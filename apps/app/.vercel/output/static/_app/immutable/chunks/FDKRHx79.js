import {
	s as Qt,
	D as Vt,
	H as zn,
	l as Bi,
	u as zi,
	m as Hi,
	o as Vi,
	n as He,
	d as z,
	q as U,
	i as Q,
	c as be,
	e as we,
	h as ke,
	k as se,
	v as Ia,
	F as So,
	w as zr,
	y as wr,
	z as Ls,
	b as J,
	g as K,
	j as W,
	R as La,
	C as Ft,
	a as Fi,
	f as ji,
	t as Ki,
	B as Pa,
	M as Ra,
	p as Mo
} from './CZvU1ekx.js';
import {
	S as Jt,
	i as Yt,
	d as w,
	t as M,
	a as S,
	m as A,
	c as E,
	b as O,
	f as Ps,
	g as Hn,
	e as Vn
} from './ZuwjM_kn.js';
import {
	a8 as as,
	i as Rt,
	q as Bt,
	h as Rs,
	a9 as Ln,
	aa as Ba,
	S as Ae,
	E as Lt,
	t as cs,
	r as za,
	F as Zt,
	o as Oe,
	I as Re,
	A as Co,
	a7 as To,
	c as Ha,
	n as xo,
	G as wn,
	ab as _,
	ac as ne,
	ad as V,
	ae as oe,
	af as $n,
	ag as L,
	ah as zt,
	ai as Fn,
	aj as Wi,
	ak as Ar,
	al as ie,
	am as Bs,
	an as et,
	ao as Xt,
	ap as ht,
	aq as Er,
	ar as zs,
	as as qi,
	at as At,
	au as us,
	av as Va,
	aw as Fa,
	ax as me,
	ay as Hs,
	az as ja,
	aA as Ka,
	aB as wo
} from './Dz2apFQ9.js';
import { I as Ui } from './BRhspWxV.js';
import { I as Gi, R as Wa, T as qa, C as Ua } from './3VOIDKNN.js';
import { g as Qi, a as Ji, c as X, B as ge } from './CTLOy2q2.js';
import { S as ze } from './CBpdtyLw.js';
import { A as Ga, W as Qa } from './NZn2UU_-.js';
import { M as Vs } from './BMSQkwth.js';
function Ja(t) {
	let e;
	const n = t[2].default,
		r = Bi(n, t, t[3], null);
	return {
		c() {
			r && r.c();
		},
		l(s) {
			r && r.l(s);
		},
		m(s, o) {
			r && r.m(s, o), (e = !0);
		},
		p(s, o) {
			r && r.p && (!e || o & 8) && zi(r, n, s, s[3], e ? Vi(n, s[3], o, null) : Hi(s[3]), null);
		},
		i(s) {
			e || (S(r, s), (e = !0));
		},
		o(s) {
			M(r, s), (e = !1);
		},
		d(s) {
			r && r.d(s);
		}
	};
}
function Ya(t) {
	let e, n;
	const r = [{ name: 'replace-all' }, t[1], { iconNode: t[0] }];
	let s = { $$slots: { default: [Ja] }, $$scope: { ctx: t } };
	for (let o = 0; o < r.length; o += 1) s = Vt(s, r[o]);
	return (
		(e = new Gi({ props: s })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), (n = !0);
			},
			p(o, [i]) {
				const l = i & 3 ? Qi(r, [r[0], i & 2 && Ji(o[1]), i & 1 && { iconNode: o[0] }]) : {};
				i & 8 && (l.$$scope = { dirty: i, ctx: o }), e.$set(l);
			},
			i(o) {
				n || (S(e.$$.fragment, o), (n = !0));
			},
			o(o) {
				M(e.$$.fragment, o), (n = !1);
			},
			d(o) {
				w(e, o);
			}
		}
	);
}
function Xa(t, e, n) {
	let { $$slots: r = {}, $$scope: s } = e;
	const o = [
		['path', { d: 'M14 4c0-1.1.9-2 2-2' }],
		['path', { d: 'M20 2c1.1 0 2 .9 2 2' }],
		['path', { d: 'M22 8c0 1.1-.9 2-2 2' }],
		['path', { d: 'M16 10c-1.1 0-2-.9-2-2' }],
		['path', { d: 'm3 7 3 3 3-3' }],
		['path', { d: 'M6 10V5c0-1.7 1.3-3 3-3h1' }],
		['rect', { width: '8', height: '8', x: '2', y: '14', rx: '2' }],
		['path', { d: 'M14 14c1.1 0 2 .9 2 2v4c0 1.1-.9 2-2 2' }],
		['path', { d: 'M20 14c1.1 0 2 .9 2 2v4c0 1.1-.9 2-2 2' }]
	];
	return (
		(t.$$set = (i) => {
			n(1, (e = Vt(Vt({}, e), zn(i)))), '$$scope' in i && n(3, (s = i.$$scope));
		}),
		(e = zn(e)),
		[o, e, r, s]
	);
}
class Za extends Jt {
	constructor(e) {
		super(), Yt(this, e, Xa, Ya, Qt, {});
	}
}
function ec(t) {
	let e;
	const n = t[2].default,
		r = Bi(n, t, t[3], null);
	return {
		c() {
			r && r.c();
		},
		l(s) {
			r && r.l(s);
		},
		m(s, o) {
			r && r.m(s, o), (e = !0);
		},
		p(s, o) {
			r && r.p && (!e || o & 8) && zi(r, n, s, s[3], e ? Vi(n, s[3], o, null) : Hi(s[3]), null);
		},
		i(s) {
			e || (S(r, s), (e = !0));
		},
		o(s) {
			M(r, s), (e = !1);
		},
		d(s) {
			r && r.d(s);
		}
	};
}
function tc(t) {
	let e, n;
	const r = [{ name: 'replace' }, t[1], { iconNode: t[0] }];
	let s = { $$slots: { default: [ec] }, $$scope: { ctx: t } };
	for (let o = 0; o < r.length; o += 1) s = Vt(s, r[o]);
	return (
		(e = new Gi({ props: s })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), (n = !0);
			},
			p(o, [i]) {
				const l = i & 3 ? Qi(r, [r[0], i & 2 && Ji(o[1]), i & 1 && { iconNode: o[0] }]) : {};
				i & 8 && (l.$$scope = { dirty: i, ctx: o }), e.$set(l);
			},
			i(o) {
				n || (S(e.$$.fragment, o), (n = !0));
			},
			o(o) {
				M(e.$$.fragment, o), (n = !1);
			},
			d(o) {
				w(e, o);
			}
		}
	);
}
function nc(t, e, n) {
	let { $$slots: r = {}, $$scope: s } = e;
	const o = [
		['path', { d: 'M14 4c0-1.1.9-2 2-2' }],
		['path', { d: 'M20 2c1.1 0 2 .9 2 2' }],
		['path', { d: 'M22 8c0 1.1-.9 2-2 2' }],
		['path', { d: 'M16 10c-1.1 0-2-.9-2-2' }],
		['path', { d: 'm3 7 3 3 3-3' }],
		['path', { d: 'M6 10V5c0-1.7 1.3-3 3-3h1' }],
		['rect', { width: '8', height: '8', x: '2', y: '14', rx: '2' }]
	];
	return (
		(t.$$set = (i) => {
			n(1, (e = Vt(Vt({}, e), zn(i)))), '$$scope' in i && n(3, (s = i.$$scope));
		}),
		(e = zn(e)),
		[o, e, r, s]
	);
}
class rc extends Jt {
	constructor(e) {
		super(), Yt(this, e, nc, tc, Qt, {});
	}
}
function Ao(t) {
	let e, n, r, s;
	return {
		c() {
			(e = ke('input')), this.h();
		},
		l(o) {
			(e = be(o, 'INPUT', { id: !0, type: !0, autocomplete: !0, autocorrect: !0, class: !0 })),
				this.h();
		},
		h() {
			U(e, 'id', 'inline-title-input'),
				U(e, 'type', 'text'),
				U(e, 'autocomplete', 'off'),
				U(e, 'autocorrect', 'off'),
				(e.disabled = n = t[2] !== 'edit'),
				U(
					e,
					'class',
					as(
						'w-[655px] prose font-bold text-4xl text-foreground mx-auto bg-transparent focus:outline-none',
						/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && 'w-[635px]'
					)
				);
		},
		m(o, i) {
			Q(o, e, i),
				So(e, t[0]),
				r || ((s = [zr(e, 'keydown', t[3]), zr(e, 'blur', t[4]), zr(e, 'input', t[6])]), (r = !0));
		},
		p(o, i) {
			i & 4 && n !== (n = o[2] !== 'edit') && (e.disabled = n),
				i & 1 && e.value !== o[0] && So(e, o[0]);
		},
		d(o) {
			o && z(e), (r = !1), Ia(s);
		}
	};
}
function sc(t) {
	let e,
		n,
		r = t[1].editor.show_inline_title && Ao(t);
	return {
		c() {
			(e = ke('div')), r && r.c(), this.h();
		},
		l(s) {
			e = be(s, 'DIV', { class: !0 });
			var o = we(e);
			r && r.l(o), o.forEach(z), this.h();
		},
		h() {
			U(
				e,
				'class',
				(n = as('flex items-center w-full h-fit px-8 pb-2.5', !t[1].editor.show_toolbar && 'mt-5'))
			);
		},
		m(s, o) {
			Q(s, e, o), r && r.m(e, null);
		},
		p(s, [o]) {
			s[1].editor.show_inline_title
				? r
					? r.p(s, o)
					: ((r = Ao(s)), r.c(), r.m(e, null))
				: r && (r.d(1), (r = null)),
				o & 2 &&
					n !==
						(n = as(
							'flex items-center w-full h-fit px-8 pb-2.5',
							!s[1].editor.show_toolbar && 'mt-5'
						)) &&
					U(e, 'class', n);
		},
		i: He,
		o: He,
		d(s) {
			s && z(e), r && r.d();
		}
	};
}
function oc(t, e, n) {
	let r, s, o, i;
	se(t, Rt, (f) => n(7, (r = f))),
		se(t, Bt, (f) => n(8, (s = f))),
		se(t, Rs, (f) => n(1, (o = f))),
		se(t, Ln, (f) => n(2, (i = f)));
	let { preCheckRegex: l = void 0 } = e,
		a = '';
	function c(f) {
		f.key === 'Enter' && s.chain().focus().run();
	}
	async function u() {
		if (r) {
			if (
				(l && !l.test(a) && n(0, (a = r.split('/').pop().split('.').slice(0, -1).join('.'))),
				a !== r.split('/').pop().split('.').slice(0, -1).join('.') && a.trim() !== '')
			)
				try {
					await Ba(r, a);
				} catch {
					n(0, (a = r.split('/').pop().split('.').slice(0, -1).join('.')));
				}
			a.trim() === '' && n(0, (a = r.split('/').pop().split('.').slice(0, -1).join('.'))),
				a.includes('.') && n(0, (a = a.split('.').slice(0, -1).join('.'))),
				n(0, (a = a.replace(/[/\\?%*:|"<>]/g, '')));
		}
	}
	Rt.subscribe((f) => {
		n(0, (a = f ? f.split('/').pop().split('.').slice(0, -1).join('.') : ''));
	});
	function d() {
		(a = this.value), n(0, a);
	}
	return (
		(t.$$set = (f) => {
			'preCheckRegex' in f && n(5, (l = f.preCheckRegex));
		}),
		[a, o, i, c, u, l, d]
	);
}
class xb extends Jt {
	constructor(e) {
		super(), Yt(this, e, oc, sc, Qt, { preCheckRegex: 5 });
	}
}
function ic(t) {
	let e, n;
	return (
		(e = new Re({
			props: { name: 'chevron', class: X('w-4 h-4', t[4] ? 'transform rotate-90' : '') }
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 16 && (o.class = X('w-4 h-4', r[4] ? 'transform rotate-90' : '')), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function lc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-full w-6 fill-muted-foreground hover:fill-foreground',
				$$slots: { default: [ic] },
				$$scope: { ctx: t }
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217744 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function ac(t) {
	let e, n;
	return (
		(e = new Ga({
			props: {
				class: X(
					'w-18px] h-[18px] stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]',
					t[1] ? 'stroke-foreground' : ''
				)
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 2 &&
					(o.class = X(
						'w-18px] h-[18px] stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]',
						r[1] ? 'stroke-foreground' : ''
					)),
					e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function cc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: X('h-7 w-7 group', t[1] ? 'bg-accent' : ''),
				$$slots: { default: [ac] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[18]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 2 && (o.class = X('h-7 w-7 group', r[1] ? 'bg-accent' : '')),
					s & 134217730 && (o.$$scope = { dirty: s, ctx: r }),
					e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function uc(t) {
	let e, n;
	return (
		(e = new Qa({
			props: {
				class: X(
					'w-4 h-4 stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]',
					t[3] ? 'stroke-foreground' : ''
				)
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 8 &&
					(o.class = X(
						'w-4 h-4 stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]',
						r[3] ? 'stroke-foreground' : ''
					)),
					e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function dc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: X('h-7 w-7 group', t[3] ? 'bg-accent' : ''),
				$$slots: { default: [uc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[19]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 8 && (o.class = X('h-7 w-7 group', r[3] ? 'bg-accent' : '')),
					s & 134217736 && (o.$$scope = { dirty: s, ctx: r }),
					e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function fc(t) {
	let e, n;
	return (
		(e = new Re({ props: { name: 'arrowUp', class: 'w-4 h-4' } })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function pc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-7 w-7 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [fc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[20]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217728 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function hc(t) {
	let e, n;
	return (
		(e = new Re({ props: { name: 'arrowDown', class: 'w-4 h-4' } })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function mc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-7 w-7 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [hc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[21]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217728 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function gc(t) {
	let e, n;
	return (
		(e = new Re({ props: { name: 'x', class: 'w-4 h-4' } })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function bc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-7 w-7 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [gc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[22]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217728 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function kc(t) {
	let e, n;
	return (
		(e = new rc({
			props: {
				class:
					'w-4 h-4 stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]'
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function yc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-7 w-7 group',
				$$slots: { default: [kc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[24]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217728 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function $c(t) {
	let e, n;
	return (
		(e = new Za({
			props: {
				class:
					'w-4 h-4 stroke-muted-foreground group-hover:stroke-foreground transition-all stroke-[1.5px]'
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Sc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-7 w-7 group',
				$$slots: { default: [$c] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[25]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 134217728 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Mc(t) {
	let e, n, r, s, o, i, l, a, c;
	function u(f) {
		t[23](f);
	}
	let d = { class: 'w-full h-7', placeholder: 'Replace', spellcheck: 'false' };
	return (
		t[0] !== void 0 && (d.value = t[0]),
		(n = new Ui({ props: d })),
		wr.push(() => Ps(n, 'value', u)),
		(i = new Oe({
			props: { text: 'Replace', side: 'bottom', $$slots: { default: [yc] }, $$scope: { ctx: t } }
		})),
		(a = new Oe({
			props: {
				text: 'Replace all',
				side: 'bottom',
				$$slots: { default: [Sc] },
				$$scope: { ctx: t }
			}
		})),
		{
			c() {
				(e = ke('div')),
					O(n.$$.fragment),
					(s = W()),
					(o = ke('div')),
					O(i.$$.fragment),
					(l = W()),
					O(a.$$.fragment),
					this.h();
			},
			l(f) {
				e = be(f, 'DIV', { class: !0 });
				var p = we(e);
				E(n.$$.fragment, p), (s = K(p)), (o = be(p, 'DIV', { class: !0 }));
				var h = we(o);
				E(i.$$.fragment, h), (l = K(h)), E(a.$$.fragment, h), h.forEach(z), p.forEach(z), this.h();
			},
			h() {
				U(o, 'class', 'flex items-center h-full pr-[90px] gap-0.5'),
					U(e, 'class', 'flex flex-row items-center justify-between h-full w-full gap-1');
			},
			m(f, p) {
				Q(f, e, p),
					A(n, e, null),
					J(e, s),
					J(e, o),
					A(i, o, null),
					J(o, l),
					A(a, o, null),
					(c = !0);
			},
			p(f, p) {
				const h = {};
				!r && p & 1 && ((r = !0), (h.value = f[0]), Ls(() => (r = !1))), n.$set(h);
				const g = {};
				p & 134217732 && (g.$$scope = { dirty: p, ctx: f }), i.$set(g);
				const m = {};
				p & 134217732 && (m.$$scope = { dirty: p, ctx: f }), a.$set(m);
			},
			i(f) {
				c || (S(n.$$.fragment, f), S(i.$$.fragment, f), S(a.$$.fragment, f), (c = !0));
			},
			o(f) {
				M(n.$$.fragment, f), M(i.$$.fragment, f), M(a.$$.fragment, f), (c = !1);
			},
			d(f) {
				f && z(e), w(n), w(i), w(a);
			}
		}
	);
}
function Cc(t) {
	let e, n, r, s, o, i, l, a, c, u, d, f, p, h, g, m, b, k, v;
	e = new qa({
		props: {
			class: 'absolute left-0 flex items-center h-full w-7',
			$$slots: { default: [lc] },
			$$scope: { ctx: t }
		}
	});
	function I(y) {
		t[17](y);
	}
	let T = { id: 'editorSearch', class: 'w-full h-7', placeholder: 'Find', spellcheck: 'false' };
	return (
		t[9] !== void 0 && (T.value = t[9]),
		(s = new Ui({ props: T })),
		wr.push(() => Ps(s, 'value', I)),
		(a = new Oe({
			props: {
				text: 'Case sensitive',
				side: 'bottom',
				$$slots: { default: [cc] },
				$$scope: { ctx: t }
			}
		})),
		(u = new Oe({
			props: { text: 'Whole word', side: 'bottom', $$slots: { default: [dc] }, $$scope: { ctx: t } }
		})),
		(f = new Oe({
			props: {
				text: 'Previous',
				side: 'bottom',
				shortcut: { shift: !0, key: 'Enter' },
				$$slots: { default: [pc] },
				$$scope: { ctx: t }
			}
		})),
		(h = new Oe({
			props: {
				text: 'Next',
				side: 'bottom',
				shortcut: { key: 'Enter' },
				$$slots: { default: [mc] },
				$$scope: { ctx: t }
			}
		})),
		(m = new Oe({
			props: { text: 'Close', side: 'bottom', $$slots: { default: [bc] }, $$scope: { ctx: t } }
		})),
		(k = new Ua({ props: { class: 'w-full', $$slots: { default: [Mc] }, $$scope: { ctx: t } } })),
		{
			c() {
				O(e.$$.fragment),
					(n = W()),
					(r = ke('div')),
					O(s.$$.fragment),
					(i = W()),
					(l = ke('div')),
					O(a.$$.fragment),
					(c = W()),
					O(u.$$.fragment),
					(d = W()),
					O(f.$$.fragment),
					(p = W()),
					O(h.$$.fragment),
					(g = W()),
					O(m.$$.fragment),
					(b = W()),
					O(k.$$.fragment),
					this.h();
			},
			l(y) {
				E(e.$$.fragment, y), (n = K(y)), (r = be(y, 'DIV', { class: !0 }));
				var D = we(r);
				E(s.$$.fragment, D), (i = K(D)), (l = be(D, 'DIV', { class: !0 }));
				var C = we(l);
				E(a.$$.fragment, C),
					(c = K(C)),
					E(u.$$.fragment, C),
					(d = K(C)),
					E(f.$$.fragment, C),
					(p = K(C)),
					E(h.$$.fragment, C),
					(g = K(C)),
					E(m.$$.fragment, C),
					C.forEach(z),
					D.forEach(z),
					(b = K(y)),
					E(k.$$.fragment, y),
					this.h();
			},
			h() {
				U(l, 'class', 'flex items-center h-full gap-0.5'),
					U(r, 'class', 'flex flex-row items-center justify-between h-full w-full gap-1 -mt-[1px]');
			},
			m(y, D) {
				A(e, y, D),
					Q(y, n, D),
					Q(y, r, D),
					A(s, r, null),
					J(r, i),
					J(r, l),
					A(a, l, null),
					J(l, c),
					A(u, l, null),
					J(l, d),
					A(f, l, null),
					J(l, p),
					A(h, l, null),
					J(l, g),
					A(m, l, null),
					Q(y, b, D),
					A(k, y, D),
					(v = !0);
			},
			p(y, D) {
				const C = {};
				D & 134217744 && (C.$$scope = { dirty: D, ctx: y }), e.$set(C);
				const F = {};
				!o && D & 512 && ((o = !0), (F.value = y[9]), Ls(() => (o = !1))), s.$set(F);
				const N = {};
				D & 134217730 && (N.$$scope = { dirty: D, ctx: y }), a.$set(N);
				const H = {};
				D & 134217736 && (H.$$scope = { dirty: D, ctx: y }), u.$set(H);
				const ue = {};
				D & 134217732 && (ue.$$scope = { dirty: D, ctx: y }), f.$set(ue);
				const Ce = {};
				D & 134217732 && (Ce.$$scope = { dirty: D, ctx: y }), h.$set(Ce);
				const R = {};
				D & 134217728 && (R.$$scope = { dirty: D, ctx: y }), m.$set(R);
				const j = {};
				D & 134217733 && (j.$$scope = { dirty: D, ctx: y }), k.$set(j);
			},
			i(y) {
				v ||
					(S(e.$$.fragment, y),
					S(s.$$.fragment, y),
					S(a.$$.fragment, y),
					S(u.$$.fragment, y),
					S(f.$$.fragment, y),
					S(h.$$.fragment, y),
					S(m.$$.fragment, y),
					S(k.$$.fragment, y),
					(v = !0));
			},
			o(y) {
				M(e.$$.fragment, y),
					M(s.$$.fragment, y),
					M(a.$$.fragment, y),
					M(u.$$.fragment, y),
					M(f.$$.fragment, y),
					M(h.$$.fragment, y),
					M(m.$$.fragment, y),
					M(k.$$.fragment, y),
					(v = !1);
			},
			d(y) {
				y && (z(n), z(r), z(b)), w(e, y), w(s), w(a), w(u), w(f), w(h), w(m), w(k, y);
			}
		}
	);
}
function Tc(t) {
	let e, n, r, s, o, i, l, a, c, u, d, f, p, h;
	(n = new ze({ props: { options: Ae['editor:search'], callback: t[13] } })),
		(s = new ze({ props: { options: { key: 'Escape' }, callback: t[14] } })),
		(i = new ze({ props: { options: { key: 'Enter' }, callback: t[15] } })),
		(a = new ze({ props: { options: { shift: !0, key: 'Enter' }, callback: t[16] } }));
	function g(b) {
		t[26](b);
	}
	let m = {
		class: 'flex relative flex-col gap-1 items-center justify-between w-full h-full pl-7',
		$$slots: { default: [Cc] },
		$$scope: { ctx: t }
	};
	return (
		t[4] !== void 0 && (m.open = t[4]),
		(u = new Wa({ props: m })),
		wr.push(() => Ps(u, 'open', g)),
		{
			c() {
				(e = ke('div')),
					O(n.$$.fragment),
					(r = W()),
					O(s.$$.fragment),
					(o = W()),
					O(i.$$.fragment),
					(l = W()),
					O(a.$$.fragment),
					(c = W()),
					O(u.$$.fragment),
					this.h();
			},
			l(b) {
				e = be(b, 'DIV', { class: !0, style: !0 });
				var k = we(e);
				E(n.$$.fragment, k),
					(r = K(k)),
					E(s.$$.fragment, k),
					(o = K(k)),
					E(i.$$.fragment, k),
					(l = K(k)),
					E(a.$$.fragment, k),
					(c = K(k)),
					E(u.$$.fragment, k),
					k.forEach(z),
					this.h();
			},
			h() {
				U(
					e,
					'class',
					(f = X(
						'fixed top-[80px] w-96 min-h-10 bg-secondary-background border z-30 rounded-md flex items-center px-1 py-1.5 transition-all duration-200',
						t[5] ? 'translate-y-0' : '-translate-y-96',
						t[6].editor.show_toolbar ? 'top-[80px]' : 'top-[48px]'
					))
				),
					U(e, 'style', (p = `right: ${t[7] ? t[8] + 16 : 16}px`));
			},
			m(b, k) {
				Q(b, e, k),
					A(n, e, null),
					J(e, r),
					A(s, e, null),
					J(e, o),
					A(i, e, null),
					J(e, l),
					A(a, e, null),
					J(e, c),
					A(u, e, null),
					(h = !0);
			},
			p(b, [k]) {
				const v = {};
				k & 32 && (v.callback = b[13]), n.$set(v);
				const I = {};
				k & 32 && (I.callback = b[14]), s.$set(I);
				const T = {};
				k & 36 && (T.callback = b[15]), i.$set(T);
				const y = {};
				k & 36 && (y.callback = b[16]), a.$set(y);
				const D = {};
				k & 134218271 && (D.$$scope = { dirty: k, ctx: b }),
					!d && k & 16 && ((d = !0), (D.open = b[4]), Ls(() => (d = !1))),
					u.$set(D),
					(!h ||
						(k & 96 &&
							f !==
								(f = X(
									'fixed top-[80px] w-96 min-h-10 bg-secondary-background border z-30 rounded-md flex items-center px-1 py-1.5 transition-all duration-200',
									b[5] ? 'translate-y-0' : '-translate-y-96',
									b[6].editor.show_toolbar ? 'top-[80px]' : 'top-[48px]'
								)))) &&
						U(e, 'class', f),
					(!h || (k & 384 && p !== (p = `right: ${b[7] ? b[8] + 16 : 16}px`))) && U(e, 'style', p);
			},
			i(b) {
				h ||
					(S(n.$$.fragment, b),
					S(s.$$.fragment, b),
					S(i.$$.fragment, b),
					S(a.$$.fragment, b),
					S(u.$$.fragment, b),
					(h = !0));
			},
			o(b) {
				M(n.$$.fragment, b),
					M(s.$$.fragment, b),
					M(i.$$.fragment, b),
					M(a.$$.fragment, b),
					M(u.$$.fragment, b),
					(h = !1);
			},
			d(b) {
				b && z(e), w(n), w(s), w(i), w(a), w(u);
			}
		}
	);
}
function xc(t, e, n) {
	let r, s, o, i, l, a;
	se(t, Bt, (R) => n(2, (r = R))),
		se(t, Lt, (R) => n(5, (s = R))),
		se(t, Rs, (R) => n(6, (o = R))),
		se(t, cs, (R) => n(7, (i = R))),
		se(t, za, (R) => n(8, (l = R))),
		se(t, Zt, (R) => n(9, (a = R)));
	let c = '',
		u = !1,
		d = !1,
		f = !1;
	const p = () => {
			if (!r) return;
			const { results: R, resultIndex: j } = r.storage.searchAndReplace,
				Te = R[j];
			if (!Te) return;
			r.commands.setTextSelection(Te);
			const { node: De } = r.view.domAtPos(r.state.selection.anchor);
			if (De instanceof HTMLElement) {
				const yo = De.getBoundingClientRect(),
					$o = yo.top < 0,
					va = yo.bottom > window.innerHeight;
				if ($o || va) {
					const _a = $o ? 'auto' : 'smooth';
					De.scrollIntoView({ behavior: _a, block: 'center' });
				}
			}
		},
		h = () => {
			if (!r) return;
			const { from: R, to: j } = r.state.selection;
			return r.state.doc.textBetween(R, j);
		},
		g = () => {
			Zt.set(''),
				n(0, (c = '')),
				n(1, (u = !1)),
				n(3, (d = !1)),
				n(4, (f = !1)),
				r.commands.resetIndex(),
				Lt.set(!1);
		};
	Lt.subscribe((R) => {
		if (R) {
			const j = document.querySelector('#editorSearch');
			j && j.focus();
		}
	}),
		Zt.subscribe((R) => {
			if (r) {
				const j = R.replace(/[.*+?^${}()|[\]\\]/g, '');
				d ? r.commands.setSearchTerm(`\\b${j}\\b`) : r.commands.setSearchTerm(j);
				try {
					p();
				} catch (Te) {
					console.error('Error selecting search result:', Te);
				}
			}
		});
	const m = () => {
			s ? g() : (Zt.set(h() || ''), Lt.set(!0));
		},
		b = () => {
			s && g();
		},
		k = () => {
			s && (r.commands.nextSearchResult(), p());
		},
		v = () => {
			s && (r.commands.previousSearchResult(), p());
		};
	function I(R) {
		(a = R), Zt.set(a);
	}
	const T = () => {
			n(1, (u = !u));
		},
		y = () => {
			n(3, (d = !d));
		},
		D = () => {
			r.commands.previousSearchResult(), p();
		},
		C = () => {
			r.commands.nextSearchResult(), p();
		},
		F = () => {
			g();
		};
	function N(R) {
		(c = R), n(0, c);
	}
	const H = () => {
			r.commands.replace(), p();
		},
		ue = () => {
			r.commands.replaceAll(), p();
		};
	function Ce(R) {
		(f = R), n(4, f);
	}
	return (
		(t.$$.update = () => {
			t.$$.dirty & 7 && r && (r.commands.setReplaceTerm(c), r.commands.setCaseSensitive(u));
		}),
		[c, u, r, d, f, s, o, i, l, a, p, h, g, m, b, k, v, I, T, y, D, C, F, N, H, ue, Ce]
	);
}
class wb extends Jt {
	constructor(e) {
		super(), Yt(this, e, xc, Tc, Qt, {});
	}
}
function Eo(t, e, n) {
	const r = t.slice();
	return (r[19] = e[n]), (r[21] = n), r;
}
function wc(t) {
	let e, n, r, s;
	return (
		(e = new ze({ props: { options: Ae['notes:toggle-sidebar'] } })),
		(r = new Re({
			props: {
				name: 'sidebarArrow',
				class: X('w-4 h-4 transform transition-transform', t[3] ? 'rotate-180' : '')
			}
		})),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o), (n = K(o)), E(r.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), Q(o, n, i), A(r, o, i), (s = !0);
			},
			p(o, i) {
				const l = {};
				i & 8 && (l.class = X('w-4 h-4 transform transition-transform', o[3] ? 'rotate-180' : '')),
					r.$set(l);
			},
			i(o) {
				s || (S(e.$$.fragment, o), S(r.$$.fragment, o), (s = !0));
			},
			o(o) {
				M(e.$$.fragment, o), M(r.$$.fragment, o), (s = !1);
			},
			d(o) {
				o && z(n), w(e, o), w(r, o);
			}
		}
	);
}
function Ac(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [wc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[11]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 4194312 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Ec(t) {
	let e, n, r;
	return {
		c() {
			(e = ke('div')), (n = W()), (r = ke('div')), this.h();
		},
		l(s) {
			(e = be(s, 'DIV', { class: !0 })),
				we(e).forEach(z),
				(n = K(s)),
				(r = be(s, 'DIV', { class: !0 })),
				we(r).forEach(z),
				this.h();
		},
		h() {
			U(e, 'class', 'w-6'), U(r, 'class', 'w-6');
		},
		m(s, o) {
			Q(s, e, o), Q(s, n, o), Q(s, r, o);
		},
		p: He,
		i: He,
		o: He,
		d(s) {
			s && (z(e), z(n), z(r));
		}
	};
}
function Oc(t) {
	let e, n, r, s;
	return (
		(e = new Oe({
			props: {
				text: 'Previous note',
				side: 'bottom',
				shortcut: Ae['notes:history-back'],
				$$slots: { default: [Dc] },
				$$scope: { ctx: t }
			}
		})),
		(r = new Oe({
			props: {
				text: 'Next note',
				side: 'bottom',
				shortcut: Ae['notes:history-forward'],
				$$slots: { default: [_c] },
				$$scope: { ctx: t }
			}
		})),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o), (n = K(o)), E(r.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), Q(o, n, i), A(r, o, i), (s = !0);
			},
			p(o, i) {
				const l = {};
				i & 4194324 && (l.$$scope = { dirty: i, ctx: o }), e.$set(l);
				const a = {};
				i & 4194324 && (a.$$scope = { dirty: i, ctx: o }), r.$set(a);
			},
			i(o) {
				s || (S(e.$$.fragment, o), S(r.$$.fragment, o), (s = !0));
			},
			o(o) {
				M(e.$$.fragment, o), M(r.$$.fragment, o), (s = !1);
			},
			d(o) {
				o && z(n), w(e, o), w(r, o);
			}
		}
	);
}
function Nc(t) {
	let e, n, r, s;
	return (
		(e = new ze({ props: { options: Ae['notes:history-back'], callback: t[12] } })),
		(r = new Re({ props: { name: 'arrowLeft', class: 'w-4 h-4' } })),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o), (n = K(o)), E(r.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), Q(o, n, i), A(r, o, i), (s = !0);
			},
			p(o, i) {
				const l = {};
				i & 20 && (l.callback = o[12]), e.$set(l);
			},
			i(o) {
				s || (S(e.$$.fragment, o), S(r.$$.fragment, o), (s = !0));
			},
			o(o) {
				M(e.$$.fragment, o), M(r.$$.fragment, o), (s = !1);
			},
			d(o) {
				o && z(n), w(e, o), w(r, o);
			}
		}
	);
}
function Dc(t) {
	var r, s;
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				disabled:
					!((r = t[4]) != null && r.length) ||
					((s = t[4]) == null ? void 0 : s.length) === 1 ||
					t[2] === 0,
				$$slots: { default: [Nc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[13]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), (n = !0);
			},
			p(o, i) {
				var a, c;
				const l = {};
				i & 20 &&
					(l.disabled =
						!((a = o[4]) != null && a.length) ||
						((c = o[4]) == null ? void 0 : c.length) === 1 ||
						o[2] === 0),
					i & 4194324 && (l.$$scope = { dirty: i, ctx: o }),
					e.$set(l);
			},
			i(o) {
				n || (S(e.$$.fragment, o), (n = !0));
			},
			o(o) {
				M(e.$$.fragment, o), (n = !1);
			},
			d(o) {
				w(e, o);
			}
		}
	);
}
function vc(t) {
	let e, n, r, s;
	return (
		(e = new ze({ props: { options: Ae['notes:history-forward'], callback: t[14] } })),
		(r = new Re({ props: { name: 'arrowRight', class: 'w-4 h-4' } })),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o), (n = K(o)), E(r.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), Q(o, n, i), A(r, o, i), (s = !0);
			},
			p(o, i) {
				const l = {};
				i & 20 && (l.callback = o[14]), e.$set(l);
			},
			i(o) {
				s || (S(e.$$.fragment, o), S(r.$$.fragment, o), (s = !0));
			},
			o(o) {
				M(e.$$.fragment, o), M(r.$$.fragment, o), (s = !1);
			},
			d(o) {
				o && z(n), w(e, o), w(r, o);
			}
		}
	);
}
function _c(t) {
	var r, s, o;
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				disabled:
					!((r = t[4]) != null && r.length) ||
					((s = t[4]) == null ? void 0 : s.length) === 1 ||
					t[2] === ((o = t[4]) == null ? void 0 : o.length) - 1,
				$$slots: { default: [vc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[15]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(i) {
				E(e.$$.fragment, i);
			},
			m(i, l) {
				A(e, i, l), (n = !0);
			},
			p(i, l) {
				var c, u, d;
				const a = {};
				l & 20 &&
					(a.disabled =
						!((c = i[4]) != null && c.length) ||
						((u = i[4]) == null ? void 0 : u.length) === 1 ||
						i[2] === ((d = i[4]) == null ? void 0 : d.length) - 1),
					l & 4194324 && (a.$$scope = { dirty: l, ctx: i }),
					e.$set(a);
			},
			i(i) {
				n || (S(e.$$.fragment, i), (n = !0));
			},
			o(i) {
				M(e.$$.fragment, i), (n = !1);
			},
			d(i) {
				w(e, i);
			}
		}
	);
}
function Ic(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'sm',
				variant: 'ghost',
				scale: 'sm',
				class: 'h-6 text-[13px] w-fit px-1.5 text-foreground transition-all font-medium',
				$$slots: { default: [Pc] },
				$$scope: { ctx: t }
			}
		})),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 4194400 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Lc(t) {
	var i;
	let e,
		n,
		r = xo(((i = t[5]) == null ? void 0 : i.replace(t[6], '').split('/')) ?? []),
		s = [];
	for (let l = 0; l < r.length; l += 1) s[l] = No(Eo(t, r, l));
	const o = (l) =>
		M(s[l], 1, 1, () => {
			s[l] = null;
		});
	return {
		c() {
			for (let l = 0; l < s.length; l += 1) s[l].c();
			e = Ft();
		},
		l(l) {
			for (let a = 0; a < s.length; a += 1) s[a].l(l);
			e = Ft();
		},
		m(l, a) {
			for (let c = 0; c < s.length; c += 1) s[c] && s[c].m(l, a);
			Q(l, e, a), (n = !0);
		},
		p(l, a) {
			var c;
			if (a & 96) {
				r = xo(((c = l[5]) == null ? void 0 : c.replace(l[6], '').split('/')) ?? []);
				let u;
				for (u = 0; u < r.length; u += 1) {
					const d = Eo(l, r, u);
					s[u]
						? (s[u].p(d, a), S(s[u], 1))
						: ((s[u] = No(d)), s[u].c(), S(s[u], 1), s[u].m(e.parentNode, e));
				}
				for (Hn(), u = r.length; u < s.length; u += 1) o(u);
				Vn();
			}
		},
		i(l) {
			if (!n) {
				for (let a = 0; a < r.length; a += 1) S(s[a]);
				n = !0;
			}
		},
		o(l) {
			s = s.filter(Boolean);
			for (let a = 0; a < s.length; a += 1) M(s[a]);
			n = !1;
		},
		d(l) {
			l && z(e), La(s, l);
		}
	};
}
function Pc(t) {
	var r, s;
	let e =
			(((s = (r = t[5]) == null ? void 0 : r.replace(t[6], '').split('/')) == null
				? void 0
				: s.slice(-1)[0]) ?? '') + '',
		n;
	return {
		c() {
			n = Ki(e);
		},
		l(o) {
			n = ji(o, e);
		},
		m(o, i) {
			Q(o, n, i);
		},
		p(o, i) {
			var l, a;
			i & 96 &&
				e !==
					(e =
						(((a = (l = o[5]) == null ? void 0 : l.replace(o[6], '').split('/')) == null
							? void 0
							: a.slice(-1)[0]) ?? '') + '') &&
				Fi(n, e);
		},
		d(o) {
			o && z(n);
		}
	};
}
function Rc(t) {
	var l, a, c, u;
	let e,
		n,
		r =
			t[21] !==
			((a = ((l = t[5]) == null ? void 0 : l.replace(t[6], '').split('/')) ?? []) == null
				? void 0
				: a.length) -
				1,
		s,
		o;
	e = new ge({
		props: {
			size: 'sm',
			variant: 'ghost',
			scale: 'sm',
			class: X(
				'h-6 text-[13px] w-fit px-1.5 fill-muted-foreground hover:fill-foreground transition-all font-normal',
				t[21] ===
					((u = ((c = t[5]) == null ? void 0 : c.replace(t[6], '').split('/')) ?? []) == null
						? void 0
						: u.length) -
						1 && 'text-foreground font-medium'
			),
			$$slots: { default: [Bc] },
			$$scope: { ctx: t }
		}
	});
	let i = r && Oo();
	return {
		c() {
			O(e.$$.fragment), (n = W()), i && i.c(), (s = Ft());
		},
		l(d) {
			E(e.$$.fragment, d), (n = K(d)), i && i.l(d), (s = Ft());
		},
		m(d, f) {
			A(e, d, f), Q(d, n, f), i && i.m(d, f), Q(d, s, f), (o = !0);
		},
		p(d, f) {
			var h, g, m, b;
			const p = {};
			f & 96 &&
				(p.class = X(
					'h-6 text-[13px] w-fit px-1.5 fill-muted-foreground hover:fill-foreground transition-all font-normal',
					d[21] ===
						((g = ((h = d[5]) == null ? void 0 : h.replace(d[6], '').split('/')) ?? []) == null
							? void 0
							: g.length) -
							1 && 'text-foreground font-medium'
				)),
				f & 4194400 && (p.$$scope = { dirty: f, ctx: d }),
				e.$set(p),
				f & 96 &&
					(r =
						d[21] !==
						((b = ((m = d[5]) == null ? void 0 : m.replace(d[6], '').split('/')) ?? []) == null
							? void 0
							: b.length) -
							1),
				r
					? i
						? f & 96 && S(i, 1)
						: ((i = Oo()), i.c(), S(i, 1), i.m(s.parentNode, s))
					: i &&
						(Hn(),
						M(i, 1, 1, () => {
							i = null;
						}),
						Vn());
		},
		i(d) {
			o || (S(e.$$.fragment, d), S(i), (o = !0));
		},
		o(d) {
			M(e.$$.fragment, d), M(i), (o = !1);
		},
		d(d) {
			d && (z(n), z(s)), w(e, d), i && i.d(d);
		}
	};
}
function Bc(t) {
	let e = t[19] + '',
		n;
	return {
		c() {
			n = Ki(e);
		},
		l(r) {
			n = ji(r, e);
		},
		m(r, s) {
			Q(r, n, s);
		},
		p(r, s) {
			s & 96 && e !== (e = r[19] + '') && Fi(n, e);
		},
		d(r) {
			r && z(n);
		}
	};
}
function Oo(t) {
	let e, n;
	return (
		(e = new Re({ props: { name: 'chevron', class: 'w-3.5 h-3.5 inline-block' } })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function No(t) {
	let e,
		n,
		r = t[21] !== 0 && Rc(t);
	return {
		c() {
			r && r.c(), (e = Ft());
		},
		l(s) {
			r && r.l(s), (e = Ft());
		},
		m(s, o) {
			r && r.m(s, o), Q(s, e, o), (n = !0);
		},
		p(s, o) {
			s[21] !== 0 && r.p(s, o);
		},
		i(s) {
			n || (S(r), (n = !0));
		},
		o(s) {
			M(r), (n = !1);
		},
		d(s) {
			s && z(e), r && r.d(s);
		}
	};
}
function zc(t) {
	let e, n, r, s, o, i;
	return (
		(e = new ze({ props: { options: Ae['editor:toggle-mode'] } })),
		(r = new Re({
			props: { name: 'editPencil', class: X('w-4 h-4', t[7] === 'edit' && 'hidden') }
		})),
		(o = new Re({ props: { name: 'glasses', class: X('w-4 h-4', t[7] === 'view' && 'hidden') } })),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment), (s = W()), O(o.$$.fragment);
			},
			l(l) {
				E(e.$$.fragment, l), (n = K(l)), E(r.$$.fragment, l), (s = K(l)), E(o.$$.fragment, l);
			},
			m(l, a) {
				A(e, l, a), Q(l, n, a), A(r, l, a), Q(l, s, a), A(o, l, a), (i = !0);
			},
			p(l, a) {
				const c = {};
				a & 128 && (c.class = X('w-4 h-4', l[7] === 'edit' && 'hidden')), r.$set(c);
				const u = {};
				a & 128 && (u.class = X('w-4 h-4', l[7] === 'view' && 'hidden')), o.$set(u);
			},
			i(l) {
				i || (S(e.$$.fragment, l), S(r.$$.fragment, l), S(o.$$.fragment, l), (i = !0));
			},
			o(l) {
				M(e.$$.fragment, l), M(r.$$.fragment, l), M(o.$$.fragment, l), (i = !1);
			},
			d(l) {
				l && (z(n), z(s)), w(e, l), w(r, l), w(o, l);
			}
		}
	);
}
function Hc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [zc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[16]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 4194432 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Vc(t) {
	let e, n;
	return (
		(e = new Re({ props: { name: 'searchDocument', class: X('w-4 h-4') } })),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p: He,
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Fc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [Vc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[17]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 4194304 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function jc(t) {
	let e, n, r, s;
	return (
		(e = new ze({ props: { options: Ae['notes:toggle-details'] } })),
		(r = new Re({
			props: {
				name: 'sidebarArrow',
				class: X('w-4 h-4 transform transition-transform', t[10] ? '' : 'rotate-180')
			}
		})),
		{
			c() {
				O(e.$$.fragment), (n = W()), O(r.$$.fragment);
			},
			l(o) {
				E(e.$$.fragment, o), (n = K(o)), E(r.$$.fragment, o);
			},
			m(o, i) {
				A(e, o, i), Q(o, n, i), A(r, o, i), (s = !0);
			},
			p(o, i) {
				const l = {};
				i & 1024 &&
					(l.class = X('w-4 h-4 transform transition-transform', o[10] ? '' : 'rotate-180')),
					r.$set(l);
			},
			i(o) {
				s || (S(e.$$.fragment, o), S(r.$$.fragment, o), (s = !0));
			},
			o(o) {
				M(e.$$.fragment, o), M(r.$$.fragment, o), (s = !1);
			},
			d(o) {
				o && z(n), w(e, o), w(r, o);
			}
		}
	);
}
function Kc(t) {
	let e, n;
	return (
		(e = new ge({
			props: {
				size: 'icon',
				variant: 'ghost',
				scale: 'md',
				class: 'h-6 w-6 fill-muted-foreground hover:fill-foreground transition-all',
				$$slots: { default: [jc] },
				$$scope: { ctx: t }
			}
		})),
		e.$on('click', t[18]),
		{
			c() {
				O(e.$$.fragment);
			},
			l(r) {
				E(e.$$.fragment, r);
			},
			m(r, s) {
				A(e, r, s), (n = !0);
			},
			p(r, s) {
				const o = {};
				s & 4195328 && (o.$$scope = { dirty: s, ctx: r }), e.$set(o);
			},
			i(r) {
				n || (S(e.$$.fragment, r), (n = !0));
			},
			o(r) {
				M(e.$$.fragment, r), (n = !1);
			},
			d(r) {
				w(e, r);
			}
		}
	);
}
function Wc(t) {
	let e, n, r, s, o, i, l, a, c, u, d, f, p, h, g, m, b, k, v;
	r = new Oe({
		props: {
			text: t[3] ? 'Collapse' : 'Expand',
			side: 'bottom',
			shortcut: Ae['notes:toggle-sidebar'],
			$$slots: { default: [Ac] },
			$$scope: { ctx: t }
		}
	});
	const I = [Oc, Ec],
		T = [];
	function y(N, H) {
		return N[0] ? 1 : 0;
	}
	(o = y(t)), (i = T[o] = I[o](t));
	const D = [Lc, Ic],
		C = [];
	function F(N, H) {
		return N[1] ? 1 : 0;
	}
	return (
		(u = F(t)),
		(d = C[u] = D[u](t)),
		(h = new Oe({
			props: {
				text: t[7] === 'edit' ? 'View mode' : 'Edit mode',
				side: 'bottom',
				shortcut: Ae['editor:toggle-mode'],
				$$slots: { default: [Hc] },
				$$scope: { ctx: t }
			}
		})),
		(m = new Oe({
			props: {
				text: 'Search',
				side: 'bottom',
				shortcut: Ae['editor:search'],
				$$slots: { default: [Fc] },
				$$scope: { ctx: t }
			}
		})),
		(k = new Oe({
			props: {
				text: 'Expand',
				side: 'bottom',
				shortcut: Ae['notes:toggle-details'],
				$$slots: { default: [Kc] },
				$$scope: { ctx: t }
			}
		})),
		{
			c() {
				(e = ke('div')),
					(n = ke('div')),
					O(r.$$.fragment),
					(s = W()),
					i.c(),
					(l = W()),
					(a = ke('div')),
					(c = ke('p')),
					d.c(),
					(f = W()),
					(p = ke('div')),
					O(h.$$.fragment),
					(g = W()),
					O(m.$$.fragment),
					(b = W()),
					O(k.$$.fragment),
					this.h();
			},
			l(N) {
				e = be(N, 'DIV', { class: !0 });
				var H = we(e);
				n = be(H, 'DIV', { class: !0 });
				var ue = we(n);
				E(r.$$.fragment, ue),
					(s = K(ue)),
					i.l(ue),
					ue.forEach(z),
					(l = K(H)),
					(a = be(H, 'DIV', { class: !0 }));
				var Ce = we(a);
				c = be(Ce, 'P', { class: !0 });
				var R = we(c);
				d.l(R), R.forEach(z), Ce.forEach(z), (f = K(H)), (p = be(H, 'DIV', { class: !0 }));
				var j = we(p);
				E(h.$$.fragment, j),
					(g = K(j)),
					E(m.$$.fragment, j),
					(b = K(j)),
					E(k.$$.fragment, j),
					j.forEach(z),
					H.forEach(z),
					this.h();
			},
			h() {
				U(n, 'class', 'flex gap-1.5 select-none'),
					U(c, 'class', 'text-xs flex items-center text-muted-foreground fill-muted-foreground'),
					U(a, 'class', 'flex gap-1.5'),
					U(p, 'class', 'flex gap-1.5'),
					U(
						e,
						'class',
						'sticky gap-2 min-h-10 top-0 px-3 z-50 flex items-center justify-between w-full bg-secondary-background'
					);
			},
			m(N, H) {
				Q(N, e, H),
					J(e, n),
					A(r, n, null),
					J(n, s),
					T[o].m(n, null),
					J(e, l),
					J(e, a),
					J(a, c),
					C[u].m(c, null),
					J(e, f),
					J(e, p),
					A(h, p, null),
					J(p, g),
					A(m, p, null),
					J(p, b),
					A(k, p, null),
					(v = !0);
			},
			p(N, [H]) {
				const ue = {};
				H & 8 && (ue.text = N[3] ? 'Collapse' : 'Expand'),
					H & 4194312 && (ue.$$scope = { dirty: H, ctx: N }),
					r.$set(ue);
				let Ce = o;
				(o = y(N)),
					o === Ce
						? T[o].p(N, H)
						: (Hn(),
							M(T[Ce], 1, 1, () => {
								T[Ce] = null;
							}),
							Vn(),
							(i = T[o]),
							i ? i.p(N, H) : ((i = T[o] = I[o](N)), i.c()),
							S(i, 1),
							i.m(n, null));
				let R = u;
				(u = F(N)),
					u === R
						? C[u].p(N, H)
						: (Hn(),
							M(C[R], 1, 1, () => {
								C[R] = null;
							}),
							Vn(),
							(d = C[u]),
							d ? d.p(N, H) : ((d = C[u] = D[u](N)), d.c()),
							S(d, 1),
							d.m(c, null));
				const j = {};
				H & 128 && (j.text = N[7] === 'edit' ? 'View mode' : 'Edit mode'),
					H & 4194688 && (j.$$scope = { dirty: H, ctx: N }),
					h.$set(j);
				const Te = {};
				H & 4194816 && (Te.$$scope = { dirty: H, ctx: N }), m.$set(Te);
				const De = {};
				H & 4195328 && (De.$$scope = { dirty: H, ctx: N }), k.$set(De);
			},
			i(N) {
				v ||
					(S(r.$$.fragment, N),
					S(i),
					S(d),
					S(h.$$.fragment, N),
					S(m.$$.fragment, N),
					S(k.$$.fragment, N),
					(v = !0));
			},
			o(N) {
				M(r.$$.fragment, N),
					M(i),
					M(d),
					M(h.$$.fragment, N),
					M(m.$$.fragment, N),
					M(k.$$.fragment, N),
					(v = !1);
			},
			d(N) {
				N && z(e), w(r), T[o].d(), C[u].d(), w(h), w(m), w(k);
			}
		}
	);
}
function qc(t, e, n) {
	let r, s, o, i, l, a, c, u;
	se(t, Co, (y) => n(3, (r = y))),
		se(t, To, (y) => n(4, (s = y))),
		se(t, Rt, (y) => n(5, (o = y))),
		se(t, Ha, (y) => n(6, (i = y))),
		se(t, Ln, (y) => n(7, (l = y))),
		se(t, Bt, (y) => n(8, (a = y))),
		se(t, Lt, (y) => n(9, (c = y))),
		se(t, cs, (y) => n(10, (u = y)));
	let { hideHistory: d = !1 } = e,
		{ hideParentDirectories: f = !1 } = e,
		p = 0;
	To.subscribe((y) => {
		n(2, (p = y.length - 1));
	});
	const h = () => {
			Co.update((y) => !y);
		},
		g = () => {
			!(s != null && s.length) ||
				(s == null ? void 0 : s.length) === 1 ||
				p === 0 ||
				(n(2, p--, p), wn(s[p], !0));
		},
		m = () => {
			n(2, p--, p), wn(s[p], !0);
		},
		b = () => {
			!(s != null && s.length) ||
				(s == null ? void 0 : s.length) === 1 ||
				p === (s == null ? void 0 : s.length) - 1 ||
				(n(2, p++, p), wn(s[p], !0));
		},
		k = () => {
			n(2, p++, p), wn(s[p], !0);
		},
		v = () => {
			l === 'edit'
				? (a.setEditable(!1), Ln.set('view'))
				: l === 'view' && (a.setEditable(!0), Ln.set('edit'));
		},
		I = () => {
			Lt.set(!c);
		},
		T = () => {
			cs.update((y) => !y);
		};
	return (
		(t.$$set = (y) => {
			'hideHistory' in y && n(0, (d = y.hideHistory)),
				'hideParentDirectories' in y && n(1, (f = y.hideParentDirectories));
		}),
		[d, f, p, r, s, o, i, l, a, c, u, h, g, m, b, k, v, I, T]
	);
}
class Ab extends Jt {
	constructor(e) {
		super(), Yt(this, e, qc, Wc, Qt, { hideHistory: 0, hideParentDirectories: 1 });
	}
}
const de = function (t) {
		for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
	},
	jt = function (t) {
		let e = t.assignedSlot || t.parentNode;
		return e && e.nodeType == 11 ? e.host : e;
	};
let ds = null;
const Xe = function (t, e, n) {
		let r = ds || (ds = document.createRange());
		return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
	},
	Uc = function () {
		ds = null;
	},
	Et = function (t, e, n, r) {
		return n && (Do(t, e, n, r, -1) || Do(t, e, n, r, 1));
	},
	Gc = /^(img|br|input|textarea|hr)$/i;
function Do(t, e, n, r, s) {
	for (var o; ; ) {
		if (t == n && e == r) return !0;
		if (e == (s < 0 ? 0 : Le(t))) {
			let i = t.parentNode;
			if (!i || i.nodeType != 1 || Sn(t) || Gc.test(t.nodeName) || t.contentEditable == 'false')
				return !1;
			(e = de(t) + (s < 0 ? 0 : 1)), (t = i);
		} else if (t.nodeType == 1) {
			let i = t.childNodes[e + (s < 0 ? -1 : 0)];
			if (i.nodeType == 1 && i.contentEditable == 'false')
				if (!((o = i.pmViewDesc) === null || o === void 0) && o.ignoreForSelection) e += s;
				else return !1;
			else (t = i), (e = s < 0 ? Le(t) : 0);
		} else return !1;
	}
}
function Le(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Qc(t, e) {
	for (;;) {
		if (t.nodeType == 3 && e) return t;
		if (t.nodeType == 1 && e > 0) {
			if (t.contentEditable == 'false') return null;
			(t = t.childNodes[e - 1]), (e = Le(t));
		} else if (t.parentNode && !Sn(t)) (e = de(t)), (t = t.parentNode);
		else return null;
	}
}
function Jc(t, e) {
	for (;;) {
		if (t.nodeType == 3 && e < t.nodeValue.length) return t;
		if (t.nodeType == 1 && e < t.childNodes.length) {
			if (t.contentEditable == 'false') return null;
			(t = t.childNodes[e]), (e = 0);
		} else if (t.parentNode && !Sn(t)) (e = de(t) + 1), (t = t.parentNode);
		else return null;
	}
}
function Yc(t, e, n) {
	for (let r = e == 0, s = e == Le(t); r || s; ) {
		if (t == n) return !0;
		let o = de(t);
		if (((t = t.parentNode), !t)) return !1;
		(r = r && o == 0), (s = s && o == Le(t));
	}
}
function Sn(t) {
	let e;
	for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
	return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Or = function (t) {
	return t.focusNode && Et(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function kt(t, e) {
	let n = document.createEvent('Event');
	return n.initEvent('keydown', !0, !0), (n.keyCode = t), (n.key = n.code = e), n;
}
function Xc(t) {
	let e = t.activeElement;
	for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
	return e;
}
function Zc(t, e, n) {
	if (t.caretPositionFromPoint)
		try {
			let r = t.caretPositionFromPoint(e, n);
			if (r) return { node: r.offsetNode, offset: Math.min(Le(r.offsetNode), r.offset) };
		} catch {}
	if (t.caretRangeFromPoint) {
		let r = t.caretRangeFromPoint(e, n);
		if (r) return { node: r.startContainer, offset: Math.min(Le(r.startContainer), r.startOffset) };
	}
}
const We = typeof navigator < 'u' ? navigator : null,
	vo = typeof document < 'u' ? document : null,
	mt = (We && We.userAgent) || '',
	fs = /Edge\/(\d+)/.exec(mt),
	Yi = /MSIE \d/.exec(mt),
	ps = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(mt),
	Ee = !!(Yi || ps || fs),
	ut = Yi ? document.documentMode : ps ? +ps[1] : fs ? +fs[1] : 0,
	Ve = !Ee && /gecko\/(\d+)/i.test(mt);
Ve && +(/Firefox\/(\d+)/.exec(mt) || [0, 0])[1];
const hs = !Ee && /Chrome\/(\d+)/.exec(mt),
	he = !!hs,
	Xi = hs ? +hs[1] : 0,
	ye = !Ee && !!We && /Apple Computer/.test(We.vendor),
	Kt = ye && (/Mobile\/\w+/.test(mt) || (!!We && We.maxTouchPoints > 2)),
	Ie = Kt || (We ? /Mac/.test(We.platform) : !1),
	eu = We ? /Win/.test(We.platform) : !1,
	Ze = /Android \d/.test(mt),
	Mn = !!vo && 'webkitFontSmoothing' in vo.documentElement.style,
	tu = Mn ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function nu(t) {
	let e = t.defaultView && t.defaultView.visualViewport;
	return e
		? { left: 0, right: e.width, top: 0, bottom: e.height }
		: {
				left: 0,
				right: t.documentElement.clientWidth,
				top: 0,
				bottom: t.documentElement.clientHeight
			};
}
function Ge(t, e) {
	return typeof t == 'number' ? t : t[e];
}
function ru(t) {
	let e = t.getBoundingClientRect(),
		n = e.width / t.offsetWidth || 1,
		r = e.height / t.offsetHeight || 1;
	return {
		left: e.left,
		right: e.left + t.clientWidth * n,
		top: e.top,
		bottom: e.top + t.clientHeight * r
	};
}
function _o(t, e, n) {
	let r = t.someProp('scrollThreshold') || 0,
		s = t.someProp('scrollMargin') || 5,
		o = t.dom.ownerDocument;
	for (let i = n || t.dom; i; ) {
		if (i.nodeType != 1) {
			i = jt(i);
			continue;
		}
		let l = i,
			a = l == o.body,
			c = a ? nu(o) : ru(l),
			u = 0,
			d = 0;
		if (
			(e.top < c.top + Ge(r, 'top')
				? (d = -(c.top - e.top + Ge(s, 'top')))
				: e.bottom > c.bottom - Ge(r, 'bottom') &&
					(d =
						e.bottom - e.top > c.bottom - c.top
							? e.top + Ge(s, 'top') - c.top
							: e.bottom - c.bottom + Ge(s, 'bottom')),
			e.left < c.left + Ge(r, 'left')
				? (u = -(c.left - e.left + Ge(s, 'left')))
				: e.right > c.right - Ge(r, 'right') && (u = e.right - c.right + Ge(s, 'right')),
			u || d)
		)
			if (a) o.defaultView.scrollBy(u, d);
			else {
				let p = l.scrollLeft,
					h = l.scrollTop;
				d && (l.scrollTop += d), u && (l.scrollLeft += u);
				let g = l.scrollLeft - p,
					m = l.scrollTop - h;
				e = { left: e.left - g, top: e.top - m, right: e.right - g, bottom: e.bottom - m };
			}
		let f = a ? 'fixed' : getComputedStyle(i).position;
		if (/^(fixed|sticky)$/.test(f)) break;
		i = f == 'absolute' ? i.offsetParent : jt(i);
	}
}
function su(t) {
	let e = t.dom.getBoundingClientRect(),
		n = Math.max(0, e.top),
		r,
		s;
	for (let o = (e.left + e.right) / 2, i = n + 1; i < Math.min(innerHeight, e.bottom); i += 5) {
		let l = t.root.elementFromPoint(o, i);
		if (!l || l == t.dom || !t.dom.contains(l)) continue;
		let a = l.getBoundingClientRect();
		if (a.top >= n - 20) {
			(r = l), (s = a.top);
			break;
		}
	}
	return { refDOM: r, refTop: s, stack: Zi(t.dom) };
}
function Zi(t) {
	let e = [],
		n = t.ownerDocument;
	for (
		let r = t;
		r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
		r = jt(r)
	);
	return e;
}
function ou({ refDOM: t, refTop: e, stack: n }) {
	let r = t ? t.getBoundingClientRect().top : 0;
	el(n, r == 0 ? 0 : r - e);
}
function el(t, e) {
	for (let n = 0; n < t.length; n++) {
		let { dom: r, top: s, left: o } = t[n];
		r.scrollTop != s + e && (r.scrollTop = s + e), r.scrollLeft != o && (r.scrollLeft = o);
	}
}
let Dt = null;
function iu(t) {
	if (t.setActive) return t.setActive();
	if (Dt) return t.focus(Dt);
	let e = Zi(t);
	t.focus(
		Dt == null
			? {
					get preventScroll() {
						return (Dt = { preventScroll: !0 }), !0;
					}
				}
			: void 0
	),
		Dt || ((Dt = !1), el(e, 0));
}
function tl(t, e) {
	let n,
		r = 2e8,
		s,
		o = 0,
		i = e.top,
		l = e.top,
		a,
		c;
	for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
		let f;
		if (u.nodeType == 1) f = u.getClientRects();
		else if (u.nodeType == 3) f = Xe(u).getClientRects();
		else continue;
		for (let p = 0; p < f.length; p++) {
			let h = f[p];
			if (h.top <= i && h.bottom >= l) {
				(i = Math.max(h.bottom, i)), (l = Math.min(h.top, l));
				let g = h.left > e.left ? h.left - e.left : h.right < e.left ? e.left - h.right : 0;
				if (g < r) {
					(n = u),
						(r = g),
						(s =
							g && n.nodeType == 3 ? { left: h.right < e.left ? h.right : h.left, top: e.top } : e),
						u.nodeType == 1 && g && (o = d + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
					continue;
				}
			} else
				h.top > e.top &&
					!a &&
					h.left <= e.left &&
					h.right >= e.left &&
					((a = u), (c = { left: Math.max(h.left, Math.min(h.right, e.left)), top: h.top }));
			!n &&
				((e.left >= h.right && e.top >= h.top) || (e.left >= h.left && e.top >= h.bottom)) &&
				(o = d + 1);
		}
	}
	return (
		!n && a && ((n = a), (s = c), (r = 0)),
		n && n.nodeType == 3
			? lu(n, s)
			: !n || (r && n.nodeType == 1)
				? { node: t, offset: o }
				: tl(n, s)
	);
}
function lu(t, e) {
	let n = t.nodeValue.length,
		r = document.createRange();
	for (let s = 0; s < n; s++) {
		r.setEnd(t, s + 1), r.setStart(t, s);
		let o = rt(r, 1);
		if (o.top != o.bottom && Fs(e, o))
			return { node: t, offset: s + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
	}
	return { node: t, offset: 0 };
}
function Fs(t, e) {
	return (
		t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1
	);
}
function au(t, e) {
	let n = t.parentNode;
	return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function cu(t, e, n) {
	let { node: r, offset: s } = tl(e, n),
		o = -1;
	if (r.nodeType == 1 && !r.firstChild) {
		let i = r.getBoundingClientRect();
		o = i.left != i.right && n.left > (i.left + i.right) / 2 ? 1 : -1;
	}
	return t.docView.posFromDOM(r, s, o);
}
function uu(t, e, n, r) {
	let s = -1;
	for (let o = e, i = !1; o != t.dom; ) {
		let l = t.docView.nearestDesc(o, !0),
			a;
		if (!l) return null;
		if (
			l.dom.nodeType == 1 &&
			((l.node.isBlock && l.parent) || !l.contentDOM) &&
			((a = l.dom.getBoundingClientRect()).width || a.height) &&
			(l.node.isBlock &&
				l.parent &&
				((!i && a.left > r.left) || a.top > r.top
					? (s = l.posBefore)
					: ((!i && a.right < r.left) || a.bottom < r.top) && (s = l.posAfter),
				(i = !0)),
			!l.contentDOM && s < 0 && !l.node.isText)
		)
			return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2)
				? l.posBefore
				: l.posAfter;
		o = l.dom.parentNode;
	}
	return s > -1 ? s : t.docView.posFromDOM(e, n, -1);
}
function nl(t, e, n) {
	let r = t.childNodes.length;
	if (r && n.top < n.bottom)
		for (
			let s = Math.max(
					0,
					Math.min(r - 1, Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) - 2)
				),
				o = s;
			;

		) {
			let i = t.childNodes[o];
			if (i.nodeType == 1) {
				let l = i.getClientRects();
				for (let a = 0; a < l.length; a++) {
					let c = l[a];
					if (Fs(e, c)) return nl(i, e, c);
				}
			}
			if ((o = (o + 1) % r) == s) break;
		}
	return t;
}
function du(t, e) {
	let n = t.dom.ownerDocument,
		r,
		s = 0,
		o = Zc(n, e.left, e.top);
	o && ({ node: r, offset: s } = o);
	let i = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top),
		l;
	if (!i || !t.dom.contains(i.nodeType != 1 ? i.parentNode : i)) {
		let c = t.dom.getBoundingClientRect();
		if (!Fs(e, c) || ((i = nl(t.dom, e, c)), !i)) return null;
	}
	if (ye) for (let c = i; r && c; c = jt(c)) c.draggable && (r = void 0);
	if (((i = au(i, e)), r)) {
		if (
			Ve &&
			r.nodeType == 1 &&
			((s = Math.min(s, r.childNodes.length)), s < r.childNodes.length)
		) {
			let u = r.childNodes[s],
				d;
			u.nodeName == 'IMG' &&
				(d = u.getBoundingClientRect()).right <= e.left &&
				d.bottom > e.top &&
				s++;
		}
		let c;
		Mn &&
			s &&
			r.nodeType == 1 &&
			(c = r.childNodes[s - 1]).nodeType == 1 &&
			c.contentEditable == 'false' &&
			c.getBoundingClientRect().top >= e.top &&
			s--,
			r == t.dom &&
			s == r.childNodes.length - 1 &&
			r.lastChild.nodeType == 1 &&
			e.top > r.lastChild.getBoundingClientRect().bottom
				? (l = t.state.doc.content.size)
				: (s == 0 || r.nodeType != 1 || r.childNodes[s - 1].nodeName != 'BR') &&
					(l = uu(t, r, s, e));
	}
	l == null && (l = cu(t, i, e));
	let a = t.docView.nearestDesc(i, !0);
	return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function Io(t) {
	return t.top < t.bottom || t.left < t.right;
}
function rt(t, e) {
	let n = t.getClientRects();
	if (n.length) {
		let r = n[e < 0 ? 0 : n.length - 1];
		if (Io(r)) return r;
	}
	return Array.prototype.find.call(n, Io) || t.getBoundingClientRect();
}
const fu = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function rl(t, e, n) {
	let { node: r, offset: s, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1),
		i = Mn || Ve;
	if (r.nodeType == 3)
		if (i && (fu.test(r.nodeValue) || (n < 0 ? !s : s == r.nodeValue.length))) {
			let a = rt(Xe(r, s, s), n);
			if (Ve && s && /\s/.test(r.nodeValue[s - 1]) && s < r.nodeValue.length) {
				let c = rt(Xe(r, s - 1, s - 1), -1);
				if (c.top == a.top) {
					let u = rt(Xe(r, s, s + 1), -1);
					if (u.top != a.top) return en(u, u.left < c.left);
				}
			}
			return a;
		} else {
			let a = s,
				c = s,
				u = n < 0 ? 1 : -1;
			return (
				n < 0 && !s
					? (c++, (u = -1))
					: n >= 0 && s == r.nodeValue.length
						? (a--, (u = 1))
						: n < 0
							? a--
							: c++,
				en(rt(Xe(r, a, c), u), u < 0)
			);
		}
	if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
		if (o == null && s && (n < 0 || s == Le(r))) {
			let a = r.childNodes[s - 1];
			if (a.nodeType == 1) return Hr(a.getBoundingClientRect(), !1);
		}
		if (o == null && s < Le(r)) {
			let a = r.childNodes[s];
			if (a.nodeType == 1) return Hr(a.getBoundingClientRect(), !0);
		}
		return Hr(r.getBoundingClientRect(), n >= 0);
	}
	if (o == null && s && (n < 0 || s == Le(r))) {
		let a = r.childNodes[s - 1],
			c =
				a.nodeType == 3
					? Xe(a, Le(a) - (i ? 0 : 1))
					: a.nodeType == 1 && (a.nodeName != 'BR' || !a.nextSibling)
						? a
						: null;
		if (c) return en(rt(c, 1), !1);
	}
	if (o == null && s < Le(r)) {
		let a = r.childNodes[s];
		for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; ) a = a.nextSibling;
		let c = a ? (a.nodeType == 3 ? Xe(a, 0, i ? 0 : 1) : a.nodeType == 1 ? a : null) : null;
		if (c) return en(rt(c, -1), !0);
	}
	return en(rt(r.nodeType == 3 ? Xe(r) : r, -n), n >= 0);
}
function en(t, e) {
	if (t.width == 0) return t;
	let n = e ? t.left : t.right;
	return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function Hr(t, e) {
	if (t.height == 0) return t;
	let n = e ? t.top : t.bottom;
	return { top: n, bottom: n, left: t.left, right: t.right };
}
function sl(t, e, n) {
	let r = t.state,
		s = t.root.activeElement;
	r != e && t.updateState(e), s != t.dom && t.focus();
	try {
		return n();
	} finally {
		r != e && t.updateState(r), s != t.dom && s && s.focus();
	}
}
function pu(t, e, n) {
	let r = e.selection,
		s = n == 'up' ? r.$from : r.$to;
	return sl(t, e, () => {
		let { node: o } = t.docView.domFromPos(s.pos, n == 'up' ? -1 : 1);
		for (;;) {
			let l = t.docView.nearestDesc(o, !0);
			if (!l) break;
			if (l.node.isBlock) {
				o = l.contentDOM || l.dom;
				break;
			}
			o = l.dom.parentNode;
		}
		let i = rl(t, s.pos, 1);
		for (let l = o.firstChild; l; l = l.nextSibling) {
			let a;
			if (l.nodeType == 1) a = l.getClientRects();
			else if (l.nodeType == 3) a = Xe(l, 0, l.nodeValue.length).getClientRects();
			else continue;
			for (let c = 0; c < a.length; c++) {
				let u = a[c];
				if (
					u.bottom > u.top + 1 &&
					(n == 'up'
						? i.top - u.top > (u.bottom - i.top) * 2
						: u.bottom - i.bottom > (i.bottom - u.top) * 2)
				)
					return !1;
			}
		}
		return !0;
	});
}
const hu = /[\u0590-\u08ac]/;
function mu(t, e, n) {
	let { $head: r } = e.selection;
	if (!r.parent.isTextblock) return !1;
	let s = r.parentOffset,
		o = !s,
		i = s == r.parent.content.size,
		l = t.domSelection();
	return l
		? !hu.test(r.parent.textContent) || !l.modify
			? n == 'left' || n == 'backward'
				? o
				: i
			: sl(t, e, () => {
					let {
							focusNode: a,
							focusOffset: c,
							anchorNode: u,
							anchorOffset: d
						} = t.domSelectionRange(),
						f = l.caretBidiLevel;
					l.modify('move', n, 'character');
					let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
						{ focusNode: h, focusOffset: g } = t.domSelectionRange(),
						m = (h && !p.contains(h.nodeType == 1 ? h : h.parentNode)) || (a == h && c == g);
					try {
						l.collapse(u, d), a && (a != u || c != d) && l.extend && l.extend(a, c);
					} catch {}
					return f != null && (l.caretBidiLevel = f), m;
				})
		: r.pos == r.start() || r.pos == r.end();
}
let Lo = null,
	Po = null,
	Ro = !1;
function gu(t, e, n) {
	return Lo == e && Po == n
		? Ro
		: ((Lo = e), (Po = n), (Ro = n == 'up' || n == 'down' ? pu(t, e, n) : mu(t, e, n)));
}
const Pe = 0,
	Bo = 1,
	$t = 2,
	qe = 3;
class Cn {
	constructor(e, n, r, s) {
		(this.parent = e),
			(this.children = n),
			(this.dom = r),
			(this.contentDOM = s),
			(this.dirty = Pe),
			(r.pmViewDesc = this);
	}
	matchesWidget(e) {
		return !1;
	}
	matchesMark(e) {
		return !1;
	}
	matchesNode(e, n, r) {
		return !1;
	}
	matchesHack(e) {
		return !1;
	}
	parseRule() {
		return null;
	}
	stopEvent(e) {
		return !1;
	}
	get size() {
		let e = 0;
		for (let n = 0; n < this.children.length; n++) e += this.children[n].size;
		return e;
	}
	get border() {
		return 0;
	}
	destroy() {
		(this.parent = void 0), this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
		for (let e = 0; e < this.children.length; e++) this.children[e].destroy();
	}
	posBeforeChild(e) {
		for (let n = 0, r = this.posAtStart; ; n++) {
			let s = this.children[n];
			if (s == e) return r;
			r += s.size;
		}
	}
	get posBefore() {
		return this.parent.posBeforeChild(this);
	}
	get posAtStart() {
		return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
	}
	get posAfter() {
		return this.posBefore + this.size;
	}
	get posAtEnd() {
		return this.posAtStart + this.size - 2 * this.border;
	}
	localPosFromDOM(e, n, r) {
		if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
			if (r < 0) {
				let o, i;
				if (e == this.contentDOM) o = e.childNodes[n - 1];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					o = e.previousSibling;
				}
				for (; o && !((i = o.pmViewDesc) && i.parent == this); ) o = o.previousSibling;
				return o ? this.posBeforeChild(i) + i.size : this.posAtStart;
			} else {
				let o, i;
				if (e == this.contentDOM) o = e.childNodes[n];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					o = e.nextSibling;
				}
				for (; o && !((i = o.pmViewDesc) && i.parent == this); ) o = o.nextSibling;
				return o ? this.posBeforeChild(i) : this.posAtEnd;
			}
		let s;
		if (e == this.dom && this.contentDOM) s = n > de(this.contentDOM);
		else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
			s = e.compareDocumentPosition(this.contentDOM) & 2;
		else if (this.dom.firstChild) {
			if (n == 0)
				for (let o = e; ; o = o.parentNode) {
					if (o == this.dom) {
						s = !1;
						break;
					}
					if (o.previousSibling) break;
				}
			if (s == null && n == e.childNodes.length)
				for (let o = e; ; o = o.parentNode) {
					if (o == this.dom) {
						s = !0;
						break;
					}
					if (o.nextSibling) break;
				}
		}
		return (s ?? r > 0) ? this.posAtEnd : this.posAtStart;
	}
	nearestDesc(e, n = !1) {
		for (let r = !0, s = e; s; s = s.parentNode) {
			let o = this.getDesc(s),
				i;
			if (o && (!n || o.node))
				if (
					r &&
					(i = o.nodeDOM) &&
					!(i.nodeType == 1 ? i.contains(e.nodeType == 1 ? e : e.parentNode) : i == e)
				)
					r = !1;
				else return o;
		}
	}
	getDesc(e) {
		let n = e.pmViewDesc;
		for (let r = n; r; r = r.parent) if (r == this) return n;
	}
	posFromDOM(e, n, r) {
		for (let s = e; s; s = s.parentNode) {
			let o = this.getDesc(s);
			if (o) return o.localPosFromDOM(e, n, r);
		}
		return -1;
	}
	descAt(e) {
		for (let n = 0, r = 0; n < this.children.length; n++) {
			let s = this.children[n],
				o = r + s.size;
			if (r == e && o != r) {
				for (; !s.border && s.children.length; )
					for (let i = 0; i < s.children.length; i++) {
						let l = s.children[i];
						if (l.size) {
							s = l;
							break;
						}
					}
				return s;
			}
			if (e < o) return s.descAt(e - r - s.border);
			r = o;
		}
	}
	domFromPos(e, n) {
		if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
		let r = 0,
			s = 0;
		for (let o = 0; r < this.children.length; r++) {
			let i = this.children[r],
				l = o + i.size;
			if (l > e || i instanceof il) {
				s = e - o;
				break;
			}
			o = l;
		}
		if (s) return this.children[r].domFromPos(s - this.children[r].border, n);
		for (let o; r && !(o = this.children[r - 1]).size && o instanceof ol && o.side >= 0; r--);
		if (n <= 0) {
			let o,
				i = !0;
			for (
				;
				(o = r ? this.children[r - 1] : null), !(!o || o.dom.parentNode == this.contentDOM);
				r--, i = !1
			);
			return o && n && i && !o.border && !o.domAtom
				? o.domFromPos(o.size, n)
				: { node: this.contentDOM, offset: o ? de(o.dom) + 1 : 0 };
		} else {
			let o,
				i = !0;
			for (
				;
				(o = r < this.children.length ? this.children[r] : null),
					!(!o || o.dom.parentNode == this.contentDOM);
				r++, i = !1
			);
			return o && i && !o.border && !o.domAtom
				? o.domFromPos(0, n)
				: { node: this.contentDOM, offset: o ? de(o.dom) : this.contentDOM.childNodes.length };
		}
	}
	parseRange(e, n, r = 0) {
		if (this.children.length == 0)
			return {
				node: this.contentDOM,
				from: e,
				to: n,
				fromOffset: 0,
				toOffset: this.contentDOM.childNodes.length
			};
		let s = -1,
			o = -1;
		for (let i = r, l = 0; ; l++) {
			let a = this.children[l],
				c = i + a.size;
			if (s == -1 && e <= c) {
				let u = i + a.border;
				if (
					e >= u &&
					n <= c - a.border &&
					a.node &&
					a.contentDOM &&
					this.contentDOM.contains(a.contentDOM)
				)
					return a.parseRange(e, n, u);
				e = i;
				for (let d = l; d > 0; d--) {
					let f = this.children[d - 1];
					if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
						s = de(f.dom) + 1;
						break;
					}
					e -= f.size;
				}
				s == -1 && (s = 0);
			}
			if (s > -1 && (c > n || l == this.children.length - 1)) {
				n = c;
				for (let u = l + 1; u < this.children.length; u++) {
					let d = this.children[u];
					if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
						o = de(d.dom);
						break;
					}
					n += d.size;
				}
				o == -1 && (o = this.contentDOM.childNodes.length);
				break;
			}
			i = c;
		}
		return { node: this.contentDOM, from: e, to: n, fromOffset: s, toOffset: o };
	}
	emptyChildAt(e) {
		if (this.border || !this.contentDOM || !this.children.length) return !1;
		let n = this.children[e < 0 ? 0 : this.children.length - 1];
		return n.size == 0 || n.emptyChildAt(e);
	}
	domAfterPos(e) {
		let { node: n, offset: r } = this.domFromPos(e, 0);
		if (n.nodeType != 1 || r == n.childNodes.length) throw new RangeError('No node after pos ' + e);
		return n.childNodes[r];
	}
	setSelection(e, n, r, s = !1) {
		let o = Math.min(e, n),
			i = Math.max(e, n);
		for (let p = 0, h = 0; p < this.children.length; p++) {
			let g = this.children[p],
				m = h + g.size;
			if (o > h && i < m) return g.setSelection(e - h - g.border, n - h - g.border, r, s);
			h = m;
		}
		let l = this.domFromPos(e, e ? -1 : 1),
			a = n == e ? l : this.domFromPos(n, n ? -1 : 1),
			c = r.root.getSelection(),
			u = r.domSelectionRange(),
			d = !1;
		if ((Ve || ye) && e == n) {
			let { node: p, offset: h } = l;
			if (p.nodeType == 3) {
				if (
					((d = !!(
						h &&
						p.nodeValue[h - 1] ==
							`
`
					)),
					d && h == p.nodeValue.length)
				)
					for (let g = p, m; g; g = g.parentNode) {
						if ((m = g.nextSibling)) {
							m.nodeName == 'BR' && (l = a = { node: m.parentNode, offset: de(m) + 1 });
							break;
						}
						let b = g.pmViewDesc;
						if (b && b.node && b.node.isBlock) break;
					}
			} else {
				let g = p.childNodes[h - 1];
				d = g && (g.nodeName == 'BR' || g.contentEditable == 'false');
			}
		}
		if (Ve && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
			let p = u.focusNode.childNodes[u.focusOffset];
			p && p.contentEditable == 'false' && (s = !0);
		}
		if (
			!(s || (d && ye)) &&
			Et(l.node, l.offset, u.anchorNode, u.anchorOffset) &&
			Et(a.node, a.offset, u.focusNode, u.focusOffset)
		)
			return;
		let f = !1;
		if ((c.extend || e == n) && !d) {
			c.collapse(l.node, l.offset);
			try {
				e != n && c.extend(a.node, a.offset), (f = !0);
			} catch {}
		}
		if (!f) {
			if (e > n) {
				let h = l;
				(l = a), (a = h);
			}
			let p = document.createRange();
			p.setEnd(a.node, a.offset), p.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(p);
		}
	}
	ignoreMutation(e) {
		return !this.contentDOM && e.type != 'selection';
	}
	get contentLost() {
		return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
	}
	markDirty(e, n) {
		for (let r = 0, s = 0; s < this.children.length; s++) {
			let o = this.children[s],
				i = r + o.size;
			if (r == i ? e <= i && n >= r : e < i && n > r) {
				let l = r + o.border,
					a = i - o.border;
				if (e >= l && n <= a) {
					(this.dirty = e == r || n == i ? $t : Bo),
						e == l && n == a && (o.contentLost || o.dom.parentNode != this.contentDOM)
							? (o.dirty = qe)
							: o.markDirty(e - l, n - l);
					return;
				} else
					o.dirty =
						o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length
							? $t
							: qe;
			}
			r = i;
		}
		this.dirty = $t;
	}
	markParentsDirty() {
		let e = 1;
		for (let n = this.parent; n; n = n.parent, e++) {
			let r = e == 1 ? $t : Bo;
			n.dirty < r && (n.dirty = r);
		}
	}
	get domAtom() {
		return !1;
	}
	get ignoreForCoords() {
		return !1;
	}
	get ignoreForSelection() {
		return !1;
	}
	isText(e) {
		return !1;
	}
}
class ol extends Cn {
	constructor(e, n, r, s) {
		let o,
			i = n.type.toDOM;
		if (
			(typeof i == 'function' &&
				(i = i(r, () => {
					if (!o) return s;
					if (o.parent) return o.parent.posBeforeChild(o);
				})),
			!n.type.spec.raw)
		) {
			if (i.nodeType != 1) {
				let l = document.createElement('span');
				l.appendChild(i), (i = l);
			}
			(i.contentEditable = 'false'), i.classList.add('ProseMirror-widget');
		}
		super(e, [], i, null), (this.widget = n), (this.widget = n), (o = this);
	}
	matchesWidget(e) {
		return this.dirty == Pe && e.type.eq(this.widget.type);
	}
	parseRule() {
		return { ignore: !0 };
	}
	stopEvent(e) {
		let n = this.widget.spec.stopEvent;
		return n ? n(e) : !1;
	}
	ignoreMutation(e) {
		return e.type != 'selection' || this.widget.spec.ignoreSelection;
	}
	destroy() {
		this.widget.type.destroy(this.dom), super.destroy();
	}
	get domAtom() {
		return !0;
	}
	get ignoreForSelection() {
		return !!this.widget.type.spec.relaxedSide;
	}
	get side() {
		return this.widget.type.side;
	}
}
class bu extends Cn {
	constructor(e, n, r, s) {
		super(e, [], n, null), (this.textDOM = r), (this.text = s);
	}
	get size() {
		return this.text.length;
	}
	localPosFromDOM(e, n) {
		return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
	}
	domFromPos(e) {
		return { node: this.textDOM, offset: e };
	}
	ignoreMutation(e) {
		return e.type === 'characterData' && e.target.nodeValue == e.oldValue;
	}
}
class Ot extends Cn {
	constructor(e, n, r, s, o) {
		super(e, [], r, s), (this.mark = n), (this.spec = o);
	}
	static create(e, n, r, s) {
		let o = s.nodeViews[n.type.name],
			i = o && o(n, s, r);
		return (
			(!i || !i.dom) && (i = $n.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
			new Ot(e, n, i.dom, i.contentDOM || i.dom, i)
		);
	}
	parseRule() {
		return this.dirty & qe || this.mark.type.spec.reparseInView
			? null
			: { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
	}
	matchesMark(e) {
		return this.dirty != qe && this.mark.eq(e);
	}
	markDirty(e, n) {
		if ((super.markDirty(e, n), this.dirty != Pe)) {
			let r = this.parent;
			for (; !r.node; ) r = r.parent;
			r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = Pe);
		}
	}
	slice(e, n, r) {
		let s = Ot.create(this.parent, this.mark, !0, r),
			o = this.children,
			i = this.size;
		n < i && (o = gs(o, n, i, r)), e > 0 && (o = gs(o, 0, e, r));
		for (let l = 0; l < o.length; l++) o[l].parent = s;
		return (s.children = o), s;
	}
	ignoreMutation(e) {
		return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
	}
	destroy() {
		this.spec.destroy && this.spec.destroy(), super.destroy();
	}
}
class dt extends Cn {
	constructor(e, n, r, s, o, i, l, a, c) {
		super(e, [], o, i),
			(this.node = n),
			(this.outerDeco = r),
			(this.innerDeco = s),
			(this.nodeDOM = l);
	}
	static create(e, n, r, s, o, i) {
		let l = o.nodeViews[n.type.name],
			a,
			c =
				l &&
				l(
					n,
					o,
					() => {
						if (!a) return i;
						if (a.parent) return a.parent.posBeforeChild(a);
					},
					r,
					s
				),
			u = c && c.dom,
			d = c && c.contentDOM;
		if (n.isText) {
			if (!u) u = document.createTextNode(n.text);
			else if (u.nodeType != 3) throw new RangeError('Text must be rendered as a DOM text node');
		} else
			u ||
				({ dom: u, contentDOM: d } = $n.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
		!d &&
			!n.isText &&
			u.nodeName != 'BR' &&
			(u.hasAttribute('contenteditable') || (u.contentEditable = 'false'),
			n.type.spec.draggable && (u.draggable = !0));
		let f = u;
		return (
			(u = cl(u, r, n)),
			c
				? (a = new ku(e, n, r, s, u, d || null, f, c, o, i + 1))
				: n.isText
					? new Nr(e, n, r, s, u, f, o)
					: new dt(e, n, r, s, u, d || null, f, o, i + 1)
		);
	}
	parseRule() {
		if (this.node.type.spec.reparseInView) return null;
		let e = { node: this.node.type.name, attrs: this.node.attrs };
		if ((this.node.type.whitespace == 'pre' && (e.preserveWhitespace = 'full'), !this.contentDOM))
			e.getContent = () => this.node.content;
		else if (!this.contentLost) e.contentElement = this.contentDOM;
		else {
			for (let n = this.children.length - 1; n >= 0; n--) {
				let r = this.children[n];
				if (this.dom.contains(r.dom.parentNode)) {
					e.contentElement = r.dom.parentNode;
					break;
				}
			}
			e.contentElement || (e.getContent = () => L.empty);
		}
		return e;
	}
	matchesNode(e, n, r) {
		return this.dirty == Pe && e.eq(this.node) && jn(n, this.outerDeco) && r.eq(this.innerDeco);
	}
	get size() {
		return this.node.nodeSize;
	}
	get border() {
		return this.node.isLeaf ? 0 : 1;
	}
	updateChildren(e, n) {
		let r = this.node.inlineContent,
			s = n,
			o = e.composing ? this.localCompositionInfo(e, n) : null,
			i = o && o.pos > -1 ? o : null,
			l = o && o.pos < 0,
			a = new $u(this, i && i.node, e);
		Cu(
			this.node,
			this.innerDeco,
			(c, u, d) => {
				c.spec.marks
					? a.syncToMarks(c.spec.marks, r, e)
					: c.type.side >= 0 &&
						!d &&
						a.syncToMarks(u == this.node.childCount ? Fn.none : this.node.child(u).marks, r, e),
					a.placeWidget(c, e, s);
			},
			(c, u, d, f) => {
				a.syncToMarks(c.marks, r, e);
				let p;
				a.findNodeMatch(c, u, d, f) ||
					(l &&
						e.state.selection.from > s &&
						e.state.selection.to < s + c.nodeSize &&
						(p = a.findIndexWithChild(o.node)) > -1 &&
						a.updateNodeAt(c, u, d, p, e)) ||
					a.updateNextNode(c, u, d, e, f, s) ||
					a.addNode(c, u, d, e, s),
					(s += c.nodeSize);
			}
		),
			a.syncToMarks([], r, e),
			this.node.isTextblock && a.addTextblockHacks(),
			a.destroyRest(),
			(a.changed || this.dirty == $t) &&
				(i && this.protectLocalComposition(e, i),
				ll(this.contentDOM, this.children, e),
				Kt && Tu(this.dom));
	}
	localCompositionInfo(e, n) {
		let { from: r, to: s } = e.state.selection;
		if (!(e.state.selection instanceof V) || r < n || s > n + this.node.content.size) return null;
		let o = e.input.compositionNode;
		if (!o || !this.dom.contains(o.parentNode)) return null;
		if (this.node.inlineContent) {
			let i = o.nodeValue,
				l = xu(this.node.content, i, r - n, s - n);
			return l < 0 ? null : { node: o, pos: l, text: i };
		} else return { node: o, pos: -1, text: '' };
	}
	protectLocalComposition(e, { node: n, pos: r, text: s }) {
		if (this.getDesc(n)) return;
		let o = n;
		for (; o.parentNode != this.contentDOM; o = o.parentNode) {
			for (; o.previousSibling; ) o.parentNode.removeChild(o.previousSibling);
			for (; o.nextSibling; ) o.parentNode.removeChild(o.nextSibling);
			o.pmViewDesc && (o.pmViewDesc = void 0);
		}
		let i = new bu(this, o, n, s);
		e.input.compositionNodes.push(i), (this.children = gs(this.children, r, r + s.length, e, i));
	}
	update(e, n, r, s) {
		return this.dirty == qe || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, s), !0);
	}
	updateInner(e, n, r, s) {
		this.updateOuterDeco(n),
			(this.node = e),
			(this.innerDeco = r),
			this.contentDOM && this.updateChildren(s, this.posAtStart),
			(this.dirty = Pe);
	}
	updateOuterDeco(e) {
		if (jn(e, this.outerDeco)) return;
		let n = this.nodeDOM.nodeType != 1,
			r = this.dom;
		(this.dom = al(this.dom, this.nodeDOM, ms(this.outerDeco, this.node, n), ms(e, this.node, n))),
			this.dom != r && ((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
			(this.outerDeco = e);
	}
	selectNode() {
		this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add('ProseMirror-selectednode'),
			(this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
	}
	deselectNode() {
		this.nodeDOM.nodeType == 1 &&
			(this.nodeDOM.classList.remove('ProseMirror-selectednode'),
			(this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute('draggable'));
	}
	get domAtom() {
		return this.node.isAtom;
	}
}
function zo(t, e, n, r, s) {
	cl(r, e, t);
	let o = new dt(void 0, t, e, n, r, r, r, s, 0);
	return o.contentDOM && o.updateChildren(s, 0), o;
}
class Nr extends dt {
	constructor(e, n, r, s, o, i, l) {
		super(e, n, r, s, o, null, i, l, 0);
	}
	parseRule() {
		let e = this.nodeDOM.parentNode;
		for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
		return { skip: e || !0 };
	}
	update(e, n, r, s) {
		return this.dirty == qe || (this.dirty != Pe && !this.inParent()) || !e.sameMarkup(this.node)
			? !1
			: (this.updateOuterDeco(n),
				(this.dirty != Pe || e.text != this.node.text) &&
					e.text != this.nodeDOM.nodeValue &&
					((this.nodeDOM.nodeValue = e.text),
					s.trackWrites == this.nodeDOM && (s.trackWrites = null)),
				(this.node = e),
				(this.dirty = Pe),
				!0);
	}
	inParent() {
		let e = this.parent.contentDOM;
		for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
		return !1;
	}
	domFromPos(e) {
		return { node: this.nodeDOM, offset: e };
	}
	localPosFromDOM(e, n, r) {
		return e == this.nodeDOM
			? this.posAtStart + Math.min(n, this.node.text.length)
			: super.localPosFromDOM(e, n, r);
	}
	ignoreMutation(e) {
		return e.type != 'characterData' && e.type != 'selection';
	}
	slice(e, n, r) {
		let s = this.node.cut(e, n),
			o = document.createTextNode(s.text);
		return new Nr(this.parent, s, this.outerDeco, this.innerDeco, o, o, r);
	}
	markDirty(e, n) {
		super.markDirty(e, n),
			this.dom != this.nodeDOM &&
				(e == 0 || n == this.nodeDOM.nodeValue.length) &&
				(this.dirty = qe);
	}
	get domAtom() {
		return !1;
	}
	isText(e) {
		return this.node.text == e;
	}
}
class il extends Cn {
	parseRule() {
		return { ignore: !0 };
	}
	matchesHack(e) {
		return this.dirty == Pe && this.dom.nodeName == e;
	}
	get domAtom() {
		return !0;
	}
	get ignoreForCoords() {
		return this.dom.nodeName == 'IMG';
	}
}
class ku extends dt {
	constructor(e, n, r, s, o, i, l, a, c, u) {
		super(e, n, r, s, o, i, l, c, u), (this.spec = a);
	}
	update(e, n, r, s) {
		if (this.dirty == qe) return !1;
		if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
			let o = this.spec.update(e, n, r);
			return o && this.updateInner(e, n, r, s), o;
		} else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, s);
	}
	selectNode() {
		this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
	}
	deselectNode() {
		this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
	}
	setSelection(e, n, r, s) {
		this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, s);
	}
	destroy() {
		this.spec.destroy && this.spec.destroy(), super.destroy();
	}
	stopEvent(e) {
		return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
	}
	ignoreMutation(e) {
		return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
	}
}
function ll(t, e, n) {
	let r = t.firstChild,
		s = !1;
	for (let o = 0; o < e.length; o++) {
		let i = e[o],
			l = i.dom;
		if (l.parentNode == t) {
			for (; l != r; ) (r = Ho(r)), (s = !0);
			r = r.nextSibling;
		} else (s = !0), t.insertBefore(l, r);
		if (i instanceof Ot) {
			let a = r ? r.previousSibling : t.lastChild;
			ll(i.contentDOM, i.children, n), (r = a ? a.nextSibling : t.firstChild);
		}
	}
	for (; r; ) (r = Ho(r)), (s = !0);
	s && n.trackWrites == t && (n.trackWrites = null);
}
const sn = function (t) {
	t && (this.nodeName = t);
};
sn.prototype = Object.create(null);
const St = [new sn()];
function ms(t, e, n) {
	if (t.length == 0) return St;
	let r = n ? St[0] : new sn(),
		s = [r];
	for (let o = 0; o < t.length; o++) {
		let i = t[o].type.attrs;
		if (i) {
			i.nodeName && s.push((r = new sn(i.nodeName)));
			for (let l in i) {
				let a = i[l];
				a != null &&
					(n && s.length == 1 && s.push((r = new sn(e.isInline ? 'span' : 'div'))),
					l == 'class'
						? (r.class = (r.class ? r.class + ' ' : '') + a)
						: l == 'style'
							? (r.style = (r.style ? r.style + ';' : '') + a)
							: l != 'nodeName' && (r[l] = a));
			}
		}
	}
	return s;
}
function al(t, e, n, r) {
	if (n == St && r == St) return e;
	let s = e;
	for (let o = 0; o < r.length; o++) {
		let i = r[o],
			l = n[o];
		if (o) {
			let a;
			(l &&
				l.nodeName == i.nodeName &&
				s != t &&
				(a = s.parentNode) &&
				a.nodeName.toLowerCase() == i.nodeName) ||
				((a = document.createElement(i.nodeName)),
				(a.pmIsDeco = !0),
				a.appendChild(s),
				(l = St[0])),
				(s = a);
		}
		yu(s, l || St[0], i);
	}
	return s;
}
function yu(t, e, n) {
	for (let r in e)
		r != 'class' && r != 'style' && r != 'nodeName' && !(r in n) && t.removeAttribute(r);
	for (let r in n)
		r != 'class' && r != 'style' && r != 'nodeName' && n[r] != e[r] && t.setAttribute(r, n[r]);
	if (e.class != n.class) {
		let r = e.class ? e.class.split(' ').filter(Boolean) : [],
			s = n.class ? n.class.split(' ').filter(Boolean) : [];
		for (let o = 0; o < r.length; o++) s.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
		for (let o = 0; o < s.length; o++) r.indexOf(s[o]) == -1 && t.classList.add(s[o]);
		t.classList.length == 0 && t.removeAttribute('class');
	}
	if (e.style != n.style) {
		if (e.style) {
			let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
				s;
			for (; (s = r.exec(e.style)); ) t.style.removeProperty(s[1]);
		}
		n.style && (t.style.cssText += n.style);
	}
}
function cl(t, e, n) {
	return al(t, t, St, ms(e, n, t.nodeType != 1));
}
function jn(t, e) {
	if (t.length != e.length) return !1;
	for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
	return !0;
}
function Ho(t) {
	let e = t.nextSibling;
	return t.parentNode.removeChild(t), e;
}
class $u {
	constructor(e, n, r) {
		(this.lock = n),
			(this.view = r),
			(this.index = 0),
			(this.stack = []),
			(this.changed = !1),
			(this.top = e),
			(this.preMatch = Su(e.node.content, e));
	}
	destroyBetween(e, n) {
		if (e != n) {
			for (let r = e; r < n; r++) this.top.children[r].destroy();
			this.top.children.splice(e, n - e), (this.changed = !0);
		}
	}
	destroyRest() {
		this.destroyBetween(this.index, this.top.children.length);
	}
	syncToMarks(e, n, r) {
		let s = 0,
			o = this.stack.length >> 1,
			i = Math.min(o, e.length);
		for (
			;
			s < i &&
			(s == o - 1 ? this.top : this.stack[(s + 1) << 1]).matchesMark(e[s]) &&
			e[s].type.spec.spanning !== !1;

		)
			s++;
		for (; s < o; )
			this.destroyRest(),
				(this.top.dirty = Pe),
				(this.index = this.stack.pop()),
				(this.top = this.stack.pop()),
				o--;
		for (; o < e.length; ) {
			this.stack.push(this.top, this.index + 1);
			let l = -1;
			for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
				let c = this.top.children[a];
				if (c.matchesMark(e[o]) && !this.isLocked(c.dom)) {
					l = a;
					break;
				}
			}
			if (l > -1)
				l > this.index && ((this.changed = !0), this.destroyBetween(this.index, l)),
					(this.top = this.top.children[this.index]);
			else {
				let a = Ot.create(this.top, e[o], n, r);
				this.top.children.splice(this.index, 0, a), (this.top = a), (this.changed = !0);
			}
			(this.index = 0), o++;
		}
	}
	findNodeMatch(e, n, r, s) {
		let o = -1,
			i;
		if (
			s >= this.preMatch.index &&
			(i = this.preMatch.matches[s - this.preMatch.index]).parent == this.top &&
			i.matchesNode(e, n, r)
		)
			o = this.top.children.indexOf(i, this.index);
		else
			for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
				let c = this.top.children[l];
				if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
					o = l;
					break;
				}
			}
		return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
	}
	updateNodeAt(e, n, r, s, o) {
		let i = this.top.children[s];
		return (
			i.dirty == qe && i.dom == i.contentDOM && (i.dirty = $t),
			i.update(e, n, r, o) ? (this.destroyBetween(this.index, s), this.index++, !0) : !1
		);
	}
	findIndexWithChild(e) {
		for (;;) {
			let n = e.parentNode;
			if (!n) return -1;
			if (n == this.top.contentDOM) {
				let r = e.pmViewDesc;
				if (r) {
					for (let s = this.index; s < this.top.children.length; s++)
						if (this.top.children[s] == r) return s;
				}
				return -1;
			}
			e = n;
		}
	}
	updateNextNode(e, n, r, s, o, i) {
		for (let l = this.index; l < this.top.children.length; l++) {
			let a = this.top.children[l];
			if (a instanceof dt) {
				let c = this.preMatch.matched.get(a);
				if (c != null && c != o) return !1;
				let u = a.dom,
					d,
					f =
						this.isLocked(u) &&
						!(
							e.isText &&
							a.node &&
							a.node.isText &&
							a.nodeDOM.nodeValue == e.text &&
							a.dirty != qe &&
							jn(n, a.outerDeco)
						);
				if (!f && a.update(e, n, r, s))
					return (
						this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0
					);
				if (!f && (d = this.recreateWrapper(a, e, n, r, s, i)))
					return (
						this.destroyBetween(this.index, l),
						(this.top.children[this.index] = d),
						d.contentDOM && ((d.dirty = $t), d.updateChildren(s, i + 1), (d.dirty = Pe)),
						(this.changed = !0),
						this.index++,
						!0
					);
				break;
			}
		}
		return !1;
	}
	recreateWrapper(e, n, r, s, o, i) {
		if (
			e.dirty ||
			n.isAtom ||
			!e.children.length ||
			!e.node.content.eq(n.content) ||
			!jn(r, e.outerDeco) ||
			!s.eq(e.innerDeco)
		)
			return null;
		let l = dt.create(this.top, n, r, s, o, i);
		if (l.contentDOM) {
			(l.children = e.children), (e.children = []);
			for (let a of l.children) a.parent = l;
		}
		return e.destroy(), l;
	}
	addNode(e, n, r, s, o) {
		let i = dt.create(this.top, e, n, r, s, o);
		i.contentDOM && i.updateChildren(s, o + 1),
			this.top.children.splice(this.index++, 0, i),
			(this.changed = !0);
	}
	placeWidget(e, n, r) {
		let s = this.index < this.top.children.length ? this.top.children[this.index] : null;
		if (s && s.matchesWidget(e) && (e == s.widget || !s.widget.type.toDOM.parentNode)) this.index++;
		else {
			let o = new ol(this.top, e, n, r);
			this.top.children.splice(this.index++, 0, o), (this.changed = !0);
		}
	}
	addTextblockHacks() {
		let e = this.top.children[this.index - 1],
			n = this.top;
		for (; e instanceof Ot; ) (n = e), (e = n.children[n.children.length - 1]);
		(!e ||
			!(e instanceof Nr) ||
			/\n$/.test(e.node.text) ||
			(this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
			((ye || he) && e && e.dom.contentEditable == 'false' && this.addHackNode('IMG', n),
			this.addHackNode('BR', this.top));
	}
	addHackNode(e, n) {
		if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
			this.index++;
		else {
			let r = document.createElement(e);
			e == 'IMG' && ((r.className = 'ProseMirror-separator'), (r.alt = '')),
				e == 'BR' && (r.className = 'ProseMirror-trailingBreak');
			let s = new il(this.top, [], r, null);
			n != this.top ? n.children.push(s) : n.children.splice(this.index++, 0, s),
				(this.changed = !0);
		}
	}
	isLocked(e) {
		return this.lock && (e == this.lock || (e.nodeType == 1 && e.contains(this.lock.parentNode)));
	}
}
function Su(t, e) {
	let n = e,
		r = n.children.length,
		s = t.childCount,
		o = new Map(),
		i = [];
	e: for (; s > 0; ) {
		let l;
		for (;;)
			if (r) {
				let c = n.children[r - 1];
				if (c instanceof Ot) (n = c), (r = c.children.length);
				else {
					(l = c), r--;
					break;
				}
			} else {
				if (n == e) break e;
				(r = n.parent.children.indexOf(n)), (n = n.parent);
			}
		let a = l.node;
		if (a) {
			if (a != t.child(s - 1)) break;
			--s, o.set(l, s), i.push(l);
		}
	}
	return { index: s, matched: o, matches: i.reverse() };
}
function Mu(t, e) {
	return t.type.side - e.type.side;
}
function Cu(t, e, n, r) {
	let s = e.locals(t),
		o = 0;
	if (s.length == 0) {
		for (let c = 0; c < t.childCount; c++) {
			let u = t.child(c);
			r(u, s, e.forChild(o, u), c), (o += u.nodeSize);
		}
		return;
	}
	let i = 0,
		l = [],
		a = null;
	for (let c = 0; ; ) {
		let u, d;
		for (; i < s.length && s[i].to == o; ) {
			let m = s[i++];
			m.widget && (u ? (d || (d = [u])).push(m) : (u = m));
		}
		if (u)
			if (d) {
				d.sort(Mu);
				for (let m = 0; m < d.length; m++) n(d[m], c, !!a);
			} else n(u, c, !!a);
		let f, p;
		if (a) (p = -1), (f = a), (a = null);
		else if (c < t.childCount) (p = c), (f = t.child(c++));
		else break;
		for (let m = 0; m < l.length; m++) l[m].to <= o && l.splice(m--, 1);
		for (; i < s.length && s[i].from <= o && s[i].to > o; ) l.push(s[i++]);
		let h = o + f.nodeSize;
		if (f.isText) {
			let m = h;
			i < s.length && s[i].from < m && (m = s[i].from);
			for (let b = 0; b < l.length; b++) l[b].to < m && (m = l[b].to);
			m < h && ((a = f.cut(m - o)), (f = f.cut(0, m - o)), (h = m), (p = -1));
		} else for (; i < s.length && s[i].to < h; ) i++;
		let g = f.isInline && !f.isLeaf ? l.filter((m) => !m.inline) : l.slice();
		r(f, g, e.forChild(o, f), p), (o = h);
	}
}
function Tu(t) {
	if (t.nodeName == 'UL' || t.nodeName == 'OL') {
		let e = t.style.cssText;
		(t.style.cssText = e + '; list-style: square !important'),
			window.getComputedStyle(t).listStyle,
			(t.style.cssText = e);
	}
}
function xu(t, e, n, r) {
	for (let s = 0, o = 0; s < t.childCount && o <= r; ) {
		let i = t.child(s++),
			l = o;
		if (((o += i.nodeSize), !i.isText)) continue;
		let a = i.text;
		for (; s < t.childCount; ) {
			let c = t.child(s++);
			if (((o += c.nodeSize), !c.isText)) break;
			a += c.text;
		}
		if (o >= n) {
			if (o >= r && a.slice(r - e.length - l, r - l) == e) return r - e.length;
			let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
			if (c >= 0 && c + e.length + l >= n) return l + c;
			if (n == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e) return r;
		}
	}
	return -1;
}
function gs(t, e, n, r, s) {
	let o = [];
	for (let i = 0, l = 0; i < t.length; i++) {
		let a = t[i],
			c = l,
			u = (l += a.size);
		c >= n || u <= e
			? o.push(a)
			: (c < e && o.push(a.slice(0, e - c, r)),
				s && (o.push(s), (s = void 0)),
				u > n && o.push(a.slice(n - c, a.size, r)));
	}
	return o;
}
function js(t, e = null) {
	let n = t.domSelectionRange(),
		r = t.state.doc;
	if (!n.focusNode) return null;
	let s = t.docView.nearestDesc(n.focusNode),
		o = s && s.size == 0,
		i = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
	if (i < 0) return null;
	let l = r.resolve(i),
		a,
		c;
	if (Or(n)) {
		for (a = i; s && !s.node; ) s = s.parent;
		let d = s.node;
		if (
			s &&
			d.isAtom &&
			_.isSelectable(d) &&
			s.parent &&
			!(d.isInline && Yc(n.focusNode, n.focusOffset, s.dom))
		) {
			let f = s.posBefore;
			c = new _(i == f ? l : r.resolve(f));
		}
	} else {
		if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
			let d = i,
				f = i;
			for (let p = 0; p < n.rangeCount; p++) {
				let h = n.getRangeAt(p);
				(d = Math.min(d, t.docView.posFromDOM(h.startContainer, h.startOffset, 1))),
					(f = Math.max(f, t.docView.posFromDOM(h.endContainer, h.endOffset, -1)));
			}
			if (d < 0) return null;
			([a, i] = f == t.state.selection.anchor ? [f, d] : [d, f]), (l = r.resolve(i));
		} else a = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
		if (a < 0) return null;
	}
	let u = r.resolve(a);
	if (!c) {
		let d = e == 'pointer' || (t.state.selection.head < l.pos && !o) ? 1 : -1;
		c = Ks(t, u, l, d);
	}
	return c;
}
function ul(t) {
	return t.editable
		? t.hasFocus()
		: fl(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function tt(t, e = !1) {
	let n = t.state.selection;
	if ((dl(t, n), !!ul(t))) {
		if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && he) {
			let r = t.domSelectionRange(),
				s = t.domObserver.currentSelection;
			if (
				r.anchorNode &&
				s.anchorNode &&
				Et(r.anchorNode, r.anchorOffset, s.anchorNode, s.anchorOffset)
			) {
				(t.input.mouseDown.delayedSelectionSync = !0), t.domObserver.setCurSelection();
				return;
			}
		}
		if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) Au(t);
		else {
			let { anchor: r, head: s } = n,
				o,
				i;
			Vo &&
				!(n instanceof V) &&
				(n.$from.parent.inlineContent || (o = Fo(t, n.from)),
				!n.empty && !n.$from.parent.inlineContent && (i = Fo(t, n.to))),
				t.docView.setSelection(r, s, t, e),
				Vo && (o && jo(o), i && jo(i)),
				n.visible
					? t.dom.classList.remove('ProseMirror-hideselection')
					: (t.dom.classList.add('ProseMirror-hideselection'),
						'onselectionchange' in document && wu(t));
		}
		t.domObserver.setCurSelection(), t.domObserver.connectSelection();
	}
}
const Vo = ye || (he && Xi < 63);
function Fo(t, e) {
	let { node: n, offset: r } = t.docView.domFromPos(e, 0),
		s = r < n.childNodes.length ? n.childNodes[r] : null,
		o = r ? n.childNodes[r - 1] : null;
	if (ye && s && s.contentEditable == 'false') return Vr(s);
	if ((!s || s.contentEditable == 'false') && (!o || o.contentEditable == 'false')) {
		if (s) return Vr(s);
		if (o) return Vr(o);
	}
}
function Vr(t) {
	return (
		(t.contentEditable = 'true'),
		ye && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
		t
	);
}
function jo(t) {
	(t.contentEditable = 'false'), t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function wu(t) {
	let e = t.dom.ownerDocument;
	e.removeEventListener('selectionchange', t.input.hideSelectionGuard);
	let n = t.domSelectionRange(),
		r = n.anchorNode,
		s = n.anchorOffset;
	e.addEventListener(
		'selectionchange',
		(t.input.hideSelectionGuard = () => {
			(n.anchorNode != r || n.anchorOffset != s) &&
				(e.removeEventListener('selectionchange', t.input.hideSelectionGuard),
				setTimeout(() => {
					(!ul(t) || t.state.selection.visible) &&
						t.dom.classList.remove('ProseMirror-hideselection');
				}, 20));
		})
	);
}
function Au(t) {
	let e = t.domSelection(),
		n = document.createRange();
	if (!e) return;
	let r = t.cursorWrapper.dom,
		s = r.nodeName == 'IMG';
	s ? n.setStart(r.parentNode, de(r) + 1) : n.setStart(r, 0),
		n.collapse(!0),
		e.removeAllRanges(),
		e.addRange(n),
		!s && !t.state.selection.visible && Ee && ut <= 11 && ((r.disabled = !0), (r.disabled = !1));
}
function dl(t, e) {
	if (e instanceof _) {
		let n = t.docView.descAt(e.from);
		n != t.lastSelectedViewDesc && (Ko(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
	} else Ko(t);
}
function Ko(t) {
	t.lastSelectedViewDesc &&
		(t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
		(t.lastSelectedViewDesc = void 0));
}
function Ks(t, e, n, r) {
	return t.someProp('createSelectionBetween', (s) => s(t, e, n)) || V.between(e, n, r);
}
function Wo(t) {
	return t.editable && !t.hasFocus() ? !1 : fl(t);
}
function fl(t) {
	let e = t.domSelectionRange();
	if (!e.anchorNode) return !1;
	try {
		return (
			t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) &&
			(t.editable ||
				t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
		);
	} catch {
		return !1;
	}
}
function Eu(t) {
	let e = t.docView.domFromPos(t.state.selection.anchor, 0),
		n = t.domSelectionRange();
	return Et(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function bs(t, e) {
	let { $anchor: n, $head: r } = t.selection,
		s = e > 0 ? n.max(r) : n.min(r),
		o = s.parent.inlineContent
			? s.depth
				? t.doc.resolve(e > 0 ? s.after() : s.before())
				: null
			: s;
	return o && ne.findFrom(o, e);
}
function st(t, e) {
	return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function qo(t, e, n) {
	let r = t.state.selection;
	if (r instanceof V)
		if (n.indexOf('s') > -1) {
			let { $head: s } = r,
				o = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter;
			if (!o || o.isText || !o.isLeaf) return !1;
			let i = t.state.doc.resolve(s.pos + o.nodeSize * (e < 0 ? -1 : 1));
			return st(t, new V(r.$anchor, i));
		} else if (r.empty) {
			if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) {
				let s = bs(t.state, e);
				return s && s instanceof _ ? st(t, s) : !1;
			} else if (!(Ie && n.indexOf('m') > -1)) {
				let s = r.$head,
					o = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter,
					i;
				if (!o || o.isText) return !1;
				let l = e < 0 ? s.pos - o.nodeSize : s.pos;
				return o.isAtom || ((i = t.docView.descAt(l)) && !i.contentDOM)
					? _.isSelectable(o)
						? st(t, new _(e < 0 ? t.state.doc.resolve(s.pos - o.nodeSize) : s))
						: Mn
							? st(t, new V(t.state.doc.resolve(e < 0 ? l : l + o.nodeSize)))
							: !1
					: !1;
			}
		} else return !1;
	else {
		if (r instanceof _ && r.node.isInline) return st(t, new V(e > 0 ? r.$to : r.$from));
		{
			let s = bs(t.state, e);
			return s ? st(t, s) : !1;
		}
	}
}
function Kn(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function on(t, e) {
	let n = t.pmViewDesc;
	return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != 'BR');
}
function vt(t, e) {
	return e < 0 ? Ou(t) : Nu(t);
}
function Ou(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let s,
		o,
		i = !1;
	for (Ve && n.nodeType == 1 && r < Kn(n) && on(n.childNodes[r], -1) && (i = !0); ; )
		if (r > 0) {
			if (n.nodeType != 1) break;
			{
				let l = n.childNodes[r - 1];
				if (on(l, -1)) (s = n), (o = --r);
				else if (l.nodeType == 3) (n = l), (r = n.nodeValue.length);
				else break;
			}
		} else {
			if (pl(n)) break;
			{
				let l = n.previousSibling;
				for (; l && on(l, -1); ) (s = n.parentNode), (o = de(l)), (l = l.previousSibling);
				if (l) (n = l), (r = Kn(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = 0;
				}
			}
		}
	i ? ks(t, n, r) : s && ks(t, s, o);
}
function Nu(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let s = Kn(n),
		o,
		i;
	for (;;)
		if (r < s) {
			if (n.nodeType != 1) break;
			let l = n.childNodes[r];
			if (on(l, 1)) (o = n), (i = ++r);
			else break;
		} else {
			if (pl(n)) break;
			{
				let l = n.nextSibling;
				for (; l && on(l, 1); ) (o = l.parentNode), (i = de(l) + 1), (l = l.nextSibling);
				if (l) (n = l), (r = 0), (s = Kn(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = s = 0;
				}
			}
		}
	o && ks(t, o, i);
}
function pl(t) {
	let e = t.pmViewDesc;
	return e && e.node && e.node.isBlock;
}
function Du(t, e) {
	for (; t && e == t.childNodes.length && !Sn(t); ) (e = de(t) + 1), (t = t.parentNode);
	for (; t && e < t.childNodes.length; ) {
		let n = t.childNodes[e];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == 'false') break;
		(t = n), (e = 0);
	}
}
function vu(t, e) {
	for (; t && !e && !Sn(t); ) (e = de(t)), (t = t.parentNode);
	for (; t && e; ) {
		let n = t.childNodes[e - 1];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == 'false') break;
		(t = n), (e = t.childNodes.length);
	}
}
function ks(t, e, n) {
	if (e.nodeType != 3) {
		let o, i;
		(i = Du(e, n)) ? ((e = i), (n = 0)) : (o = vu(e, n)) && ((e = o), (n = o.nodeValue.length));
	}
	let r = t.domSelection();
	if (!r) return;
	if (Or(r)) {
		let o = document.createRange();
		o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
	} else r.extend && r.extend(e, n);
	t.domObserver.setCurSelection();
	let { state: s } = t;
	setTimeout(() => {
		t.state == s && tt(t);
	}, 50);
}
function Uo(t, e) {
	let n = t.state.doc.resolve(e);
	if (!(he || eu) && n.parent.inlineContent) {
		let s = t.coordsAtPos(e);
		if (e > n.start()) {
			let o = t.coordsAtPos(e - 1),
				i = (o.top + o.bottom) / 2;
			if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
				return o.left < s.left ? 'ltr' : 'rtl';
		}
		if (e < n.end()) {
			let o = t.coordsAtPos(e + 1),
				i = (o.top + o.bottom) / 2;
			if (i > s.top && i < s.bottom && Math.abs(o.left - s.left) > 1)
				return o.left > s.left ? 'ltr' : 'rtl';
		}
	}
	return getComputedStyle(t.dom).direction == 'rtl' ? 'rtl' : 'ltr';
}
function Go(t, e, n) {
	let r = t.state.selection;
	if ((r instanceof V && !r.empty) || n.indexOf('s') > -1 || (Ie && n.indexOf('m') > -1)) return !1;
	let { $from: s, $to: o } = r;
	if (!s.parent.inlineContent || t.endOfTextblock(e < 0 ? 'up' : 'down')) {
		let i = bs(t.state, e);
		if (i && i instanceof _) return st(t, i);
	}
	if (!s.parent.inlineContent) {
		let i = e < 0 ? s : o,
			l = r instanceof Ar ? ne.near(i, e) : ne.findFrom(i, e);
		return l ? st(t, l) : !1;
	}
	return !1;
}
function Qo(t, e) {
	if (!(t.state.selection instanceof V)) return !0;
	let { $head: n, $anchor: r, empty: s } = t.state.selection;
	if (!n.sameParent(r)) return !0;
	if (!s) return !1;
	if (t.endOfTextblock(e > 0 ? 'forward' : 'backward')) return !0;
	let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
	if (o && !o.isText) {
		let i = t.state.tr;
		return (
			e < 0 ? i.delete(n.pos - o.nodeSize, n.pos) : i.delete(n.pos, n.pos + o.nodeSize),
			t.dispatch(i),
			!0
		);
	}
	return !1;
}
function Jo(t, e, n) {
	t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function _u(t) {
	if (!ye || t.state.selection.$head.parentOffset > 0) return !1;
	let { focusNode: e, focusOffset: n } = t.domSelectionRange();
	if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == 'false') {
		let r = e.firstChild;
		Jo(t, r, 'true'), setTimeout(() => Jo(t, r, 'false'), 20);
	}
	return !1;
}
function Iu(t) {
	let e = '';
	return (
		t.ctrlKey && (e += 'c'),
		t.metaKey && (e += 'm'),
		t.altKey && (e += 'a'),
		t.shiftKey && (e += 's'),
		e
	);
}
function Lu(t, e) {
	let n = e.keyCode,
		r = Iu(e);
	if (n == 8 || (Ie && n == 72 && r == 'c')) return Qo(t, -1) || vt(t, -1);
	if ((n == 46 && !e.shiftKey) || (Ie && n == 68 && r == 'c')) return Qo(t, 1) || vt(t, 1);
	if (n == 13 || n == 27) return !0;
	if (n == 37 || (Ie && n == 66 && r == 'c')) {
		let s = n == 37 ? (Uo(t, t.state.selection.from) == 'ltr' ? -1 : 1) : -1;
		return qo(t, s, r) || vt(t, s);
	} else if (n == 39 || (Ie && n == 70 && r == 'c')) {
		let s = n == 39 ? (Uo(t, t.state.selection.from) == 'ltr' ? 1 : -1) : 1;
		return qo(t, s, r) || vt(t, s);
	} else {
		if (n == 38 || (Ie && n == 80 && r == 'c')) return Go(t, -1, r) || vt(t, -1);
		if (n == 40 || (Ie && n == 78 && r == 'c')) return _u(t) || Go(t, 1, r) || vt(t, 1);
		if (r == (Ie ? 'm' : 'c') && (n == 66 || n == 73 || n == 89 || n == 90)) return !0;
	}
	return !1;
}
function Ws(t, e) {
	t.someProp('transformCopied', (p) => {
		e = p(e, t);
	});
	let n = [],
		{ content: r, openStart: s, openEnd: o } = e;
	for (; s > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
		s--, o--;
		let p = r.firstChild;
		n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), (r = p.content);
	}
	let i = t.someProp('clipboardSerializer') || $n.fromSchema(t.state.schema),
		l = yl(),
		a = l.createElement('div');
	a.appendChild(i.serializeFragment(r, { document: l }));
	let c = a.firstChild,
		u,
		d = 0;
	for (; c && c.nodeType == 1 && (u = kl[c.nodeName.toLowerCase()]); ) {
		for (let p = u.length - 1; p >= 0; p--) {
			let h = l.createElement(u[p]);
			for (; a.firstChild; ) h.appendChild(a.firstChild);
			a.appendChild(h), d++;
		}
		c = a.firstChild;
	}
	c &&
		c.nodeType == 1 &&
		c.setAttribute('data-pm-slice', `${s} ${o}${d ? ` -${d}` : ''} ${JSON.stringify(n)}`);
	let f =
		t.someProp('clipboardTextSerializer', (p) => p(e, t)) ||
		e.content.textBetween(
			0,
			e.content.size,
			`

`
		);
	return { dom: a, text: f, slice: e };
}
function hl(t, e, n, r, s) {
	let o = s.parent.type.spec.code,
		i,
		l;
	if (!n && !e) return null;
	let a = e && (r || o || !n);
	if (a) {
		if (
			(t.someProp('transformPastedText', (f) => {
				e = f(e, o || r, t);
			}),
			o)
		)
			return e
				? new oe(
						L.from(
							t.state.schema.text(
								e.replace(
									/\r\n?/g,
									`
`
								)
							)
						),
						0,
						0
					)
				: oe.empty;
		let d = t.someProp('clipboardTextParser', (f) => f(e, s, r, t));
		if (d) l = d;
		else {
			let f = s.marks(),
				{ schema: p } = t.state,
				h = $n.fromSchema(p);
			(i = document.createElement('div')),
				e.split(/(?:\r\n?|\n)+/).forEach((g) => {
					let m = i.appendChild(document.createElement('p'));
					g && m.appendChild(h.serializeNode(p.text(g, f)));
				});
		}
	} else
		t.someProp('transformPastedHTML', (d) => {
			n = d(n, t);
		}),
			(i = zu(n)),
			Mn && Hu(i);
	let c = i && i.querySelector('[data-pm-slice]'),
		u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute('data-pm-slice') || '');
	if (u && u[3])
		for (let d = +u[3]; d > 0; d--) {
			let f = i.firstChild;
			for (; f && f.nodeType != 1; ) f = f.nextSibling;
			if (!f) break;
			i = f;
		}
	if (
		(l ||
			(l = (
				t.someProp('clipboardParser') ||
				t.someProp('domParser') ||
				zt.fromSchema(t.state.schema)
			).parseSlice(i, {
				preserveWhitespace: !!(a || u),
				context: s,
				ruleFromNode(f) {
					return f.nodeName == 'BR' &&
						!f.nextSibling &&
						f.parentNode &&
						!Pu.test(f.parentNode.nodeName)
						? { ignore: !0 }
						: null;
				}
			})),
		u)
	)
		l = Vu(Yo(l, +u[1], +u[2]), u[4]);
	else if (((l = oe.maxOpen(Ru(l.content, s), !0)), l.openStart || l.openEnd)) {
		let d = 0,
			f = 0;
		for (
			let p = l.content.firstChild;
			d < l.openStart && !p.type.spec.isolating;
			d++, p = p.firstChild
		);
		for (
			let p = l.content.lastChild;
			f < l.openEnd && !p.type.spec.isolating;
			f++, p = p.lastChild
		);
		l = Yo(l, d, f);
	}
	return (
		t.someProp('transformPasted', (d) => {
			l = d(l, t);
		}),
		l
	);
}
const Pu =
	/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function Ru(t, e) {
	if (t.childCount < 2) return t;
	for (let n = e.depth; n >= 0; n--) {
		let s = e.node(n).contentMatchAt(e.index(n)),
			o,
			i = [];
		if (
			(t.forEach((l) => {
				if (!i) return;
				let a = s.findWrapping(l.type),
					c;
				if (!a) return (i = null);
				if ((c = i.length && o.length && gl(a, o, l, i[i.length - 1], 0))) i[i.length - 1] = c;
				else {
					i.length && (i[i.length - 1] = bl(i[i.length - 1], o.length));
					let u = ml(l, a);
					i.push(u), (s = s.matchType(u.type)), (o = a);
				}
			}),
			i)
		)
			return L.from(i);
	}
	return t;
}
function ml(t, e, n = 0) {
	for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, L.from(t));
	return t;
}
function gl(t, e, n, r, s) {
	if (s < t.length && s < e.length && t[s] == e[s]) {
		let o = gl(t, e, n, r.lastChild, s + 1);
		if (o) return r.copy(r.content.replaceChild(r.childCount - 1, o));
		if (r.contentMatchAt(r.childCount).matchType(s == t.length - 1 ? n.type : t[s + 1]))
			return r.copy(r.content.append(L.from(ml(n, t, s + 1))));
	}
}
function bl(t, e) {
	if (e == 0) return t;
	let n = t.content.replaceChild(t.childCount - 1, bl(t.lastChild, e - 1)),
		r = t.contentMatchAt(t.childCount).fillBefore(L.empty, !0);
	return t.copy(n.append(r));
}
function ys(t, e, n, r, s, o) {
	let i = e < 0 ? t.firstChild : t.lastChild,
		l = i.content;
	return (
		t.childCount > 1 && (o = 0),
		s < r - 1 && (l = ys(l, e, n, r, s + 1, o)),
		s >= n &&
			(l =
				e < 0
					? i
							.contentMatchAt(0)
							.fillBefore(l, o <= s)
							.append(l)
					: l.append(i.contentMatchAt(i.childCount).fillBefore(L.empty, !0))),
		t.replaceChild(e < 0 ? 0 : t.childCount - 1, i.copy(l))
	);
}
function Yo(t, e, n) {
	return (
		e < t.openStart && (t = new oe(ys(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)),
		n < t.openEnd && (t = new oe(ys(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
		t
	);
}
const kl = {
	thead: ['table'],
	tbody: ['table'],
	tfoot: ['table'],
	caption: ['table'],
	colgroup: ['table'],
	col: ['table', 'colgroup'],
	tr: ['table', 'tbody'],
	td: ['table', 'tbody', 'tr'],
	th: ['table', 'tbody', 'tr']
};
let Xo = null;
function yl() {
	return Xo || (Xo = document.implementation.createHTMLDocument('title'));
}
let Fr = null;
function Bu(t) {
	let e = window.trustedTypes;
	return e
		? (Fr ||
				(Fr = e.defaultPolicy || e.createPolicy('ProseMirrorClipboard', { createHTML: (n) => n })),
			Fr.createHTML(t))
		: t;
}
function zu(t) {
	let e = /^(\s*<meta [^>]*>)*/.exec(t);
	e && (t = t.slice(e[0].length));
	let n = yl().createElement('div'),
		r = /<([a-z][^>\s]+)/i.exec(t),
		s;
	if (
		((s = r && kl[r[1].toLowerCase()]) &&
			(t =
				s.map((o) => '<' + o + '>').join('') +
				t +
				s
					.map((o) => '</' + o + '>')
					.reverse()
					.join('')),
		(n.innerHTML = Bu(t)),
		s)
	)
		for (let o = 0; o < s.length; o++) n = n.querySelector(s[o]) || n;
	return n;
}
function Hu(t) {
	let e = t.querySelectorAll(he ? 'span:not([class]):not([style])' : 'span.Apple-converted-space');
	for (let n = 0; n < e.length; n++) {
		let r = e[n];
		r.childNodes.length == 1 &&
			r.textContent == ' ' &&
			r.parentNode &&
			r.parentNode.replaceChild(t.ownerDocument.createTextNode(' '), r);
	}
}
function Vu(t, e) {
	if (!t.size) return t;
	let n = t.content.firstChild.type.schema,
		r;
	try {
		r = JSON.parse(e);
	} catch {
		return t;
	}
	let { content: s, openStart: o, openEnd: i } = t;
	for (let l = r.length - 2; l >= 0; l -= 2) {
		let a = n.nodes[r[l]];
		if (!a || a.hasRequiredAttrs()) break;
		(s = L.from(a.create(r[l + 1], s))), o++, i++;
	}
	return new oe(s, o, i);
}
const $e = {},
	Se = {},
	Fu = { touchstart: !0, touchmove: !0 };
class ju {
	constructor() {
		(this.shiftKey = !1),
			(this.mouseDown = null),
			(this.lastKeyCode = null),
			(this.lastKeyCodeTime = 0),
			(this.lastClick = { time: 0, x: 0, y: 0, type: '', button: 0 }),
			(this.lastSelectionOrigin = null),
			(this.lastSelectionTime = 0),
			(this.lastIOSEnter = 0),
			(this.lastIOSEnterFallbackTimeout = -1),
			(this.lastFocus = 0),
			(this.lastTouch = 0),
			(this.lastChromeDelete = 0),
			(this.composing = !1),
			(this.compositionNode = null),
			(this.composingTimeout = -1),
			(this.compositionNodes = []),
			(this.compositionEndedAt = -2e8),
			(this.compositionID = 1),
			(this.compositionPendingChanges = 0),
			(this.domChangeCount = 0),
			(this.eventHandlers = Object.create(null)),
			(this.hideSelectionGuard = null);
	}
}
function Ku(t) {
	for (let e in $e) {
		let n = $e[e];
		t.dom.addEventListener(
			e,
			(t.input.eventHandlers[e] = (r) => {
				qu(t, r) && !qs(t, r) && (t.editable || !(r.type in Se)) && n(t, r);
			}),
			Fu[e] ? { passive: !0 } : void 0
		);
	}
	ye && t.dom.addEventListener('input', () => null), $s(t);
}
function ct(t, e) {
	(t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function Wu(t) {
	t.domObserver.stop();
	for (let e in t.input.eventHandlers) t.dom.removeEventListener(e, t.input.eventHandlers[e]);
	clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function $s(t) {
	t.someProp('handleDOMEvents', (e) => {
		for (let n in e)
			t.input.eventHandlers[n] ||
				t.dom.addEventListener(n, (t.input.eventHandlers[n] = (r) => qs(t, r)));
	});
}
function qs(t, e) {
	return t.someProp('handleDOMEvents', (n) => {
		let r = n[e.type];
		return r ? r(t, e) || e.defaultPrevented : !1;
	});
}
function qu(t, e) {
	if (!e.bubbles) return !0;
	if (e.defaultPrevented) return !1;
	for (let n = e.target; n != t.dom; n = n.parentNode)
		if (!n || n.nodeType == 11 || (n.pmViewDesc && n.pmViewDesc.stopEvent(e))) return !1;
	return !0;
}
function Uu(t, e) {
	!qs(t, e) && $e[e.type] && (t.editable || !(e.type in Se)) && $e[e.type](t, e);
}
Se.keydown = (t, e) => {
	let n = e;
	if (
		((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
		!Sl(t, n) &&
			((t.input.lastKeyCode = n.keyCode),
			(t.input.lastKeyCodeTime = Date.now()),
			!(Ze && he && n.keyCode == 13)))
	)
		if (
			(n.keyCode != 229 && t.domObserver.forceFlush(),
			Kt && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
		) {
			let r = Date.now();
			(t.input.lastIOSEnter = r),
				(t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
					t.input.lastIOSEnter == r &&
						(t.someProp('handleKeyDown', (s) => s(t, kt(13, 'Enter'))), (t.input.lastIOSEnter = 0));
				}, 200));
		} else
			t.someProp('handleKeyDown', (r) => r(t, n)) || Lu(t, n) ? n.preventDefault() : ct(t, 'key');
};
Se.keyup = (t, e) => {
	e.keyCode == 16 && (t.input.shiftKey = !1);
};
Se.keypress = (t, e) => {
	let n = e;
	if (Sl(t, n) || !n.charCode || (n.ctrlKey && !n.altKey) || (Ie && n.metaKey)) return;
	if (t.someProp('handleKeyPress', (s) => s(t, n))) {
		n.preventDefault();
		return;
	}
	let r = t.state.selection;
	if (!(r instanceof V) || !r.$from.sameParent(r.$to)) {
		let s = String.fromCharCode(n.charCode),
			o = () => t.state.tr.insertText(s).scrollIntoView();
		!/[\r\n]/.test(s) &&
			!t.someProp('handleTextInput', (i) => i(t, r.$from.pos, r.$to.pos, s, o)) &&
			t.dispatch(o()),
			n.preventDefault();
	}
};
function Dr(t) {
	return { left: t.clientX, top: t.clientY };
}
function Gu(t, e) {
	let n = e.x - t.clientX,
		r = e.y - t.clientY;
	return n * n + r * r < 100;
}
function Us(t, e, n, r, s) {
	if (r == -1) return !1;
	let o = t.state.doc.resolve(r);
	for (let i = o.depth + 1; i > 0; i--)
		if (
			t.someProp(e, (l) =>
				i > o.depth
					? l(t, n, o.nodeAfter, o.before(i), s, !0)
					: l(t, n, o.node(i), o.before(i), s, !1)
			)
		)
			return !0;
	return !1;
}
function Ht(t, e, n) {
	if ((t.focused || t.focus(), t.state.selection.eq(e))) return;
	let r = t.state.tr.setSelection(e);
	r.setMeta('pointer', !0), t.dispatch(r);
}
function Qu(t, e) {
	if (e == -1) return !1;
	let n = t.state.doc.resolve(e),
		r = n.nodeAfter;
	return r && r.isAtom && _.isSelectable(r) ? (Ht(t, new _(n)), !0) : !1;
}
function Ju(t, e) {
	if (e == -1) return !1;
	let n = t.state.selection,
		r,
		s;
	n instanceof _ && (r = n.node);
	let o = t.state.doc.resolve(e);
	for (let i = o.depth + 1; i > 0; i--) {
		let l = i > o.depth ? o.nodeAfter : o.node(i);
		if (_.isSelectable(l)) {
			r && n.$from.depth > 0 && i >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos
				? (s = o.before(n.$from.depth))
				: (s = o.before(i));
			break;
		}
	}
	return s != null ? (Ht(t, _.create(t.state.doc, s)), !0) : !1;
}
function Yu(t, e, n, r, s) {
	return (
		Us(t, 'handleClickOn', e, n, r) ||
		t.someProp('handleClick', (o) => o(t, e, r)) ||
		(s ? Ju(t, n) : Qu(t, n))
	);
}
function Xu(t, e, n, r) {
	return (
		Us(t, 'handleDoubleClickOn', e, n, r) || t.someProp('handleDoubleClick', (s) => s(t, e, r))
	);
}
function Zu(t, e, n, r) {
	return (
		Us(t, 'handleTripleClickOn', e, n, r) ||
		t.someProp('handleTripleClick', (s) => s(t, e, r)) ||
		ed(t, n, r)
	);
}
function ed(t, e, n) {
	if (n.button != 0) return !1;
	let r = t.state.doc;
	if (e == -1) return r.inlineContent ? (Ht(t, V.create(r, 0, r.content.size)), !0) : !1;
	let s = r.resolve(e);
	for (let o = s.depth + 1; o > 0; o--) {
		let i = o > s.depth ? s.nodeAfter : s.node(o),
			l = s.before(o);
		if (i.inlineContent) Ht(t, V.create(r, l + 1, l + 1 + i.content.size));
		else if (_.isSelectable(i)) Ht(t, _.create(r, l));
		else continue;
		return !0;
	}
}
function Gs(t) {
	return Wn(t);
}
const $l = Ie ? 'metaKey' : 'ctrlKey';
$e.mousedown = (t, e) => {
	let n = e;
	t.input.shiftKey = n.shiftKey;
	let r = Gs(t),
		s = Date.now(),
		o = 'singleClick';
	s - t.input.lastClick.time < 500 &&
		Gu(n, t.input.lastClick) &&
		!n[$l] &&
		t.input.lastClick.button == n.button &&
		(t.input.lastClick.type == 'singleClick'
			? (o = 'doubleClick')
			: t.input.lastClick.type == 'doubleClick' && (o = 'tripleClick')),
		(t.input.lastClick = { time: s, x: n.clientX, y: n.clientY, type: o, button: n.button });
	let i = t.posAtCoords(Dr(n));
	i &&
		(o == 'singleClick'
			? (t.input.mouseDown && t.input.mouseDown.done(), (t.input.mouseDown = new td(t, i, n, !!r)))
			: (o == 'doubleClick' ? Xu : Zu)(t, i.pos, i.inside, n)
				? n.preventDefault()
				: ct(t, 'pointer'));
};
class td {
	constructor(e, n, r, s) {
		(this.view = e),
			(this.pos = n),
			(this.event = r),
			(this.flushed = s),
			(this.delayedSelectionSync = !1),
			(this.mightDrag = null),
			(this.startDoc = e.state.doc),
			(this.selectNode = !!r[$l]),
			(this.allowDefault = r.shiftKey);
		let o, i;
		if (n.inside > -1) (o = e.state.doc.nodeAt(n.inside)), (i = n.inside);
		else {
			let u = e.state.doc.resolve(n.pos);
			(o = u.parent), (i = u.depth ? u.before() : 0);
		}
		const l = s ? null : r.target,
			a = l ? e.docView.nearestDesc(l, !0) : null;
		this.target = a && a.dom.nodeType == 1 ? a.dom : null;
		let { selection: c } = e.state;
		((r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1) ||
			(c instanceof _ && c.from <= i && c.to > i)) &&
			(this.mightDrag = {
				node: o,
				pos: i,
				addAttr: !!(this.target && !this.target.draggable),
				setUneditable: !!(this.target && Ve && !this.target.hasAttribute('contentEditable'))
			}),
			this.target &&
				this.mightDrag &&
				(this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr && (this.target.draggable = !0),
				this.mightDrag.setUneditable &&
					setTimeout(() => {
						this.view.input.mouseDown == this &&
							this.target.setAttribute('contentEditable', 'false');
					}, 20),
				this.view.domObserver.start()),
			e.root.addEventListener('mouseup', (this.up = this.up.bind(this))),
			e.root.addEventListener('mousemove', (this.move = this.move.bind(this))),
			ct(e, 'pointer');
	}
	done() {
		this.view.root.removeEventListener('mouseup', this.up),
			this.view.root.removeEventListener('mousemove', this.move),
			this.mightDrag &&
				this.target &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr && this.target.removeAttribute('draggable'),
				this.mightDrag.setUneditable && this.target.removeAttribute('contentEditable'),
				this.view.domObserver.start()),
			this.delayedSelectionSync && setTimeout(() => tt(this.view)),
			(this.view.input.mouseDown = null);
	}
	up(e) {
		if ((this.done(), !this.view.dom.contains(e.target))) return;
		let n = this.pos;
		this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Dr(e))),
			this.updateAllowDefault(e),
			this.allowDefault || !n
				? ct(this.view, 'pointer')
				: Yu(this.view, n.pos, n.inside, e, this.selectNode)
					? e.preventDefault()
					: e.button == 0 &&
						  (this.flushed ||
								(ye && this.mightDrag && !this.mightDrag.node.isAtom) ||
								(he &&
									!this.view.state.selection.visible &&
									Math.min(
										Math.abs(n.pos - this.view.state.selection.from),
										Math.abs(n.pos - this.view.state.selection.to)
									) <= 2))
						? (Ht(this.view, ne.near(this.view.state.doc.resolve(n.pos))), e.preventDefault())
						: ct(this.view, 'pointer');
	}
	move(e) {
		this.updateAllowDefault(e), ct(this.view, 'pointer'), e.buttons == 0 && this.done();
	}
	updateAllowDefault(e) {
		!this.allowDefault &&
			(Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) &&
			(this.allowDefault = !0);
	}
}
$e.touchstart = (t) => {
	(t.input.lastTouch = Date.now()), Gs(t), ct(t, 'pointer');
};
$e.touchmove = (t) => {
	(t.input.lastTouch = Date.now()), ct(t, 'pointer');
};
$e.contextmenu = (t) => Gs(t);
function Sl(t, e) {
	return t.composing
		? !0
		: ye && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
			? ((t.input.compositionEndedAt = -2e8), !0)
			: !1;
}
const nd = Ze ? 5e3 : -1;
Se.compositionstart = Se.compositionupdate = (t) => {
	if (!t.composing) {
		t.domObserver.flush();
		let { state: e } = t,
			n = e.selection.$to;
		if (
			e.selection instanceof V &&
			(e.storedMarks ||
				(!n.textOffset &&
					n.parentOffset &&
					n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
		)
			(t.markCursor = t.state.storedMarks || n.marks()), Wn(t, !0), (t.markCursor = null);
		else if (
			(Wn(t, !e.selection.empty),
			Ve && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length)
		) {
			let r = t.domSelectionRange();
			for (let s = r.focusNode, o = r.focusOffset; s && s.nodeType == 1 && o != 0; ) {
				let i = o < 0 ? s.lastChild : s.childNodes[o - 1];
				if (!i) break;
				if (i.nodeType == 3) {
					let l = t.domSelection();
					l && l.collapse(i, i.nodeValue.length);
					break;
				} else (s = i), (o = -1);
			}
		}
		t.input.composing = !0;
	}
	Ml(t, nd);
};
Se.compositionend = (t, e) => {
	t.composing &&
		((t.input.composing = !1),
		(t.input.compositionEndedAt = e.timeStamp),
		(t.input.compositionPendingChanges = t.domObserver.pendingRecords().length
			? t.input.compositionID
			: 0),
		(t.input.compositionNode = null),
		t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()),
		t.input.compositionID++,
		Ml(t, 20));
};
function Ml(t, e) {
	clearTimeout(t.input.composingTimeout),
		e > -1 && (t.input.composingTimeout = setTimeout(() => Wn(t), e));
}
function Cl(t) {
	for (
		t.composing && ((t.input.composing = !1), (t.input.compositionEndedAt = sd()));
		t.input.compositionNodes.length > 0;

	)
		t.input.compositionNodes.pop().markParentsDirty();
}
function rd(t) {
	let e = t.domSelectionRange();
	if (!e.focusNode) return null;
	let n = Qc(e.focusNode, e.focusOffset),
		r = Jc(e.focusNode, e.focusOffset);
	if (n && r && n != r) {
		let s = r.pmViewDesc,
			o = t.domObserver.lastChangedTextNode;
		if (n == o || r == o) return o;
		if (!s || !s.isText(r.nodeValue)) return r;
		if (t.input.compositionNode == r) {
			let i = n.pmViewDesc;
			if (!(!i || !i.isText(n.nodeValue))) return r;
		}
	}
	return n || r;
}
function sd() {
	let t = document.createEvent('Event');
	return t.initEvent('event', !0, !0), t.timeStamp;
}
function Wn(t, e = !1) {
	if (!(Ze && t.domObserver.flushingSoon >= 0)) {
		if ((t.domObserver.forceFlush(), Cl(t), e || (t.docView && t.docView.dirty))) {
			let n = js(t),
				r = t.state.selection;
			return (
				n && !n.eq(r)
					? t.dispatch(t.state.tr.setSelection(n))
					: (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent
						? t.dispatch(t.state.tr.deleteSelection())
						: t.updateState(t.state),
				!0
			);
		}
		return !1;
	}
}
function od(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.dom.parentNode.appendChild(document.createElement('div'));
	n.appendChild(e), (n.style.cssText = 'position: fixed; left: -10000px; top: 10px');
	let r = getSelection(),
		s = document.createRange();
	s.selectNodeContents(e),
		t.dom.blur(),
		r.removeAllRanges(),
		r.addRange(s),
		setTimeout(() => {
			n.parentNode && n.parentNode.removeChild(n), t.focus();
		}, 50);
}
const pn = (Ee && ut < 15) || (Kt && tu < 604);
$e.copy = Se.cut = (t, e) => {
	let n = e,
		r = t.state.selection,
		s = n.type == 'cut';
	if (r.empty) return;
	let o = pn ? null : n.clipboardData,
		i = r.content(),
		{ dom: l, text: a } = Ws(t, i);
	o
		? (n.preventDefault(),
			o.clearData(),
			o.setData('text/html', l.innerHTML),
			o.setData('text/plain', a))
		: od(t, l),
		s && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta('uiEvent', 'cut'));
};
function id(t) {
	return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
		? t.content.firstChild
		: null;
}
function ld(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
		r = t.dom.parentNode.appendChild(document.createElement(n ? 'textarea' : 'div'));
	n || (r.contentEditable = 'true'),
		(r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
		r.focus();
	let s = t.input.shiftKey && t.input.lastKeyCode != 45;
	setTimeout(() => {
		t.focus(),
			r.parentNode && r.parentNode.removeChild(r),
			n ? hn(t, r.value, null, s, e) : hn(t, r.textContent, r.innerHTML, s, e);
	}, 50);
}
function hn(t, e, n, r, s) {
	let o = hl(t, e, n, r, t.state.selection.$from);
	if (t.someProp('handlePaste', (a) => a(t, s, o || oe.empty))) return !0;
	if (!o) return !1;
	let i = id(o),
		l = i ? t.state.tr.replaceSelectionWith(i, r) : t.state.tr.replaceSelection(o);
	return t.dispatch(l.scrollIntoView().setMeta('paste', !0).setMeta('uiEvent', 'paste')), !0;
}
function Tl(t) {
	let e = t.getData('text/plain') || t.getData('Text');
	if (e) return e;
	let n = t.getData('text/uri-list');
	return n ? n.replace(/\r?\n/g, ' ') : '';
}
Se.paste = (t, e) => {
	let n = e;
	if (t.composing && !Ze) return;
	let r = pn ? null : n.clipboardData,
		s = t.input.shiftKey && t.input.lastKeyCode != 45;
	r && hn(t, Tl(r), r.getData('text/html'), s, n) ? n.preventDefault() : ld(t, n);
};
class xl {
	constructor(e, n, r) {
		(this.slice = e), (this.move = n), (this.node = r);
	}
}
const ad = Ie ? 'altKey' : 'ctrlKey';
function wl(t, e) {
	let n = t.someProp('dragCopies', (r) => !r(e));
	return n ?? !e[ad];
}
$e.dragstart = (t, e) => {
	let n = e,
		r = t.input.mouseDown;
	if ((r && r.done(), !n.dataTransfer)) return;
	let s = t.state.selection,
		o = s.empty ? null : t.posAtCoords(Dr(n)),
		i;
	if (!(o && o.pos >= s.from && o.pos <= (s instanceof _ ? s.to - 1 : s.to))) {
		if (r && r.mightDrag) i = _.create(t.state.doc, r.mightDrag.pos);
		else if (n.target && n.target.nodeType == 1) {
			let d = t.docView.nearestDesc(n.target, !0);
			d && d.node.type.spec.draggable && d != t.docView && (i = _.create(t.state.doc, d.posBefore));
		}
	}
	let l = (i || t.state.selection).content(),
		{ dom: a, text: c, slice: u } = Ws(t, l);
	(!n.dataTransfer.files.length || !he || Xi > 120) && n.dataTransfer.clearData(),
		n.dataTransfer.setData(pn ? 'Text' : 'text/html', a.innerHTML),
		(n.dataTransfer.effectAllowed = 'copyMove'),
		pn || n.dataTransfer.setData('text/plain', c),
		(t.dragging = new xl(u, wl(t, n), i));
};
$e.dragend = (t) => {
	let e = t.dragging;
	window.setTimeout(() => {
		t.dragging == e && (t.dragging = null);
	}, 50);
};
Se.dragover = Se.dragenter = (t, e) => e.preventDefault();
Se.drop = (t, e) => {
	let n = e,
		r = t.dragging;
	if (((t.dragging = null), !n.dataTransfer)) return;
	let s = t.posAtCoords(Dr(n));
	if (!s) return;
	let o = t.state.doc.resolve(s.pos),
		i = r && r.slice;
	i
		? t.someProp('transformPasted', (h) => {
				i = h(i, t);
			})
		: (i = hl(t, Tl(n.dataTransfer), pn ? null : n.dataTransfer.getData('text/html'), !1, o));
	let l = !!(r && wl(t, n));
	if (t.someProp('handleDrop', (h) => h(t, n, i || oe.empty, l))) {
		n.preventDefault();
		return;
	}
	if (!i) return;
	n.preventDefault();
	let a = i ? Wi(t.state.doc, o.pos, i) : o.pos;
	a == null && (a = o.pos);
	let c = t.state.tr;
	if (l) {
		let { node: h } = r;
		h ? h.replace(c) : c.deleteSelection();
	}
	let u = c.mapping.map(a),
		d = i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1,
		f = c.doc;
	if ((d ? c.replaceRangeWith(u, u, i.content.firstChild) : c.replaceRange(u, u, i), c.doc.eq(f)))
		return;
	let p = c.doc.resolve(u);
	if (
		d &&
		_.isSelectable(i.content.firstChild) &&
		p.nodeAfter &&
		p.nodeAfter.sameMarkup(i.content.firstChild)
	)
		c.setSelection(new _(p));
	else {
		let h = c.mapping.map(a);
		c.mapping.maps[c.mapping.maps.length - 1].forEach((g, m, b, k) => (h = k)),
			c.setSelection(Ks(t, p, c.doc.resolve(h)));
	}
	t.focus(), t.dispatch(c.setMeta('uiEvent', 'drop'));
};
$e.focus = (t) => {
	(t.input.lastFocus = Date.now()),
		t.focused ||
			(t.domObserver.stop(),
			t.dom.classList.add('ProseMirror-focused'),
			t.domObserver.start(),
			(t.focused = !0),
			setTimeout(() => {
				t.docView &&
					t.hasFocus() &&
					!t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
					tt(t);
			}, 20));
};
$e.blur = (t, e) => {
	let n = e;
	t.focused &&
		(t.domObserver.stop(),
		t.dom.classList.remove('ProseMirror-focused'),
		t.domObserver.start(),
		n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
		(t.focused = !1));
};
$e.beforeinput = (t, e) => {
	if (he && Ze && e.inputType == 'deleteContentBackward') {
		t.domObserver.flushSoon();
		let { domChangeCount: r } = t.input;
		setTimeout(() => {
			if (
				t.input.domChangeCount != r ||
				(t.dom.blur(), t.focus(), t.someProp('handleKeyDown', (o) => o(t, kt(8, 'Backspace'))))
			)
				return;
			let { $cursor: s } = t.state.selection;
			s && s.pos > 0 && t.dispatch(t.state.tr.delete(s.pos - 1, s.pos).scrollIntoView());
		}, 50);
	}
};
for (let t in Se) $e[t] = Se[t];
function mn(t, e) {
	if (t == e) return !0;
	for (let n in t) if (t[n] !== e[n]) return !1;
	for (let n in e) if (!(n in t)) return !1;
	return !0;
}
class qn {
	constructor(e, n) {
		(this.toDOM = e), (this.spec = n || Tt), (this.side = this.spec.side || 0);
	}
	map(e, n, r, s) {
		let { pos: o, deleted: i } = e.mapResult(n.from + s, this.side < 0 ? -1 : 1);
		return i ? null : new Ne(o - r, o - r, this);
	}
	valid() {
		return !0;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof qn &&
				((this.spec.key && this.spec.key == e.spec.key) ||
					(this.toDOM == e.toDOM && mn(this.spec, e.spec))))
		);
	}
	destroy(e) {
		this.spec.destroy && this.spec.destroy(e);
	}
}
class ft {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || Tt);
	}
	map(e, n, r, s) {
		let o = e.map(n.from + s, this.spec.inclusiveStart ? -1 : 1) - r,
			i = e.map(n.to + s, this.spec.inclusiveEnd ? 1 : -1) - r;
		return o >= i ? null : new Ne(o, i, this);
	}
	valid(e, n) {
		return n.from < n.to;
	}
	eq(e) {
		return this == e || (e instanceof ft && mn(this.attrs, e.attrs) && mn(this.spec, e.spec));
	}
	static is(e) {
		return e.type instanceof ft;
	}
	destroy() {}
}
class Qs {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || Tt);
	}
	map(e, n, r, s) {
		let o = e.mapResult(n.from + s, 1);
		if (o.deleted) return null;
		let i = e.mapResult(n.to + s, -1);
		return i.deleted || i.pos <= o.pos ? null : new Ne(o.pos - r, i.pos - r, this);
	}
	valid(e, n) {
		let { index: r, offset: s } = e.content.findIndex(n.from),
			o;
		return s == n.from && !(o = e.child(r)).isText && s + o.nodeSize == n.to;
	}
	eq(e) {
		return this == e || (e instanceof Qs && mn(this.attrs, e.attrs) && mn(this.spec, e.spec));
	}
	destroy() {}
}
class Ne {
	constructor(e, n, r) {
		(this.from = e), (this.to = n), (this.type = r);
	}
	copy(e, n) {
		return new Ne(e, n, this.type);
	}
	eq(e, n = 0) {
		return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
	}
	map(e, n, r) {
		return this.type.map(e, this, n, r);
	}
	static widget(e, n, r) {
		return new Ne(e, e, new qn(n, r));
	}
	static inline(e, n, r, s) {
		return new Ne(e, n, new ft(r, s));
	}
	static node(e, n, r, s) {
		return new Ne(e, n, new Qs(r, s));
	}
	get spec() {
		return this.type.spec;
	}
	get inline() {
		return this.type instanceof ft;
	}
	get widget() {
		return this.type instanceof qn;
	}
}
const _t = [],
	Tt = {};
class Y {
	constructor(e, n) {
		(this.local = e.length ? e : _t), (this.children = n.length ? n : _t);
	}
	static create(e, n) {
		return n.length ? Un(n, e, 0, Tt) : pe;
	}
	find(e, n, r) {
		let s = [];
		return this.findInner(e ?? 0, n ?? 1e9, s, 0, r), s;
	}
	findInner(e, n, r, s, o) {
		for (let i = 0; i < this.local.length; i++) {
			let l = this.local[i];
			l.from <= n && l.to >= e && (!o || o(l.spec)) && r.push(l.copy(l.from + s, l.to + s));
		}
		for (let i = 0; i < this.children.length; i += 3)
			if (this.children[i] < n && this.children[i + 1] > e) {
				let l = this.children[i] + 1;
				this.children[i + 2].findInner(e - l, n - l, r, s + l, o);
			}
	}
	map(e, n, r) {
		return this == pe || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Tt);
	}
	mapInner(e, n, r, s, o) {
		let i;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l].map(e, r, s);
			a && a.type.valid(n, a)
				? (i || (i = [])).push(a)
				: o.onRemove && o.onRemove(this.local[l].spec);
		}
		return this.children.length
			? cd(this.children, i || [], e, n, r, s, o)
			: i
				? new Y(i.sort(xt), _t)
				: pe;
	}
	add(e, n) {
		return n.length ? (this == pe ? Y.create(e, n) : this.addInner(e, n, 0)) : this;
	}
	addInner(e, n, r) {
		let s,
			o = 0;
		e.forEach((l, a) => {
			let c = a + r,
				u;
			if ((u = El(n, l, c))) {
				for (s || (s = this.children.slice()); o < s.length && s[o] < a; ) o += 3;
				s[o] == a
					? (s[o + 2] = s[o + 2].addInner(l, u, c + 1))
					: s.splice(o, 0, a, a + l.nodeSize, Un(u, l, c + 1, Tt)),
					(o += 3);
			}
		});
		let i = Al(o ? Ol(n) : n, -r);
		for (let l = 0; l < i.length; l++) i[l].type.valid(e, i[l]) || i.splice(l--, 1);
		return new Y(i.length ? this.local.concat(i).sort(xt) : this.local, s || this.children);
	}
	remove(e) {
		return e.length == 0 || this == pe ? this : this.removeInner(e, 0);
	}
	removeInner(e, n) {
		let r = this.children,
			s = this.local;
		for (let o = 0; o < r.length; o += 3) {
			let i,
				l = r[o] + n,
				a = r[o + 1] + n;
			for (let u = 0, d; u < e.length; u++)
				(d = e[u]) && d.from > l && d.to < a && ((e[u] = null), (i || (i = [])).push(d));
			if (!i) continue;
			r == this.children && (r = this.children.slice());
			let c = r[o + 2].removeInner(i, l + 1);
			c != pe ? (r[o + 2] = c) : (r.splice(o, 3), (o -= 3));
		}
		if (s.length) {
			for (let o = 0, i; o < e.length; o++)
				if ((i = e[o]))
					for (let l = 0; l < s.length; l++)
						s[l].eq(i, n) && (s == this.local && (s = this.local.slice()), s.splice(l--, 1));
		}
		return r == this.children && s == this.local ? this : s.length || r.length ? new Y(s, r) : pe;
	}
	forChild(e, n) {
		if (this == pe) return this;
		if (n.isLeaf) return Y.empty;
		let r, s;
		for (let l = 0; l < this.children.length; l += 3)
			if (this.children[l] >= e) {
				this.children[l] == e && (r = this.children[l + 2]);
				break;
			}
		let o = e + 1,
			i = o + n.content.size;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l];
			if (a.from < i && a.to > o && a.type instanceof ft) {
				let c = Math.max(o, a.from) - o,
					u = Math.min(i, a.to) - o;
				c < u && (s || (s = [])).push(a.copy(c, u));
			}
		}
		if (s) {
			let l = new Y(s.sort(xt), _t);
			return r ? new lt([l, r]) : l;
		}
		return r || pe;
	}
	eq(e) {
		if (this == e) return !0;
		if (
			!(e instanceof Y) ||
			this.local.length != e.local.length ||
			this.children.length != e.children.length
		)
			return !1;
		for (let n = 0; n < this.local.length; n++) if (!this.local[n].eq(e.local[n])) return !1;
		for (let n = 0; n < this.children.length; n += 3)
			if (
				this.children[n] != e.children[n] ||
				this.children[n + 1] != e.children[n + 1] ||
				!this.children[n + 2].eq(e.children[n + 2])
			)
				return !1;
		return !0;
	}
	locals(e) {
		return Js(this.localsInner(e));
	}
	localsInner(e) {
		if (this == pe) return _t;
		if (e.inlineContent || !this.local.some(ft.is)) return this.local;
		let n = [];
		for (let r = 0; r < this.local.length; r++)
			this.local[r].type instanceof ft || n.push(this.local[r]);
		return n;
	}
	forEachSet(e) {
		e(this);
	}
}
Y.empty = new Y([], []);
Y.removeOverlap = Js;
const pe = Y.empty;
class lt {
	constructor(e) {
		this.members = e;
	}
	map(e, n) {
		const r = this.members.map((s) => s.map(e, n, Tt));
		return lt.from(r);
	}
	forChild(e, n) {
		if (n.isLeaf) return Y.empty;
		let r = [];
		for (let s = 0; s < this.members.length; s++) {
			let o = this.members[s].forChild(e, n);
			o != pe && (o instanceof lt ? (r = r.concat(o.members)) : r.push(o));
		}
		return lt.from(r);
	}
	eq(e) {
		if (!(e instanceof lt) || e.members.length != this.members.length) return !1;
		for (let n = 0; n < this.members.length; n++) if (!this.members[n].eq(e.members[n])) return !1;
		return !0;
	}
	locals(e) {
		let n,
			r = !0;
		for (let s = 0; s < this.members.length; s++) {
			let o = this.members[s].localsInner(e);
			if (o.length)
				if (!n) n = o;
				else {
					r && ((n = n.slice()), (r = !1));
					for (let i = 0; i < o.length; i++) n.push(o[i]);
				}
		}
		return n ? Js(r ? n : n.sort(xt)) : _t;
	}
	static from(e) {
		switch (e.length) {
			case 0:
				return pe;
			case 1:
				return e[0];
			default:
				return new lt(
					e.every((n) => n instanceof Y)
						? e
						: e.reduce((n, r) => n.concat(r instanceof Y ? r : r.members), [])
				);
		}
	}
	forEachSet(e) {
		for (let n = 0; n < this.members.length; n++) this.members[n].forEachSet(e);
	}
}
function cd(t, e, n, r, s, o, i) {
	let l = t.slice();
	for (let c = 0, u = o; c < n.maps.length; c++) {
		let d = 0;
		n.maps[c].forEach((f, p, h, g) => {
			let m = g - h - (p - f);
			for (let b = 0; b < l.length; b += 3) {
				let k = l[b + 1];
				if (k < 0 || f > k + u - d) continue;
				let v = l[b] + u - d;
				p >= v ? (l[b + 1] = f <= v ? -2 : -1) : f >= u && m && ((l[b] += m), (l[b + 1] += m));
			}
			d += m;
		}),
			(u = n.maps[c].map(u, -1));
	}
	let a = !1;
	for (let c = 0; c < l.length; c += 3)
		if (l[c + 1] < 0) {
			if (l[c + 1] == -2) {
				(a = !0), (l[c + 1] = -1);
				continue;
			}
			let u = n.map(t[c] + o),
				d = u - s;
			if (d < 0 || d >= r.content.size) {
				a = !0;
				continue;
			}
			let f = n.map(t[c + 1] + o, -1),
				p = f - s,
				{ index: h, offset: g } = r.content.findIndex(d),
				m = r.maybeChild(h);
			if (m && g == d && g + m.nodeSize == p) {
				let b = l[c + 2].mapInner(n, m, u + 1, t[c] + o + 1, i);
				b != pe ? ((l[c] = d), (l[c + 1] = p), (l[c + 2] = b)) : ((l[c + 1] = -2), (a = !0));
			} else a = !0;
		}
	if (a) {
		let c = ud(l, t, e, n, s, o, i),
			u = Un(c, r, 0, i);
		e = u.local;
		for (let d = 0; d < l.length; d += 3) l[d + 1] < 0 && (l.splice(d, 3), (d -= 3));
		for (let d = 0, f = 0; d < u.children.length; d += 3) {
			let p = u.children[d];
			for (; f < l.length && l[f] < p; ) f += 3;
			l.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
		}
	}
	return new Y(e.sort(xt), l);
}
function Al(t, e) {
	if (!e || !t.length) return t;
	let n = [];
	for (let r = 0; r < t.length; r++) {
		let s = t[r];
		n.push(new Ne(s.from + e, s.to + e, s.type));
	}
	return n;
}
function ud(t, e, n, r, s, o, i) {
	function l(a, c) {
		for (let u = 0; u < a.local.length; u++) {
			let d = a.local[u].map(r, s, c);
			d ? n.push(d) : i.onRemove && i.onRemove(a.local[u].spec);
		}
		for (let u = 0; u < a.children.length; u += 3) l(a.children[u + 2], a.children[u] + c + 1);
	}
	for (let a = 0; a < t.length; a += 3) t[a + 1] == -1 && l(t[a + 2], e[a] + o + 1);
	return n;
}
function El(t, e, n) {
	if (e.isLeaf) return null;
	let r = n + e.nodeSize,
		s = null;
	for (let o = 0, i; o < t.length; o++)
		(i = t[o]) && i.from > n && i.to < r && ((s || (s = [])).push(i), (t[o] = null));
	return s;
}
function Ol(t) {
	let e = [];
	for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
	return e;
}
function Un(t, e, n, r) {
	let s = [],
		o = !1;
	e.forEach((l, a) => {
		let c = El(t, l, a + n);
		if (c) {
			o = !0;
			let u = Un(c, l, n + a + 1, r);
			u != pe && s.push(a, a + l.nodeSize, u);
		}
	});
	let i = Al(o ? Ol(t) : t, -n).sort(xt);
	for (let l = 0; l < i.length; l++)
		i[l].type.valid(e, i[l]) || (r.onRemove && r.onRemove(i[l].spec), i.splice(l--, 1));
	return i.length || s.length ? new Y(i, s) : pe;
}
function xt(t, e) {
	return t.from - e.from || t.to - e.to;
}
function Js(t) {
	let e = t;
	for (let n = 0; n < e.length - 1; n++) {
		let r = e[n];
		if (r.from != r.to)
			for (let s = n + 1; s < e.length; s++) {
				let o = e[s];
				if (o.from == r.from) {
					o.to != r.to &&
						(e == t && (e = t.slice()),
						(e[s] = o.copy(o.from, r.to)),
						Zo(e, s + 1, o.copy(r.to, o.to)));
					continue;
				} else {
					o.from < r.to &&
						(e == t && (e = t.slice()),
						(e[n] = r.copy(r.from, o.from)),
						Zo(e, s, r.copy(o.from, r.to)));
					break;
				}
			}
	}
	return e;
}
function Zo(t, e, n) {
	for (; e < t.length && xt(n, t[e]) > 0; ) e++;
	t.splice(e, 0, n);
}
function jr(t) {
	let e = [];
	return (
		t.someProp('decorations', (n) => {
			let r = n(t.state);
			r && r != pe && e.push(r);
		}),
		t.cursorWrapper && e.push(Y.create(t.state.doc, [t.cursorWrapper.deco])),
		lt.from(e)
	);
}
const dd = {
		childList: !0,
		characterData: !0,
		characterDataOldValue: !0,
		attributes: !0,
		attributeOldValue: !0,
		subtree: !0
	},
	fd = Ee && ut <= 11;
class pd {
	constructor() {
		(this.anchorNode = null),
			(this.anchorOffset = 0),
			(this.focusNode = null),
			(this.focusOffset = 0);
	}
	set(e) {
		(this.anchorNode = e.anchorNode),
			(this.anchorOffset = e.anchorOffset),
			(this.focusNode = e.focusNode),
			(this.focusOffset = e.focusOffset);
	}
	clear() {
		this.anchorNode = this.focusNode = null;
	}
	eq(e) {
		return (
			e.anchorNode == this.anchorNode &&
			e.anchorOffset == this.anchorOffset &&
			e.focusNode == this.focusNode &&
			e.focusOffset == this.focusOffset
		);
	}
}
class hd {
	constructor(e, n) {
		(this.view = e),
			(this.handleDOMChange = n),
			(this.queue = []),
			(this.flushingSoon = -1),
			(this.observer = null),
			(this.currentSelection = new pd()),
			(this.onCharData = null),
			(this.suppressingSelectionUpdates = !1),
			(this.lastChangedTextNode = null),
			(this.observer =
				window.MutationObserver &&
				new window.MutationObserver((r) => {
					for (let s = 0; s < r.length; s++) this.queue.push(r[s]);
					Ee &&
					ut <= 11 &&
					r.some(
						(s) =>
							(s.type == 'childList' && s.removedNodes.length) ||
							(s.type == 'characterData' && s.oldValue.length > s.target.nodeValue.length)
					)
						? this.flushSoon()
						: this.flush();
				})),
			fd &&
				(this.onCharData = (r) => {
					this.queue.push({ target: r.target, type: 'characterData', oldValue: r.prevValue }),
						this.flushSoon();
				}),
			(this.onSelectionChange = this.onSelectionChange.bind(this));
	}
	flushSoon() {
		this.flushingSoon < 0 &&
			(this.flushingSoon = window.setTimeout(() => {
				(this.flushingSoon = -1), this.flush();
			}, 20));
	}
	forceFlush() {
		this.flushingSoon > -1 &&
			(window.clearTimeout(this.flushingSoon), (this.flushingSoon = -1), this.flush());
	}
	start() {
		this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, dd)),
			this.onCharData &&
				this.view.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
			this.connectSelection();
	}
	stop() {
		if (this.observer) {
			let e = this.observer.takeRecords();
			if (e.length) {
				for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
				window.setTimeout(() => this.flush(), 20);
			}
			this.observer.disconnect();
		}
		this.onCharData &&
			this.view.dom.removeEventListener('DOMCharacterDataModified', this.onCharData),
			this.disconnectSelection();
	}
	connectSelection() {
		this.view.dom.ownerDocument.addEventListener('selectionchange', this.onSelectionChange);
	}
	disconnectSelection() {
		this.view.dom.ownerDocument.removeEventListener('selectionchange', this.onSelectionChange);
	}
	suppressSelectionUpdates() {
		(this.suppressingSelectionUpdates = !0),
			setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
	}
	onSelectionChange() {
		if (Wo(this.view)) {
			if (this.suppressingSelectionUpdates) return tt(this.view);
			if (Ee && ut <= 11 && !this.view.state.selection.empty) {
				let e = this.view.domSelectionRange();
				if (e.focusNode && Et(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
					return this.flushSoon();
			}
			this.flush();
		}
	}
	setCurSelection() {
		this.currentSelection.set(this.view.domSelectionRange());
	}
	ignoreSelectionChange(e) {
		if (!e.focusNode) return !0;
		let n = new Set(),
			r;
		for (let o = e.focusNode; o; o = jt(o)) n.add(o);
		for (let o = e.anchorNode; o; o = jt(o))
			if (n.has(o)) {
				r = o;
				break;
			}
		let s = r && this.view.docView.nearestDesc(r);
		if (s && s.ignoreMutation({ type: 'selection', target: r.nodeType == 3 ? r.parentNode : r }))
			return this.setCurSelection(), !0;
	}
	pendingRecords() {
		if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e);
		return this.queue;
	}
	flush() {
		let { view: e } = this;
		if (!e.docView || this.flushingSoon > -1) return;
		let n = this.pendingRecords();
		n.length && (this.queue = []);
		let r = e.domSelectionRange(),
			s =
				!this.suppressingSelectionUpdates &&
				!this.currentSelection.eq(r) &&
				Wo(e) &&
				!this.ignoreSelectionChange(r),
			o = -1,
			i = -1,
			l = !1,
			a = [];
		if (e.editable)
			for (let u = 0; u < n.length; u++) {
				let d = this.registerMutation(n[u], a);
				d &&
					((o = o < 0 ? d.from : Math.min(d.from, o)),
					(i = i < 0 ? d.to : Math.max(d.to, i)),
					d.typeOver && (l = !0));
			}
		if (Ve && a.length) {
			let u = a.filter((d) => d.nodeName == 'BR');
			if (u.length == 2) {
				let [d, f] = u;
				d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
			} else {
				let { focusNode: d } = this.currentSelection;
				for (let f of u) {
					let p = f.parentNode;
					p && p.nodeName == 'LI' && (!d || bd(e, d) != p) && f.remove();
				}
			}
		}
		let c = null;
		o < 0 &&
		s &&
		e.input.lastFocus > Date.now() - 200 &&
		Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 &&
		Or(r) &&
		(c = js(e)) &&
		c.eq(ne.near(e.state.doc.resolve(0), 1))
			? ((e.input.lastFocus = 0), tt(e), this.currentSelection.set(r), e.scrollToSelection())
			: (o > -1 || s) &&
				(o > -1 && (e.docView.markDirty(o, i), md(e)),
				this.handleDOMChange(o, i, l, a),
				e.docView && e.docView.dirty
					? e.updateState(e.state)
					: this.currentSelection.eq(r) || tt(e),
				this.currentSelection.set(r));
	}
	registerMutation(e, n) {
		if (n.indexOf(e.target) > -1) return null;
		let r = this.view.docView.nearestDesc(e.target);
		if (
			(e.type == 'attributes' &&
				(r == this.view.docView ||
					e.attributeName == 'contenteditable' ||
					(e.attributeName == 'style' && !e.oldValue && !e.target.getAttribute('style')))) ||
			!r ||
			r.ignoreMutation(e)
		)
			return null;
		if (e.type == 'childList') {
			for (let u = 0; u < e.addedNodes.length; u++) {
				let d = e.addedNodes[u];
				n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
			}
			if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
				return { from: r.posBefore, to: r.posAfter };
			let s = e.previousSibling,
				o = e.nextSibling;
			if (Ee && ut <= 11 && e.addedNodes.length)
				for (let u = 0; u < e.addedNodes.length; u++) {
					let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
					(!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d),
						(!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (o = f);
				}
			let i = s && s.parentNode == e.target ? de(s) + 1 : 0,
				l = r.localPosFromDOM(e.target, i, -1),
				a = o && o.parentNode == e.target ? de(o) : e.target.childNodes.length,
				c = r.localPosFromDOM(e.target, a, 1);
			return { from: l, to: c };
		} else
			return e.type == 'attributes'
				? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
				: ((this.lastChangedTextNode = e.target),
					{ from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue });
	}
}
let ei = new WeakMap(),
	ti = !1;
function md(t) {
	if (
		!ei.has(t) &&
		(ei.set(t, null),
		['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)
	) {
		if (((t.requiresGeckoHackNode = Ve), ti)) return;
		console.warn(
			"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
		),
			(ti = !0);
	}
}
function ni(t, e) {
	let n = e.startContainer,
		r = e.startOffset,
		s = e.endContainer,
		o = e.endOffset,
		i = t.domAtPos(t.state.selection.anchor);
	return (
		Et(i.node, i.offset, s, o) && ([n, r, s, o] = [s, o, n, r]),
		{ anchorNode: n, anchorOffset: r, focusNode: s, focusOffset: o }
	);
}
function gd(t, e) {
	if (e.getComposedRanges) {
		let s = e.getComposedRanges(t.root)[0];
		if (s) return ni(t, s);
	}
	let n;
	function r(s) {
		s.preventDefault(), s.stopImmediatePropagation(), (n = s.getTargetRanges()[0]);
	}
	return (
		t.dom.addEventListener('beforeinput', r, !0),
		document.execCommand('indent'),
		t.dom.removeEventListener('beforeinput', r, !0),
		n ? ni(t, n) : null
	);
}
function bd(t, e) {
	for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
		let r = t.docView.nearestDesc(n, !0);
		if (r && r.node.isBlock) return n;
	}
	return null;
}
function kd(t, e, n) {
	let { node: r, fromOffset: s, toOffset: o, from: i, to: l } = t.docView.parseRange(e, n),
		a = t.domSelectionRange(),
		c,
		u = a.anchorNode;
	if (
		(u &&
			t.dom.contains(u.nodeType == 1 ? u : u.parentNode) &&
			((c = [{ node: u, offset: a.anchorOffset }]),
			Or(a) || c.push({ node: a.focusNode, offset: a.focusOffset })),
		he && t.input.lastKeyCode === 8)
	)
		for (let m = o; m > s; m--) {
			let b = r.childNodes[m - 1],
				k = b.pmViewDesc;
			if (b.nodeName == 'BR' && !k) {
				o = m;
				break;
			}
			if (!k || k.size) break;
		}
	let d = t.state.doc,
		f = t.someProp('domParser') || zt.fromSchema(t.state.schema),
		p = d.resolve(i),
		h = null,
		g = f.parse(r, {
			topNode: p.parent,
			topMatch: p.parent.contentMatchAt(p.index()),
			topOpen: !0,
			from: s,
			to: o,
			preserveWhitespace: p.parent.type.whitespace == 'pre' ? 'full' : !0,
			findPositions: c,
			ruleFromNode: yd,
			context: p
		});
	if (c && c[0].pos != null) {
		let m = c[0].pos,
			b = c[1] && c[1].pos;
		b == null && (b = m), (h = { anchor: m + i, head: b + i });
	}
	return { doc: g, sel: h, from: i, to: l };
}
function yd(t) {
	let e = t.pmViewDesc;
	if (e) return e.parseRule();
	if (t.nodeName == 'BR' && t.parentNode) {
		if (ye && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
			let n = document.createElement('div');
			return n.appendChild(document.createElement('li')), { skip: n };
		} else if (t.parentNode.lastChild == t || (ye && /^(tr|table)$/i.test(t.parentNode.nodeName)))
			return { ignore: !0 };
	} else if (t.nodeName == 'IMG' && t.getAttribute('mark-placeholder')) return { ignore: !0 };
	return null;
}
const $d =
	/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Sd(t, e, n, r, s) {
	let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
	if (((t.input.compositionPendingChanges = 0), e < 0)) {
		let C = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null,
			F = js(t, C);
		if (F && !t.state.selection.eq(F)) {
			if (
				he &&
				Ze &&
				t.input.lastKeyCode === 13 &&
				Date.now() - 100 < t.input.lastKeyCodeTime &&
				t.someProp('handleKeyDown', (H) => H(t, kt(13, 'Enter')))
			)
				return;
			let N = t.state.tr.setSelection(F);
			C == 'pointer' ? N.setMeta('pointer', !0) : C == 'key' && N.scrollIntoView(),
				o && N.setMeta('composition', o),
				t.dispatch(N);
		}
		return;
	}
	let i = t.state.doc.resolve(e),
		l = i.sharedDepth(n);
	(e = i.before(l + 1)), (n = t.state.doc.resolve(n).after(l + 1));
	let a = t.state.selection,
		c = kd(t, e, n),
		u = t.state.doc,
		d = u.slice(c.from, c.to),
		f,
		p;
	t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
		? ((f = t.state.selection.to), (p = 'end'))
		: ((f = t.state.selection.from), (p = 'start')),
		(t.input.lastKeyCode = null);
	let h = Td(d.content, c.doc.content, c.from, f, p);
	if (
		(h && t.input.domChangeCount++,
		((Kt && t.input.lastIOSEnter > Date.now() - 225) || Ze) &&
			s.some((C) => C.nodeType == 1 && !$d.test(C.nodeName)) &&
			(!h || h.endA >= h.endB) &&
			t.someProp('handleKeyDown', (C) => C(t, kt(13, 'Enter'))))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (!h)
		if (
			r &&
			a instanceof V &&
			!a.empty &&
			a.$head.sameParent(a.$anchor) &&
			!t.composing &&
			!(c.sel && c.sel.anchor != c.sel.head)
		)
			h = { start: a.from, endA: a.to, endB: a.to };
		else {
			if (c.sel) {
				let C = ri(t, t.state.doc, c.sel);
				if (C && !C.eq(t.state.selection)) {
					let F = t.state.tr.setSelection(C);
					o && F.setMeta('composition', o), t.dispatch(F);
				}
			}
			return;
		}
	t.state.selection.from < t.state.selection.to &&
		h.start == h.endB &&
		t.state.selection instanceof V &&
		(h.start > t.state.selection.from &&
		h.start <= t.state.selection.from + 2 &&
		t.state.selection.from >= c.from
			? (h.start = t.state.selection.from)
			: h.endA < t.state.selection.to &&
				h.endA >= t.state.selection.to - 2 &&
				t.state.selection.to <= c.to &&
				((h.endB += t.state.selection.to - h.endA), (h.endA = t.state.selection.to))),
		Ee &&
			ut <= 11 &&
			h.endB == h.start + 1 &&
			h.endA == h.start &&
			h.start > c.from &&
			c.doc.textBetween(h.start - c.from - 1, h.start - c.from + 1) == '  ' &&
			(h.start--, h.endA--, h.endB--);
	let g = c.doc.resolveNoCache(h.start - c.from),
		m = c.doc.resolveNoCache(h.endB - c.from),
		b = u.resolve(h.start),
		k = g.sameParent(m) && g.parent.inlineContent && b.end() >= h.endA,
		v;
	if (
		((Kt &&
			t.input.lastIOSEnter > Date.now() - 225 &&
			(!k || s.some((C) => C.nodeName == 'DIV' || C.nodeName == 'P'))) ||
			(!k &&
				g.pos < c.doc.content.size &&
				(!g.sameParent(m) || !g.parent.inlineContent) &&
				!/\S/.test(c.doc.textBetween(g.pos, m.pos, '', '')) &&
				(v = ne.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) &&
				v.head > g.pos)) &&
		t.someProp('handleKeyDown', (C) => C(t, kt(13, 'Enter')))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (
		t.state.selection.anchor > h.start &&
		Cd(u, h.start, h.endA, g, m) &&
		t.someProp('handleKeyDown', (C) => C(t, kt(8, 'Backspace')))
	) {
		Ze && he && t.domObserver.suppressSelectionUpdates();
		return;
	}
	he && h.endB == h.start && (t.input.lastChromeDelete = Date.now()),
		Ze &&
			!k &&
			g.start() != m.start() &&
			m.parentOffset == 0 &&
			g.depth == m.depth &&
			c.sel &&
			c.sel.anchor == c.sel.head &&
			c.sel.head == h.endA &&
			((h.endB -= 2),
			(m = c.doc.resolveNoCache(h.endB - c.from)),
			setTimeout(() => {
				t.someProp('handleKeyDown', function (C) {
					return C(t, kt(13, 'Enter'));
				});
			}, 20));
	let I = h.start,
		T = h.endA,
		y = (C) => {
			let F = C || t.state.tr.replace(I, T, c.doc.slice(h.start - c.from, h.endB - c.from));
			if (c.sel) {
				let N = ri(t, F.doc, c.sel);
				N &&
					!(
						(he &&
							t.composing &&
							N.empty &&
							(h.start != h.endB || t.input.lastChromeDelete < Date.now() - 100) &&
							(N.head == I || N.head == F.mapping.map(T) - 1)) ||
						(Ee && N.empty && N.head == I)
					) &&
					F.setSelection(N);
			}
			return o && F.setMeta('composition', o), F.scrollIntoView();
		},
		D;
	if (k) {
		if (g.pos == m.pos) {
			Ee &&
				ut <= 11 &&
				g.parentOffset == 0 &&
				(t.domObserver.suppressSelectionUpdates(), setTimeout(() => tt(t), 20));
			let C = y(t.state.tr.delete(I, T)),
				F = u.resolve(h.start).marksAcross(u.resolve(h.endA));
			F && C.ensureMarks(F), t.dispatch(C);
		} else if (
			h.endA == h.endB &&
			(D = Md(
				g.parent.content.cut(g.parentOffset, m.parentOffset),
				b.parent.content.cut(b.parentOffset, h.endA - b.start())
			))
		) {
			let C = y(t.state.tr);
			D.type == 'add' ? C.addMark(I, T, D.mark) : C.removeMark(I, T, D.mark), t.dispatch(C);
		} else if (
			g.parent.child(g.index()).isText &&
			g.index() == m.index() - (m.textOffset ? 0 : 1)
		) {
			let C = g.parent.textBetween(g.parentOffset, m.parentOffset),
				F = () => y(t.state.tr.insertText(C, I, T));
			t.someProp('handleTextInput', (N) => N(t, I, T, C, F)) || t.dispatch(F());
		}
	} else t.dispatch(y());
}
function ri(t, e, n) {
	return Math.max(n.anchor, n.head) > e.content.size
		? null
		: Ks(t, e.resolve(n.anchor), e.resolve(n.head));
}
function Md(t, e) {
	let n = t.firstChild.marks,
		r = e.firstChild.marks,
		s = n,
		o = r,
		i,
		l,
		a;
	for (let u = 0; u < r.length; u++) s = r[u].removeFromSet(s);
	for (let u = 0; u < n.length; u++) o = n[u].removeFromSet(o);
	if (s.length == 1 && o.length == 0)
		(l = s[0]), (i = 'add'), (a = (u) => u.mark(l.addToSet(u.marks)));
	else if (s.length == 0 && o.length == 1)
		(l = o[0]), (i = 'remove'), (a = (u) => u.mark(l.removeFromSet(u.marks)));
	else return null;
	let c = [];
	for (let u = 0; u < e.childCount; u++) c.push(a(e.child(u)));
	if (L.from(c).eq(t)) return { mark: l, type: i };
}
function Cd(t, e, n, r, s) {
	if (n - e <= s.pos - r.pos || Kr(r, !0, !1) < s.pos) return !1;
	let o = t.resolve(e);
	if (!r.parent.isTextblock) {
		let l = o.nodeAfter;
		return l != null && n == e + l.nodeSize;
	}
	if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock) return !1;
	let i = t.resolve(Kr(o, !0, !0));
	return !i.parent.isTextblock || i.pos > n || Kr(i, !0, !1) < n
		? !1
		: r.parent.content.cut(r.parentOffset).eq(i.parent.content);
}
function Kr(t, e, n) {
	let r = t.depth,
		s = e ? t.end() : t.pos;
	for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); ) r--, s++, (e = !1);
	if (n) {
		let o = t.node(r).maybeChild(t.indexAfter(r));
		for (; o && !o.isLeaf; ) (o = o.firstChild), s++;
	}
	return s;
}
function Td(t, e, n, r, s) {
	let o = t.findDiffStart(e, n);
	if (o == null) return null;
	let { a: i, b: l } = t.findDiffEnd(e, n + t.size, n + e.size);
	if (s == 'end') {
		let a = Math.max(0, o - Math.min(i, l));
		r -= i + a - o;
	}
	if (i < o && t.size < e.size) {
		let a = r <= o && r >= i ? o - r : 0;
		(o -= a),
			o && o < e.size && si(e.textBetween(o - 1, o + 1)) && (o += a ? 1 : -1),
			(l = o + (l - i)),
			(i = o);
	} else if (l < o) {
		let a = r <= o && r >= l ? o - r : 0;
		(o -= a),
			o && o < t.size && si(t.textBetween(o - 1, o + 1)) && (o += a ? 1 : -1),
			(i = o + (i - l)),
			(l = o);
	}
	return { start: o, endA: i, endB: l };
}
function si(t) {
	if (t.length != 2) return !1;
	let e = t.charCodeAt(0),
		n = t.charCodeAt(1);
	return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Nl {
	constructor(e, n) {
		(this._root = null),
			(this.focused = !1),
			(this.trackWrites = null),
			(this.mounted = !1),
			(this.markCursor = null),
			(this.cursorWrapper = null),
			(this.lastSelectedViewDesc = void 0),
			(this.input = new ju()),
			(this.prevDirectPlugins = []),
			(this.pluginViews = []),
			(this.requiresGeckoHackNode = !1),
			(this.dragging = null),
			(this._props = n),
			(this.state = n.state),
			(this.directPlugins = n.plugins || []),
			this.directPlugins.forEach(ci),
			(this.dispatch = this.dispatch.bind(this)),
			(this.dom = (e && e.mount) || document.createElement('div')),
			e &&
				(e.appendChild
					? e.appendChild(this.dom)
					: typeof e == 'function'
						? e(this.dom)
						: e.mount && (this.mounted = !0)),
			(this.editable = li(this)),
			ii(this),
			(this.nodeViews = ai(this)),
			(this.docView = zo(this.state.doc, oi(this), jr(this), this.dom, this)),
			(this.domObserver = new hd(this, (r, s, o, i) => Sd(this, r, s, o, i))),
			this.domObserver.start(),
			Ku(this),
			this.updatePluginViews();
	}
	get composing() {
		return this.input.composing;
	}
	get props() {
		if (this._props.state != this.state) {
			let e = this._props;
			this._props = {};
			for (let n in e) this._props[n] = e[n];
			this._props.state = this.state;
		}
		return this._props;
	}
	update(e) {
		e.handleDOMEvents != this._props.handleDOMEvents && $s(this);
		let n = this._props;
		(this._props = e),
			e.plugins && (e.plugins.forEach(ci), (this.directPlugins = e.plugins)),
			this.updateStateInner(e.state, n);
	}
	setProps(e) {
		let n = {};
		for (let r in this._props) n[r] = this._props[r];
		n.state = this.state;
		for (let r in e) n[r] = e[r];
		this.update(n);
	}
	updateState(e) {
		this.updateStateInner(e, this._props);
	}
	updateStateInner(e, n) {
		var r;
		let s = this.state,
			o = !1,
			i = !1;
		e.storedMarks && this.composing && (Cl(this), (i = !0)), (this.state = e);
		let l = s.plugins != e.plugins || this._props.plugins != n.plugins;
		if (l || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
			let p = ai(this);
			wd(p, this.nodeViews) && ((this.nodeViews = p), (o = !0));
		}
		(l || n.handleDOMEvents != this._props.handleDOMEvents) && $s(this),
			(this.editable = li(this)),
			ii(this);
		let a = jr(this),
			c = oi(this),
			u =
				s.plugins != e.plugins && !s.doc.eq(e.doc)
					? 'reset'
					: e.scrollToSelection > s.scrollToSelection
						? 'to selection'
						: 'preserve',
			d = o || !this.docView.matchesNode(e.doc, c, a);
		(d || !e.selection.eq(s.selection)) && (i = !0);
		let f = u == 'preserve' && i && this.dom.style.overflowAnchor == null && su(this);
		if (i) {
			this.domObserver.stop();
			let p =
				d &&
				(Ee || he) &&
				!this.composing &&
				!s.selection.empty &&
				!e.selection.empty &&
				xd(s.selection, e.selection);
			if (d) {
				let h = he ? (this.trackWrites = this.domSelectionRange().focusNode) : null;
				this.composing && (this.input.compositionNode = rd(this)),
					(o || !this.docView.update(e.doc, c, a, this)) &&
						(this.docView.updateOuterDeco(c),
						this.docView.destroy(),
						(this.docView = zo(e.doc, c, a, this.dom, this))),
					h && !this.trackWrites && (p = !0);
			}
			p ||
			!(
				this.input.mouseDown &&
				this.domObserver.currentSelection.eq(this.domSelectionRange()) &&
				Eu(this)
			)
				? tt(this, p)
				: (dl(this, e.selection), this.domObserver.setCurSelection()),
				this.domObserver.start();
		}
		this.updatePluginViews(s),
			!((r = this.dragging) === null || r === void 0) &&
				r.node &&
				!s.doc.eq(e.doc) &&
				this.updateDraggedNode(this.dragging, s),
			u == 'reset'
				? (this.dom.scrollTop = 0)
				: u == 'to selection'
					? this.scrollToSelection()
					: f && ou(f);
	}
	scrollToSelection() {
		let e = this.domSelectionRange().focusNode;
		if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
			if (!this.someProp('handleScrollToSelection', (n) => n(this)))
				if (this.state.selection instanceof _) {
					let n = this.docView.domAfterPos(this.state.selection.from);
					n.nodeType == 1 && _o(this, n.getBoundingClientRect(), e);
				} else _o(this, this.coordsAtPos(this.state.selection.head, 1), e);
		}
	}
	destroyPluginViews() {
		let e;
		for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
	}
	updatePluginViews(e) {
		if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
			(this.prevDirectPlugins = this.directPlugins), this.destroyPluginViews();
			for (let n = 0; n < this.directPlugins.length; n++) {
				let r = this.directPlugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
			for (let n = 0; n < this.state.plugins.length; n++) {
				let r = this.state.plugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
		} else
			for (let n = 0; n < this.pluginViews.length; n++) {
				let r = this.pluginViews[n];
				r.update && r.update(this, e);
			}
	}
	updateDraggedNode(e, n) {
		let r = e.node,
			s = -1;
		if (this.state.doc.nodeAt(r.from) == r.node) s = r.from;
		else {
			let o = r.from + (this.state.doc.content.size - n.doc.content.size);
			(o > 0 && this.state.doc.nodeAt(o)) == r.node && (s = o);
		}
		this.dragging = new xl(e.slice, e.move, s < 0 ? void 0 : _.create(this.state.doc, s));
	}
	someProp(e, n) {
		let r = this._props && this._props[e],
			s;
		if (r != null && (s = n ? n(r) : r)) return s;
		for (let i = 0; i < this.directPlugins.length; i++) {
			let l = this.directPlugins[i].props[e];
			if (l != null && (s = n ? n(l) : l)) return s;
		}
		let o = this.state.plugins;
		if (o)
			for (let i = 0; i < o.length; i++) {
				let l = o[i].props[e];
				if (l != null && (s = n ? n(l) : l)) return s;
			}
	}
	hasFocus() {
		if (Ee) {
			let e = this.root.activeElement;
			if (e == this.dom) return !0;
			if (!e || !this.dom.contains(e)) return !1;
			for (; e && this.dom != e && this.dom.contains(e); ) {
				if (e.contentEditable == 'false') return !1;
				e = e.parentElement;
			}
			return !0;
		}
		return this.root.activeElement == this.dom;
	}
	focus() {
		this.domObserver.stop(), this.editable && iu(this.dom), tt(this), this.domObserver.start();
	}
	get root() {
		let e = this._root;
		if (e == null) {
			for (let n = this.dom.parentNode; n; n = n.parentNode)
				if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
					return (
						n.getSelection ||
							(Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
						(this._root = n)
					);
		}
		return e || document;
	}
	updateRoot() {
		this._root = null;
	}
	posAtCoords(e) {
		return du(this, e);
	}
	coordsAtPos(e, n = 1) {
		return rl(this, e, n);
	}
	domAtPos(e, n = 0) {
		return this.docView.domFromPos(e, n);
	}
	nodeDOM(e) {
		let n = this.docView.descAt(e);
		return n ? n.nodeDOM : null;
	}
	posAtDOM(e, n, r = -1) {
		let s = this.docView.posFromDOM(e, n, r);
		if (s == null) throw new RangeError('DOM position not inside the editor');
		return s;
	}
	endOfTextblock(e, n) {
		return gu(this, n || this.state, e);
	}
	pasteHTML(e, n) {
		return hn(this, '', e, !1, n || new ClipboardEvent('paste'));
	}
	pasteText(e, n) {
		return hn(this, e, null, !0, n || new ClipboardEvent('paste'));
	}
	serializeForClipboard(e) {
		return Ws(this, e);
	}
	destroy() {
		this.docView &&
			(Wu(this),
			this.destroyPluginViews(),
			this.mounted
				? (this.docView.update(this.state.doc, [], jr(this), this), (this.dom.textContent = ''))
				: this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
			this.docView.destroy(),
			(this.docView = null),
			Uc());
	}
	get isDestroyed() {
		return this.docView == null;
	}
	dispatchEvent(e) {
		return Uu(this, e);
	}
	domSelectionRange() {
		let e = this.domSelection();
		return e
			? (ye &&
					this.root.nodeType === 11 &&
					Xc(this.dom.ownerDocument) == this.dom &&
					gd(this, e)) ||
					e
			: { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
	}
	domSelection() {
		return this.root.getSelection();
	}
}
Nl.prototype.dispatch = function (t) {
	let e = this._props.dispatchTransaction;
	e ? e.call(this, t) : this.updateState(this.state.apply(t));
};
function oi(t) {
	let e = Object.create(null);
	return (
		(e.class = 'ProseMirror'),
		(e.contenteditable = String(t.editable)),
		t.someProp('attributes', (n) => {
			if ((typeof n == 'function' && (n = n(t.state)), n))
				for (let r in n)
					r == 'class'
						? (e.class += ' ' + n[r])
						: r == 'style'
							? (e.style = (e.style ? e.style + ';' : '') + n[r])
							: !e[r] && r != 'contenteditable' && r != 'nodeName' && (e[r] = String(n[r]));
		}),
		e.translate || (e.translate = 'no'),
		[Ne.node(0, t.state.doc.content.size, e)]
	);
}
function ii(t) {
	if (t.markCursor) {
		let e = document.createElement('img');
		(e.className = 'ProseMirror-separator'),
			e.setAttribute('mark-placeholder', 'true'),
			e.setAttribute('alt', ''),
			(t.cursorWrapper = {
				dom: e,
				deco: Ne.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor })
			});
	} else t.cursorWrapper = null;
}
function li(t) {
	return !t.someProp('editable', (e) => e(t.state) === !1);
}
function xd(t, e) {
	let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
	return t.$anchor.start(n) != e.$anchor.start(n);
}
function ai(t) {
	let e = Object.create(null);
	function n(r) {
		for (let s in r) Object.prototype.hasOwnProperty.call(e, s) || (e[s] = r[s]);
	}
	return t.someProp('nodeViews', n), t.someProp('markViews', n), e;
}
function wd(t, e) {
	let n = 0,
		r = 0;
	for (let s in t) {
		if (t[s] != e[s]) return !0;
		n++;
	}
	for (let s in e) r++;
	return n != r;
}
function ci(t) {
	if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
		throw new RangeError('Plugins passed directly to the view must not have a state component');
}
var pt = {
		8: 'Backspace',
		9: 'Tab',
		10: 'Enter',
		12: 'NumLock',
		13: 'Enter',
		16: 'Shift',
		17: 'Control',
		18: 'Alt',
		20: 'CapsLock',
		27: 'Escape',
		32: ' ',
		33: 'PageUp',
		34: 'PageDown',
		35: 'End',
		36: 'Home',
		37: 'ArrowLeft',
		38: 'ArrowUp',
		39: 'ArrowRight',
		40: 'ArrowDown',
		44: 'PrintScreen',
		45: 'Insert',
		46: 'Delete',
		59: ';',
		61: '=',
		91: 'Meta',
		92: 'Meta',
		106: '*',
		107: '+',
		108: ',',
		109: '-',
		110: '.',
		111: '/',
		144: 'NumLock',
		145: 'ScrollLock',
		160: 'Shift',
		161: 'Shift',
		162: 'Control',
		163: 'Control',
		164: 'Alt',
		165: 'Alt',
		173: '-',
		186: ';',
		187: '=',
		188: ',',
		189: '-',
		190: '.',
		191: '/',
		192: '`',
		219: '[',
		220: '\\',
		221: ']',
		222: "'"
	},
	Gn = {
		48: ')',
		49: '!',
		50: '@',
		51: '#',
		52: '$',
		53: '%',
		54: '^',
		55: '&',
		56: '*',
		57: '(',
		59: ':',
		61: '+',
		173: '_',
		186: ':',
		187: '+',
		188: '<',
		189: '_',
		190: '>',
		191: '?',
		192: '~',
		219: '{',
		220: '|',
		221: '}',
		222: '"'
	},
	Ad = typeof navigator < 'u' && /Mac/.test(navigator.platform),
	Ed =
		typeof navigator < 'u' &&
		/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var fe = 0; fe < 10; fe++) pt[48 + fe] = pt[96 + fe] = String(fe);
for (var fe = 1; fe <= 24; fe++) pt[fe + 111] = 'F' + fe;
for (var fe = 65; fe <= 90; fe++)
	(pt[fe] = String.fromCharCode(fe + 32)), (Gn[fe] = String.fromCharCode(fe));
for (var Wr in pt) Gn.hasOwnProperty(Wr) || (Gn[Wr] = pt[Wr]);
function Od(t) {
	var e =
			(Ad && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
			(Ed && t.shiftKey && t.key && t.key.length == 1) ||
			t.key == 'Unidentified',
		n = (!e && t.key) || (t.shiftKey ? Gn : pt)[t.keyCode] || t.key || 'Unidentified';
	return (
		n == 'Esc' && (n = 'Escape'),
		n == 'Del' && (n = 'Delete'),
		n == 'Left' && (n = 'ArrowLeft'),
		n == 'Up' && (n = 'ArrowUp'),
		n == 'Right' && (n = 'ArrowRight'),
		n == 'Down' && (n = 'ArrowDown'),
		n
	);
}
const Nd = typeof navigator < 'u' && /Mac|iP(hone|[oa]d)/.test(navigator.platform),
	Dd = typeof navigator < 'u' && /Win/.test(navigator.platform);
function vd(t) {
	let e = t.split(/-(?!$)/),
		n = e[e.length - 1];
	n == 'Space' && (n = ' ');
	let r, s, o, i;
	for (let l = 0; l < e.length - 1; l++) {
		let a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) i = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) s = !0;
		else if (/^s(hift)?$/i.test(a)) o = !0;
		else if (/^mod$/i.test(a)) Nd ? (i = !0) : (s = !0);
		else throw new Error('Unrecognized modifier name: ' + a);
	}
	return (
		r && (n = 'Alt-' + n),
		s && (n = 'Ctrl-' + n),
		i && (n = 'Meta-' + n),
		o && (n = 'Shift-' + n),
		n
	);
}
function _d(t) {
	let e = Object.create(null);
	for (let n in t) e[vd(n)] = t[n];
	return e;
}
function qr(t, e, n = !0) {
	return (
		e.altKey && (t = 'Alt-' + t),
		e.ctrlKey && (t = 'Ctrl-' + t),
		e.metaKey && (t = 'Meta-' + t),
		n && e.shiftKey && (t = 'Shift-' + t),
		t
	);
}
function Id(t) {
	return new ie({ props: { handleKeyDown: Dl(t) } });
}
function Dl(t) {
	let e = _d(t);
	return function (n, r) {
		let s = Od(r),
			o,
			i = e[qr(s, r)];
		if (i && i(n.state, n.dispatch, n)) return !0;
		if (s.length == 1 && s != ' ') {
			if (r.shiftKey) {
				let l = e[qr(s, r, !1)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
			if (
				(r.altKey || r.metaKey || r.ctrlKey) &&
				!(Dd && r.ctrlKey && r.altKey) &&
				(o = pt[r.keyCode]) &&
				o != s
			) {
				let l = e[qr(o, r)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
		}
		return !1;
	};
}
const Ys = (t, e) =>
	t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function vl(t, e) {
	let { $cursor: n } = t.selection;
	return !n || (e ? !e.endOfTextblock('backward', t) : n.parentOffset > 0) ? null : n;
}
const _l = (t, e, n) => {
		let r = vl(t, n);
		if (!r) return !1;
		let s = Xs(r);
		if (!s) {
			let i = r.blockRange(),
				l = i && Xt(i);
			return l == null ? !1 : (e && e(t.tr.lift(i, l).scrollIntoView()), !0);
		}
		let o = s.nodeBefore;
		if (Fl(t, s, e, -1)) return !0;
		if (r.parent.content.size == 0 && (Wt(o, 'end') || _.isSelectable(o)))
			for (let i = r.depth; ; i--) {
				let l = zs(t.doc, r.before(i), r.after(i), oe.empty);
				if (l && l.slice.size < l.to - l.from) {
					if (e) {
						let a = t.tr.step(l);
						a.setSelection(
							Wt(o, 'end')
								? ne.findFrom(a.doc.resolve(a.mapping.map(s.pos, -1)), -1)
								: _.create(a.doc, s.pos - o.nodeSize)
						),
							e(a.scrollIntoView());
					}
					return !0;
				}
				if (i == 1 || r.node(i - 1).childCount > 1) break;
			}
		return o.isAtom && s.depth == r.depth - 1
			? (e && e(t.tr.delete(s.pos - o.nodeSize, s.pos).scrollIntoView()), !0)
			: !1;
	},
	Ld = (t, e, n) => {
		let r = vl(t, n);
		if (!r) return !1;
		let s = Xs(r);
		return s ? Il(t, s, e) : !1;
	},
	Pd = (t, e, n) => {
		let r = Pl(t, n);
		if (!r) return !1;
		let s = Zs(r);
		return s ? Il(t, s, e) : !1;
	};
function Il(t, e, n) {
	let r = e.nodeBefore,
		s = r,
		o = e.pos - 1;
	for (; !s.isTextblock; o--) {
		if (s.type.spec.isolating) return !1;
		let u = s.lastChild;
		if (!u) return !1;
		s = u;
	}
	let i = e.nodeAfter,
		l = i,
		a = e.pos + 1;
	for (; !l.isTextblock; a++) {
		if (l.type.spec.isolating) return !1;
		let u = l.firstChild;
		if (!u) return !1;
		l = u;
	}
	let c = zs(t.doc, o, a, oe.empty);
	if (!c || c.from != o || (c instanceof qi && c.slice.size >= a - o)) return !1;
	if (n) {
		let u = t.tr.step(c);
		u.setSelection(V.create(u.doc, o)), n(u.scrollIntoView());
	}
	return !0;
}
function Wt(t, e, n = !1) {
	for (let r = t; r; r = e == 'start' ? r.firstChild : r.lastChild) {
		if (r.isTextblock) return !0;
		if (n && r.childCount != 1) return !1;
	}
	return !1;
}
const Ll = (t, e, n) => {
	let { $head: r, empty: s } = t.selection,
		o = r;
	if (!s) return !1;
	if (r.parent.isTextblock) {
		if (n ? !n.endOfTextblock('backward', t) : r.parentOffset > 0) return !1;
		o = Xs(r);
	}
	let i = o && o.nodeBefore;
	return !i || !_.isSelectable(i)
		? !1
		: (e && e(t.tr.setSelection(_.create(t.doc, o.pos - i.nodeSize)).scrollIntoView()), !0);
};
function Xs(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
			if (t.node(e).type.spec.isolating) break;
		}
	return null;
}
function Pl(t, e) {
	let { $cursor: n } = t.selection;
	return !n || (e ? !e.endOfTextblock('forward', t) : n.parentOffset < n.parent.content.size)
		? null
		: n;
}
const Rl = (t, e, n) => {
		let r = Pl(t, n);
		if (!r) return !1;
		let s = Zs(r);
		if (!s) return !1;
		let o = s.nodeAfter;
		if (Fl(t, s, e, 1)) return !0;
		if (r.parent.content.size == 0 && (Wt(o, 'start') || _.isSelectable(o))) {
			let i = zs(t.doc, r.before(), r.after(), oe.empty);
			if (i && i.slice.size < i.to - i.from) {
				if (e) {
					let l = t.tr.step(i);
					l.setSelection(
						Wt(o, 'start')
							? ne.findFrom(l.doc.resolve(l.mapping.map(s.pos)), 1)
							: _.create(l.doc, l.mapping.map(s.pos))
					),
						e(l.scrollIntoView());
				}
				return !0;
			}
		}
		return o.isAtom && s.depth == r.depth - 1
			? (e && e(t.tr.delete(s.pos, s.pos + o.nodeSize).scrollIntoView()), !0)
			: !1;
	},
	Bl = (t, e, n) => {
		let { $head: r, empty: s } = t.selection,
			o = r;
		if (!s) return !1;
		if (r.parent.isTextblock) {
			if (n ? !n.endOfTextblock('forward', t) : r.parentOffset < r.parent.content.size) return !1;
			o = Zs(r);
		}
		let i = o && o.nodeAfter;
		return !i || !_.isSelectable(i)
			? !1
			: (e && e(t.tr.setSelection(_.create(t.doc, o.pos)).scrollIntoView()), !0);
	};
function Zs(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			let n = t.node(e);
			if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1));
			if (n.type.spec.isolating) break;
		}
	return null;
}
const Rd = (t, e) => {
		let n = t.selection,
			r = n instanceof _,
			s;
		if (r) {
			if (n.node.isTextblock || !ht(t.doc, n.from)) return !1;
			s = n.from;
		} else if (((s = Er(t.doc, n.from, -1)), s == null)) return !1;
		if (e) {
			let o = t.tr.join(s);
			r && o.setSelection(_.create(o.doc, s - t.doc.resolve(s).nodeBefore.nodeSize)),
				e(o.scrollIntoView());
		}
		return !0;
	},
	Bd = (t, e) => {
		let n = t.selection,
			r;
		if (n instanceof _) {
			if (n.node.isTextblock || !ht(t.doc, n.to)) return !1;
			r = n.to;
		} else if (((r = Er(t.doc, n.to, 1)), r == null)) return !1;
		return e && e(t.tr.join(r).scrollIntoView()), !0;
	},
	zd = (t, e) => {
		let { $from: n, $to: r } = t.selection,
			s = n.blockRange(r),
			o = s && Xt(s);
		return o == null ? !1 : (e && e(t.tr.lift(s, o).scrollIntoView()), !0);
	},
	zl = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		return !n.parent.type.spec.code || !n.sameParent(r)
			? !1
			: (e &&
					e(
						t.tr
							.insertText(
								`
`
							)
							.scrollIntoView()
					),
				!0);
	};
function eo(t) {
	for (let e = 0; e < t.edgeCount; e++) {
		let { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
const Hd = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
		let s = n.node(-1),
			o = n.indexAfter(-1),
			i = eo(s.contentMatchAt(o));
		if (!i || !s.canReplaceWith(o, o, i)) return !1;
		if (e) {
			let l = n.after(),
				a = t.tr.replaceWith(l, l, i.createAndFill());
			a.setSelection(ne.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
		}
		return !0;
	},
	Hl = (t, e) => {
		let n = t.selection,
			{ $from: r, $to: s } = n;
		if (n instanceof Ar || r.parent.inlineContent || s.parent.inlineContent) return !1;
		let o = eo(s.parent.contentMatchAt(s.indexAfter()));
		if (!o || !o.isTextblock) return !1;
		if (e) {
			let i = (!r.parentOffset && s.index() < s.parent.childCount ? r : s).pos,
				l = t.tr.insert(i, o.createAndFill());
			l.setSelection(V.create(l.doc, i + 1)), e(l.scrollIntoView());
		}
		return !0;
	},
	Vl = (t, e) => {
		let { $cursor: n } = t.selection;
		if (!n || n.parent.content.size) return !1;
		if (n.depth > 1 && n.after() != n.end(-1)) {
			let o = n.before();
			if (et(t.doc, o)) return e && e(t.tr.split(o).scrollIntoView()), !0;
		}
		let r = n.blockRange(),
			s = r && Xt(r);
		return s == null ? !1 : (e && e(t.tr.lift(r, s).scrollIntoView()), !0);
	};
function Vd(t) {
	return (e, n) => {
		let { $from: r, $to: s } = e.selection;
		if (e.selection instanceof _ && e.selection.node.isBlock)
			return !r.parentOffset || !et(e.doc, r.pos)
				? !1
				: (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
		if (!r.depth) return !1;
		let o = [],
			i,
			l,
			a = !1,
			c = !1;
		for (let p = r.depth; ; p--)
			if (r.node(p).isBlock) {
				(a = r.end(p) == r.pos + (r.depth - p)),
					(c = r.start(p) == r.pos - (r.depth - p)),
					(l = eo(r.node(p - 1).contentMatchAt(r.indexAfter(p - 1)))),
					o.unshift(a && l ? { type: l } : null),
					(i = p);
				break;
			} else {
				if (p == 1) return !1;
				o.unshift(null);
			}
		let u = e.tr;
		(e.selection instanceof V || e.selection instanceof Ar) && u.deleteSelection();
		let d = u.mapping.map(r.pos),
			f = et(u.doc, d, o.length, o);
		if ((f || ((o[0] = l ? { type: l } : null), (f = et(u.doc, d, o.length, o))), !f)) return !1;
		if ((u.split(d, o.length, o), !a && c && r.node(i).type != l)) {
			let p = u.mapping.map(r.before(i)),
				h = u.doc.resolve(p);
			l &&
				r.node(i - 1).canReplaceWith(h.index(), h.index() + 1, l) &&
				u.setNodeMarkup(u.mapping.map(r.before(i)), l);
		}
		return n && n(u.scrollIntoView()), !0;
	};
}
const Fd = Vd(),
	jd = (t, e) => {
		let { $from: n, to: r } = t.selection,
			s,
			o = n.sharedDepth(r);
		return o == 0 ? !1 : ((s = n.before(o)), e && e(t.tr.setSelection(_.create(t.doc, s))), !0);
	};
function Kd(t, e, n) {
	let r = e.nodeBefore,
		s = e.nodeAfter,
		o = e.index();
	return !r || !s || !r.type.compatibleContent(s.type)
		? !1
		: !r.content.size && e.parent.canReplace(o - 1, o)
			? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
			: !e.parent.canReplace(o, o + 1) || !(s.isTextblock || ht(t.doc, e.pos))
				? !1
				: (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function Fl(t, e, n, r) {
	let s = e.nodeBefore,
		o = e.nodeAfter,
		i,
		l,
		a = s.type.spec.isolating || o.type.spec.isolating;
	if (!a && Kd(t, e, n)) return !0;
	let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
	if (
		c &&
		(i = (l = s.contentMatchAt(s.childCount)).findWrapping(o.type)) &&
		l.matchType(i[0] || o.type).validEnd
	) {
		if (n) {
			let p = e.pos + o.nodeSize,
				h = L.empty;
			for (let b = i.length - 1; b >= 0; b--) h = L.from(i[b].create(null, h));
			h = L.from(s.copy(h));
			let g = t.tr.step(new At(e.pos - 1, p, e.pos, p, new oe(h, 1, 0), i.length, !0)),
				m = g.doc.resolve(p + 2 * i.length);
			m.nodeAfter && m.nodeAfter.type == s.type && ht(g.doc, m.pos) && g.join(m.pos),
				n(g.scrollIntoView());
		}
		return !0;
	}
	let u = o.type.spec.isolating || (r > 0 && a) ? null : ne.findFrom(e, 1),
		d = u && u.$from.blockRange(u.$to),
		f = d && Xt(d);
	if (f != null && f >= e.depth) return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
	if (c && Wt(o, 'start', !0) && Wt(s, 'end')) {
		let p = s,
			h = [];
		for (; h.push(p), !p.isTextblock; ) p = p.lastChild;
		let g = o,
			m = 1;
		for (; !g.isTextblock; g = g.firstChild) m++;
		if (p.canReplace(p.childCount, p.childCount, g.content)) {
			if (n) {
				let b = L.empty;
				for (let v = h.length - 1; v >= 0; v--) b = L.from(h[v].copy(b));
				let k = t.tr.step(
					new At(
						e.pos - h.length,
						e.pos + o.nodeSize,
						e.pos + m,
						e.pos + o.nodeSize - m,
						new oe(b, h.length, 0),
						0,
						!0
					)
				);
				n(k.scrollIntoView());
			}
			return !0;
		}
	}
	return !1;
}
function jl(t) {
	return function (e, n) {
		let r = e.selection,
			s = t < 0 ? r.$from : r.$to,
			o = s.depth;
		for (; s.node(o).isInline; ) {
			if (!o) return !1;
			o--;
		}
		return s.node(o).isTextblock
			? (n && n(e.tr.setSelection(V.create(e.doc, t < 0 ? s.start(o) : s.end(o)))), !0)
			: !1;
	};
}
const Wd = jl(-1),
	qd = jl(1);
function Ud(t, e = null) {
	return function (n, r) {
		let { $from: s, $to: o } = n.selection,
			i = s.blockRange(o),
			l = i && Bs(i, t, e);
		return l ? (r && r(n.tr.wrap(i, l).scrollIntoView()), !0) : !1;
	};
}
function ui(t, e = null) {
	return function (n, r) {
		let s = !1;
		for (let o = 0; o < n.selection.ranges.length && !s; o++) {
			let {
				$from: { pos: i },
				$to: { pos: l }
			} = n.selection.ranges[o];
			n.doc.nodesBetween(i, l, (a, c) => {
				if (s) return !1;
				if (!(!a.isTextblock || a.hasMarkup(t, e)))
					if (a.type == t) s = !0;
					else {
						let u = n.doc.resolve(c),
							d = u.index();
						s = u.parent.canReplaceWith(d, d + 1, t);
					}
			});
		}
		if (!s) return !1;
		if (r) {
			let o = n.tr;
			for (let i = 0; i < n.selection.ranges.length; i++) {
				let {
					$from: { pos: l },
					$to: { pos: a }
				} = n.selection.ranges[i];
				o.setBlockType(l, a, t, e);
			}
			r(o.scrollIntoView());
		}
		return !0;
	};
}
function to(...t) {
	return function (e, n, r) {
		for (let s = 0; s < t.length; s++) if (t[s](e, n, r)) return !0;
		return !1;
	};
}
to(Ys, _l, Ll);
to(Ys, Rl, Bl);
to(zl, Hl, Vl, Fd);
typeof navigator < 'u'
	? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
	: typeof os < 'u' && os.platform && os.platform() == 'darwin';
function Gd(t, e = null) {
	return function (n, r) {
		let { $from: s, $to: o } = n.selection,
			i = s.blockRange(o);
		if (!i) return !1;
		let l = r ? n.tr : null;
		return Qd(l, i, t, e) ? (r && r(l.scrollIntoView()), !0) : !1;
	};
}
function Qd(t, e, n, r = null) {
	let s = !1,
		o = e,
		i = e.$from.doc;
	if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
		if (e.$from.index(e.depth - 1) == 0) return !1;
		let a = i.resolve(e.start - 2);
		(o = new us(a, a, e.depth)),
			e.endIndex < e.parent.childCount &&
				(e = new us(e.$from, i.resolve(e.$to.end(e.depth)), e.depth)),
			(s = !0);
	}
	let l = Bs(o, n, r, e);
	return l ? (t && Jd(t, e, l, s, n), !0) : !1;
}
function Jd(t, e, n, r, s) {
	let o = L.empty;
	for (let u = n.length - 1; u >= 0; u--) o = L.from(n[u].type.create(n[u].attrs, o));
	t.step(new At(e.start - (r ? 2 : 0), e.end, e.start, e.end, new oe(o, 0, 0), n.length, !0));
	let i = 0;
	for (let u = 0; u < n.length; u++) n[u].type == s && (i = u + 1);
	let l = n.length - i,
		a = e.start + n.length - (r ? 2 : 0),
		c = e.parent;
	for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
		!f && et(t.doc, a, l) && (t.split(a, l), (a += 2 * l)), (a += c.child(u).nodeSize);
	return t;
}
function Yd(t) {
	return function (e, n) {
		let { $from: r, $to: s } = e.selection,
			o = r.blockRange(s, (i) => i.childCount > 0 && i.firstChild.type == t);
		return o ? (n ? (r.node(o.depth - 1).type == t ? Xd(e, n, t, o) : Zd(e, n, o)) : !0) : !1;
	};
}
function Xd(t, e, n, r) {
	let s = t.tr,
		o = r.end,
		i = r.$to.end(r.depth);
	o < i &&
		(s.step(new At(o - 1, i, o, i, new oe(L.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)),
		(r = new us(s.doc.resolve(r.$from.pos), s.doc.resolve(i), r.depth)));
	const l = Xt(r);
	if (l == null) return !1;
	s.lift(r, l);
	let a = s.doc.resolve(s.mapping.map(o, -1) - 1);
	return (
		ht(s.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && s.join(a.pos),
		e(s.scrollIntoView()),
		!0
	);
}
function Zd(t, e, n) {
	let r = t.tr,
		s = n.parent;
	for (let p = n.end, h = n.endIndex - 1, g = n.startIndex; h > g; h--)
		(p -= s.child(h).nodeSize), r.delete(p - 1, p + 1);
	let o = r.doc.resolve(n.start),
		i = o.nodeAfter;
	if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize) return !1;
	let l = n.startIndex == 0,
		a = n.endIndex == s.childCount,
		c = o.node(-1),
		u = o.index(-1);
	if (!c.canReplace(u + (l ? 0 : 1), u + 1, i.content.append(a ? L.empty : L.from(s)))) return !1;
	let d = o.pos,
		f = d + i.nodeSize;
	return (
		r.step(
			new At(
				d - (l ? 1 : 0),
				f + (a ? 1 : 0),
				d + 1,
				f - 1,
				new oe(
					(l ? L.empty : L.from(s.copy(L.empty))).append(a ? L.empty : L.from(s.copy(L.empty))),
					l ? 0 : 1,
					a ? 0 : 1
				),
				l ? 0 : 1
			)
		),
		e(r.scrollIntoView()),
		!0
	);
}
function ef(t) {
	return function (e, n) {
		let { $from: r, $to: s } = e.selection,
			o = r.blockRange(s, (c) => c.childCount > 0 && c.firstChild.type == t);
		if (!o) return !1;
		let i = o.startIndex;
		if (i == 0) return !1;
		let l = o.parent,
			a = l.child(i - 1);
		if (a.type != t) return !1;
		if (n) {
			let c = a.lastChild && a.lastChild.type == l.type,
				u = L.from(c ? t.create() : null),
				d = new oe(L.from(t.create(null, L.from(l.type.create(null, u)))), c ? 3 : 1, 0),
				f = o.start,
				p = o.end;
			n(e.tr.step(new At(f - (c ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView());
		}
		return !0;
	};
}
function vr(t) {
	const { state: e, transaction: n } = t;
	let { selection: r } = n,
		{ doc: s } = n,
		{ storedMarks: o } = n;
	return {
		...e,
		apply: e.apply.bind(e),
		applyTransaction: e.applyTransaction.bind(e),
		plugins: e.plugins,
		schema: e.schema,
		reconfigure: e.reconfigure.bind(e),
		toJSON: e.toJSON.bind(e),
		get storedMarks() {
			return o;
		},
		get selection() {
			return r;
		},
		get doc() {
			return s;
		},
		get tr() {
			return (r = n.selection), (s = n.doc), (o = n.storedMarks), n;
		}
	};
}
class _r {
	constructor(e) {
		(this.editor = e.editor),
			(this.rawCommands = this.editor.extensionManager.commands),
			(this.customState = e.state);
	}
	get hasCustomState() {
		return !!this.customState;
	}
	get state() {
		return this.customState || this.editor.state;
	}
	get commands() {
		const { rawCommands: e, editor: n, state: r } = this,
			{ view: s } = n,
			{ tr: o } = r,
			i = this.buildProps(o);
		return Object.fromEntries(
			Object.entries(e).map(([l, a]) => [
				l,
				(...u) => {
					const d = a(...u)(i);
					return !o.getMeta('preventDispatch') && !this.hasCustomState && s.dispatch(o), d;
				}
			])
		);
	}
	get chain() {
		return () => this.createChain();
	}
	get can() {
		return () => this.createCan();
	}
	createChain(e, n = !0) {
		const { rawCommands: r, editor: s, state: o } = this,
			{ view: i } = s,
			l = [],
			a = !!e,
			c = e || o.tr,
			u = () => (
				!a && n && !c.getMeta('preventDispatch') && !this.hasCustomState && i.dispatch(c),
				l.every((f) => f === !0)
			),
			d = {
				...Object.fromEntries(
					Object.entries(r).map(([f, p]) => [
						f,
						(...g) => {
							const m = this.buildProps(c, n),
								b = p(...g)(m);
							return l.push(b), d;
						}
					])
				),
				run: u
			};
		return d;
	}
	createCan(e) {
		const { rawCommands: n, state: r } = this,
			s = !1,
			o = e || r.tr,
			i = this.buildProps(o, s);
		return {
			...Object.fromEntries(
				Object.entries(n).map(([a, c]) => [a, (...u) => c(...u)({ ...i, dispatch: void 0 })])
			),
			chain: () => this.createChain(o, s)
		};
	}
	buildProps(e, n = !0) {
		const { rawCommands: r, editor: s, state: o } = this,
			{ view: i } = s,
			l = {
				tr: e,
				editor: s,
				view: i,
				state: vr({ state: o, transaction: e }),
				dispatch: n ? () => {} : void 0,
				chain: () => this.createChain(e, n),
				can: () => this.createCan(e),
				get commands() {
					return Object.fromEntries(Object.entries(r).map(([a, c]) => [a, (...u) => c(...u)(l)]));
				}
			};
		return l;
	}
}
class tf {
	constructor() {
		this.callbacks = {};
	}
	on(e, n) {
		return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
	}
	emit(e, ...n) {
		const r = this.callbacks[e];
		return r && r.forEach((s) => s.apply(this, n)), this;
	}
	off(e, n) {
		const r = this.callbacks[e];
		return (
			r && (n ? (this.callbacks[e] = r.filter((s) => s !== n)) : delete this.callbacks[e]), this
		);
	}
	once(e, n) {
		const r = (...s) => {
			this.off(e, r), n.apply(this, s);
		};
		return this.on(e, r);
	}
	removeAllListeners() {
		this.callbacks = {};
	}
}
function x(t, e, n) {
	return t.config[e] === void 0 && t.parent
		? x(t.parent, e, n)
		: typeof t.config[e] == 'function'
			? t.config[e].bind({ ...n, parent: t.parent ? x(t.parent, e, n) : null })
			: t.config[e];
}
function Ir(t) {
	const e = t.filter((s) => s.type === 'extension'),
		n = t.filter((s) => s.type === 'node'),
		r = t.filter((s) => s.type === 'mark');
	return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
}
function Kl(t) {
	const e = [],
		{ nodeExtensions: n, markExtensions: r } = Ir(t),
		s = [...n, ...r],
		o = {
			default: null,
			rendered: !0,
			renderHTML: null,
			parseHTML: null,
			keepOnSplit: !0,
			isRequired: !1
		};
	return (
		t.forEach((i) => {
			const l = { name: i.name, options: i.options, storage: i.storage, extensions: s },
				a = x(i, 'addGlobalAttributes', l);
			if (!a) return;
			a().forEach((u) => {
				u.types.forEach((d) => {
					Object.entries(u.attributes).forEach(([f, p]) => {
						e.push({ type: d, name: f, attribute: { ...o, ...p } });
					});
				});
			});
		}),
		s.forEach((i) => {
			const l = { name: i.name, options: i.options, storage: i.storage },
				a = x(i, 'addAttributes', l);
			if (!a) return;
			const c = a();
			Object.entries(c).forEach(([u, d]) => {
				const f = { ...o, ...d };
				typeof (f == null ? void 0 : f.default) == 'function' && (f.default = f.default()),
					f != null &&
						f.isRequired &&
						(f == null ? void 0 : f.default) === void 0 &&
						delete f.default,
					e.push({ type: i.name, name: u, attribute: f });
			});
		}),
		e
	);
}
function ce(t, e) {
	if (typeof t == 'string') {
		if (!e.nodes[t])
			throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
		return e.nodes[t];
	}
	return t;
}
function le(...t) {
	return t
		.filter((e) => !!e)
		.reduce((e, n) => {
			const r = { ...e };
			return (
				Object.entries(n).forEach(([s, o]) => {
					if (!r[s]) {
						r[s] = o;
						return;
					}
					if (s === 'class') {
						const l = o ? String(o).split(' ') : [],
							a = r[s] ? r[s].split(' ') : [],
							c = l.filter((u) => !a.includes(u));
						r[s] = [...a, ...c].join(' ');
					} else if (s === 'style') {
						const l = o
								? o
										.split(';')
										.map((u) => u.trim())
										.filter(Boolean)
								: [],
							a = r[s]
								? r[s]
										.split(';')
										.map((u) => u.trim())
										.filter(Boolean)
								: [],
							c = new Map();
						a.forEach((u) => {
							const [d, f] = u.split(':').map((p) => p.trim());
							c.set(d, f);
						}),
							l.forEach((u) => {
								const [d, f] = u.split(':').map((p) => p.trim());
								c.set(d, f);
							}),
							(r[s] = Array.from(c.entries())
								.map(([u, d]) => `${u}: ${d}`)
								.join('; '));
					} else r[s] = o;
				}),
				r
			);
		}, {});
}
function Ss(t, e) {
	return e
		.filter((n) => n.type === t.type.name)
		.filter((n) => n.attribute.rendered)
		.map((n) =>
			n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : { [n.name]: t.attrs[n.name] }
		)
		.reduce((n, r) => le(n, r), {});
}
function Wl(t) {
	return typeof t == 'function';
}
function B(t, e = void 0, ...n) {
	return Wl(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function nf(t = {}) {
	return Object.keys(t).length === 0 && t.constructor === Object;
}
function rf(t) {
	return typeof t != 'string'
		? t
		: t.match(/^[+-]?(?:\d*\.)?\d+$/)
			? Number(t)
			: t === 'true'
				? !0
				: t === 'false'
					? !1
					: t;
}
function di(t, e) {
	return 'style' in t
		? t
		: {
				...t,
				getAttrs: (n) => {
					const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
					if (r === !1) return !1;
					const s = e.reduce((o, i) => {
						const l = i.attribute.parseHTML ? i.attribute.parseHTML(n) : rf(n.getAttribute(i.name));
						return l == null ? o : { ...o, [i.name]: l };
					}, {});
					return { ...r, ...s };
				}
			};
}
function fi(t) {
	return Object.fromEntries(
		Object.entries(t).filter(([e, n]) => (e === 'attrs' && nf(n) ? !1 : n != null))
	);
}
function sf(t, e) {
	var n;
	const r = Kl(t),
		{ nodeExtensions: s, markExtensions: o } = Ir(t),
		i = (n = s.find((c) => x(c, 'topNode'))) === null || n === void 0 ? void 0 : n.name,
		l = Object.fromEntries(
			s.map((c) => {
				const u = r.filter((b) => b.type === c.name),
					d = { name: c.name, options: c.options, storage: c.storage, editor: e },
					f = t.reduce((b, k) => {
						const v = x(k, 'extendNodeSchema', d);
						return { ...b, ...(v ? v(c) : {}) };
					}, {}),
					p = fi({
						...f,
						content: B(x(c, 'content', d)),
						marks: B(x(c, 'marks', d)),
						group: B(x(c, 'group', d)),
						inline: B(x(c, 'inline', d)),
						atom: B(x(c, 'atom', d)),
						selectable: B(x(c, 'selectable', d)),
						draggable: B(x(c, 'draggable', d)),
						code: B(x(c, 'code', d)),
						whitespace: B(x(c, 'whitespace', d)),
						linebreakReplacement: B(x(c, 'linebreakReplacement', d)),
						defining: B(x(c, 'defining', d)),
						isolating: B(x(c, 'isolating', d)),
						attrs: Object.fromEntries(
							u.map((b) => {
								var k;
								return [
									b.name,
									{
										default:
											(k = b == null ? void 0 : b.attribute) === null || k === void 0
												? void 0
												: k.default
									}
								];
							})
						)
					}),
					h = B(x(c, 'parseHTML', d));
				h && (p.parseDOM = h.map((b) => di(b, u)));
				const g = x(c, 'renderHTML', d);
				g && (p.toDOM = (b) => g({ node: b, HTMLAttributes: Ss(b, u) }));
				const m = x(c, 'renderText', d);
				return m && (p.toText = m), [c.name, p];
			})
		),
		a = Object.fromEntries(
			o.map((c) => {
				const u = r.filter((m) => m.type === c.name),
					d = { name: c.name, options: c.options, storage: c.storage, editor: e },
					f = t.reduce((m, b) => {
						const k = x(b, 'extendMarkSchema', d);
						return { ...m, ...(k ? k(c) : {}) };
					}, {}),
					p = fi({
						...f,
						inclusive: B(x(c, 'inclusive', d)),
						excludes: B(x(c, 'excludes', d)),
						group: B(x(c, 'group', d)),
						spanning: B(x(c, 'spanning', d)),
						code: B(x(c, 'code', d)),
						attrs: Object.fromEntries(
							u.map((m) => {
								var b;
								return [
									m.name,
									{
										default:
											(b = m == null ? void 0 : m.attribute) === null || b === void 0
												? void 0
												: b.default
									}
								];
							})
						)
					}),
					h = B(x(c, 'parseHTML', d));
				h && (p.parseDOM = h.map((m) => di(m, u)));
				const g = x(c, 'renderHTML', d);
				return g && (p.toDOM = (m) => g({ mark: m, HTMLAttributes: Ss(m, u) })), [c.name, p];
			})
		);
	return new Hs({ topNode: i, nodes: l, marks: a });
}
function Ur(t, e) {
	return e.nodes[t] || e.marks[t] || null;
}
function pi(t, e) {
	return Array.isArray(e) ? e.some((n) => (typeof n == 'string' ? n : n.name) === t.name) : e;
}
function Tn(t, e) {
	const n = $n.fromSchema(e).serializeFragment(t),
		s = document.implementation.createHTMLDocument().createElement('div');
	return s.appendChild(n), s.innerHTML;
}
const of = (t, e = 500) => {
	let n = '';
	const r = t.parentOffset;
	return (
		t.parent.nodesBetween(Math.max(0, r - e), r, (s, o, i, l) => {
			var a, c;
			const u =
				((c = (a = s.type.spec).toText) === null || c === void 0
					? void 0
					: c.call(a, { node: s, pos: o, parent: i, index: l })) ||
				s.textContent ||
				'%leaf%';
			n += s.isAtom && !s.isText ? u : u.slice(0, Math.max(0, r - o));
		}),
		n
	);
};
function no(t) {
	return Object.prototype.toString.call(t) === '[object RegExp]';
}
class xn {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const lf = (t, e) => {
	if (no(e)) return e.exec(t);
	const n = e(t);
	if (!n) return null;
	const r = [n.text];
	return (
		(r.index = n.index),
		(r.input = t),
		(r.data = n.data),
		n.replaceWith &&
			(n.text.includes(n.replaceWith) ||
				console.warn(
					'[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
				),
			r.push(n.replaceWith)),
		r
	);
};
function An(t) {
	var e;
	const { editor: n, from: r, to: s, text: o, rules: i, plugin: l } = t,
		{ view: a } = n;
	if (a.composing) return !1;
	const c = a.state.doc.resolve(r);
	if (
		c.parent.type.spec.code ||
		(!((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) &&
			e.marks.find((f) => f.type.spec.code))
	)
		return !1;
	let u = !1;
	const d = of(c) + o;
	return (
		i.forEach((f) => {
			if (u) return;
			const p = lf(d, f.find);
			if (!p) return;
			const h = a.state.tr,
				g = vr({ state: a.state, transaction: h }),
				m = { from: r - (p[0].length - o.length), to: s },
				{ commands: b, chain: k, can: v } = new _r({ editor: n, state: g });
			f.handler({ state: g, range: m, match: p, commands: b, chain: k, can: v }) === null ||
				!h.steps.length ||
				(h.setMeta(l, { transform: h, from: r, to: s, text: o }), a.dispatch(h), (u = !0));
		}),
		u
	);
}
function af(t) {
	const { editor: e, rules: n } = t,
		r = new ie({
			state: {
				init() {
					return null;
				},
				apply(s, o, i) {
					const l = s.getMeta(r);
					if (l) return l;
					const a = s.getMeta('applyInputRules');
					return (
						!!a &&
							setTimeout(() => {
								let { text: u } = a;
								typeof u == 'string' ? (u = u) : (u = Tn(L.from(u), i.schema));
								const { from: d } = a,
									f = d + u.length;
								An({ editor: e, from: d, to: f, text: u, rules: n, plugin: r });
							}),
						s.selectionSet || s.docChanged ? null : o
					);
				}
			},
			props: {
				handleTextInput(s, o, i, l) {
					return An({ editor: e, from: o, to: i, text: l, rules: n, plugin: r });
				},
				handleDOMEvents: {
					compositionend: (s) => (
						setTimeout(() => {
							const { $cursor: o } = s.state.selection;
							o && An({ editor: e, from: o.pos, to: o.pos, text: '', rules: n, plugin: r });
						}),
						!1
					)
				},
				handleKeyDown(s, o) {
					if (o.key !== 'Enter') return !1;
					const { $cursor: i } = s.state.selection;
					return i
						? An({
								editor: e,
								from: i.pos,
								to: i.pos,
								text: `
`,
								rules: n,
								plugin: r
							})
						: !1;
				}
			},
			isInputRules: !0
		});
	return r;
}
function cf(t) {
	return Object.prototype.toString.call(t).slice(8, -1);
}
function En(t) {
	return cf(t) !== 'Object'
		? !1
		: t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Lr(t, e) {
	const n = { ...t };
	return (
		En(t) &&
			En(e) &&
			Object.keys(e).forEach((r) => {
				En(e[r]) && En(t[r]) ? (n[r] = Lr(t[r], e[r])) : (n[r] = e[r]);
			}),
		n
	);
}
class Me {
	constructor(e = {}) {
		(this.type = 'mark'),
			(this.name = 'mark'),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = { ...this.config, ...e }),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions && (this.options = B(x(this, 'addOptions', { name: this.name }))),
			(this.storage = B(x(this, 'addStorage', { name: this.name, options: this.options })) || {});
	}
	static create(e = {}) {
		return new Me(e);
	}
	configure(e = {}) {
		const n = this.extend({ ...this.config, addOptions: () => Lr(this.options, e) });
		return (n.name = this.name), (n.parent = this.parent), n;
	}
	extend(e = {}) {
		const n = new Me(e);
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = B(x(n, 'addOptions', { name: n.name }))),
			(n.storage = B(x(n, 'addStorage', { name: n.name, options: n.options }))),
			n
		);
	}
	static handleExit({ editor: e, mark: n }) {
		const { tr: r } = e.state,
			s = e.state.selection.$from;
		if (s.pos === s.end()) {
			const i = s.marks();
			if (!!!i.find((c) => (c == null ? void 0 : c.type.name) === n.name)) return !1;
			const a = i.find((c) => (c == null ? void 0 : c.type.name) === n.name);
			return a && r.removeStoredMark(a), r.insertText(' ', s.pos), e.view.dispatch(r), !0;
		}
		return !1;
	}
}
function uf(t) {
	return typeof t == 'number';
}
class df {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const ff = (t, e, n) => {
	if (no(e)) return [...t.matchAll(e)];
	const r = e(t, n);
	return r
		? r.map((s) => {
				const o = [s.text];
				return (
					(o.index = s.index),
					(o.input = t),
					(o.data = s.data),
					s.replaceWith &&
						(s.text.includes(s.replaceWith) ||
							console.warn(
								'[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
							),
						o.push(s.replaceWith)),
					o
				);
			})
		: [];
};
function pf(t) {
	const { editor: e, state: n, from: r, to: s, rule: o, pasteEvent: i, dropEvent: l } = t,
		{ commands: a, chain: c, can: u } = new _r({ editor: e, state: n }),
		d = [];
	return (
		n.doc.nodesBetween(r, s, (p, h) => {
			if (!p.isTextblock || p.type.spec.code) return;
			const g = Math.max(r, h),
				m = Math.min(s, h + p.content.size),
				b = p.textBetween(g - h, m - h, void 0, '￼');
			ff(b, o.find, i).forEach((v) => {
				if (v.index === void 0) return;
				const I = g + v.index + 1,
					T = I + v[0].length,
					y = { from: n.tr.mapping.map(I), to: n.tr.mapping.map(T) },
					D = o.handler({
						state: n,
						range: y,
						match: v,
						commands: a,
						chain: c,
						can: u,
						pasteEvent: i,
						dropEvent: l
					});
				d.push(D);
			});
		}),
		d.every((p) => p !== null)
	);
}
let On = null;
const hf = (t) => {
	var e;
	const n = new ClipboardEvent('paste', { clipboardData: new DataTransfer() });
	return (e = n.clipboardData) === null || e === void 0 || e.setData('text/html', t), n;
};
function mf(t) {
	const { editor: e, rules: n } = t;
	let r = null,
		s = !1,
		o = !1,
		i = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null,
		l;
	try {
		l = typeof DragEvent < 'u' ? new DragEvent('drop') : null;
	} catch {
		l = null;
	}
	const a = ({ state: u, from: d, to: f, rule: p, pasteEvt: h }) => {
		const g = u.tr,
			m = vr({ state: u, transaction: g });
		if (
			!(
				!pf({
					editor: e,
					state: m,
					from: Math.max(d - 1, 0),
					to: f.b - 1,
					rule: p,
					pasteEvent: h,
					dropEvent: l
				}) || !g.steps.length
			)
		) {
			try {
				l = typeof DragEvent < 'u' ? new DragEvent('drop') : null;
			} catch {
				l = null;
			}
			return (i = typeof ClipboardEvent < 'u' ? new ClipboardEvent('paste') : null), g;
		}
	};
	return n.map(
		(u) =>
			new ie({
				view(d) {
					const f = (h) => {
							var g;
							(r =
								!((g = d.dom.parentElement) === null || g === void 0) && g.contains(h.target)
									? d.dom.parentElement
									: null),
								r && (On = e);
						},
						p = () => {
							On && (On = null);
						};
					return (
						window.addEventListener('dragstart', f),
						window.addEventListener('dragend', p),
						{
							destroy() {
								window.removeEventListener('dragstart', f),
									window.removeEventListener('dragend', p);
							}
						}
					);
				},
				props: {
					handleDOMEvents: {
						drop: (d, f) => {
							if (((o = r === d.dom.parentElement), (l = f), !o)) {
								const p = On;
								p &&
									setTimeout(() => {
										const h = p.state.selection;
										h && p.commands.deleteRange({ from: h.from, to: h.to });
									}, 10);
							}
							return !1;
						},
						paste: (d, f) => {
							var p;
							const h =
								(p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData('text/html');
							return (i = f), (s = !!(h != null && h.includes('data-pm-slice'))), !1;
						}
					}
				},
				appendTransaction: (d, f, p) => {
					const h = d[0],
						g = h.getMeta('uiEvent') === 'paste' && !s,
						m = h.getMeta('uiEvent') === 'drop' && !o,
						b = h.getMeta('applyPasteRules'),
						k = !!b;
					if (!g && !m && !k) return;
					if (k) {
						let { text: T } = b;
						typeof T == 'string' ? (T = T) : (T = Tn(L.from(T), p.schema));
						const { from: y } = b,
							D = y + T.length,
							C = hf(T);
						return a({ rule: u, state: p, from: y, to: { b: D }, pasteEvt: C });
					}
					const v = f.doc.content.findDiffStart(p.doc.content),
						I = f.doc.content.findDiffEnd(p.doc.content);
					if (!(!uf(v) || !I || v === I.b))
						return a({ rule: u, state: p, from: v, to: I, pasteEvt: i });
				}
			})
	);
}
function gf(t) {
	const e = t.filter((n, r) => t.indexOf(n) !== r);
	return Array.from(new Set(e));
}
class Pt {
	constructor(e, n) {
		(this.splittableMarks = []),
			(this.editor = n),
			(this.extensions = Pt.resolve(e)),
			(this.schema = sf(this.extensions, n)),
			this.setupExtensions();
	}
	static resolve(e) {
		const n = Pt.sort(Pt.flatten(e)),
			r = gf(n.map((s) => s.name));
		return (
			r.length &&
				console.warn(
					`[tiptap warn]: Duplicate extension names found: [${r.map((s) => `'${s}'`).join(', ')}]. This can lead to issues.`
				),
			n
		);
	}
	static flatten(e) {
		return e
			.map((n) => {
				const r = { name: n.name, options: n.options, storage: n.storage },
					s = x(n, 'addExtensions', r);
				return s ? [n, ...this.flatten(s())] : n;
			})
			.flat(10);
	}
	static sort(e) {
		return e.sort((r, s) => {
			const o = x(r, 'priority') || 100,
				i = x(s, 'priority') || 100;
			return o > i ? -1 : o < i ? 1 : 0;
		});
	}
	get commands() {
		return this.extensions.reduce((e, n) => {
			const r = {
					name: n.name,
					options: n.options,
					storage: n.storage,
					editor: this.editor,
					type: Ur(n.name, this.schema)
				},
				s = x(n, 'addCommands', r);
			return s ? { ...e, ...s() } : e;
		}, {});
	}
	get plugins() {
		const { editor: e } = this,
			n = Pt.sort([...this.extensions].reverse()),
			r = [],
			s = [],
			o = n
				.map((i) => {
					const l = {
							name: i.name,
							options: i.options,
							storage: i.storage,
							editor: e,
							type: Ur(i.name, this.schema)
						},
						a = [],
						c = x(i, 'addKeyboardShortcuts', l);
					let u = {};
					if (
						(i.type === 'mark' &&
							x(i, 'exitable', l) &&
							(u.ArrowRight = () => Me.handleExit({ editor: e, mark: i })),
						c)
					) {
						const g = Object.fromEntries(
							Object.entries(c()).map(([m, b]) => [m, () => b({ editor: e })])
						);
						u = { ...u, ...g };
					}
					const d = Id(u);
					a.push(d);
					const f = x(i, 'addInputRules', l);
					pi(i, e.options.enableInputRules) && f && r.push(...f());
					const p = x(i, 'addPasteRules', l);
					pi(i, e.options.enablePasteRules) && p && s.push(...p());
					const h = x(i, 'addProseMirrorPlugins', l);
					if (h) {
						const g = h();
						a.push(...g);
					}
					return a;
				})
				.flat();
		return [af({ editor: e, rules: r }), ...mf({ editor: e, rules: s }), ...o];
	}
	get attributes() {
		return Kl(this.extensions);
	}
	get nodeViews() {
		const { editor: e } = this,
			{ nodeExtensions: n } = Ir(this.extensions);
		return Object.fromEntries(
			n
				.filter((r) => !!x(r, 'addNodeView'))
				.map((r) => {
					const s = this.attributes.filter((a) => a.type === r.name),
						o = {
							name: r.name,
							options: r.options,
							storage: r.storage,
							editor: e,
							type: ce(r.name, this.schema)
						},
						i = x(r, 'addNodeView', o);
					if (!i) return [];
					const l = (a, c, u, d, f) => {
						const p = Ss(a, s);
						return i()({
							node: a,
							view: c,
							getPos: u,
							decorations: d,
							innerDecorations: f,
							editor: e,
							extension: r,
							HTMLAttributes: p
						});
					};
					return [r.name, l];
				})
		);
	}
	setupExtensions() {
		this.extensions.forEach((e) => {
			var n;
			this.editor.extensionStorage[e.name] = e.storage;
			const r = {
				name: e.name,
				options: e.options,
				storage: e.storage,
				editor: this.editor,
				type: Ur(e.name, this.schema)
			};
			e.type === 'mark' &&
				(!((n = B(x(e, 'keepOnSplit', r))) !== null && n !== void 0) || n) &&
				this.splittableMarks.push(e.name);
			const s = x(e, 'onBeforeCreate', r),
				o = x(e, 'onCreate', r),
				i = x(e, 'onUpdate', r),
				l = x(e, 'onSelectionUpdate', r),
				a = x(e, 'onTransaction', r),
				c = x(e, 'onFocus', r),
				u = x(e, 'onBlur', r),
				d = x(e, 'onDestroy', r);
			s && this.editor.on('beforeCreate', s),
				o && this.editor.on('create', o),
				i && this.editor.on('update', i),
				l && this.editor.on('selectionUpdate', l),
				a && this.editor.on('transaction', a),
				c && this.editor.on('focus', c),
				u && this.editor.on('blur', u),
				d && this.editor.on('destroy', d);
		});
	}
}
class re {
	constructor(e = {}) {
		(this.type = 'extension'),
			(this.name = 'extension'),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = { ...this.config, ...e }),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions && (this.options = B(x(this, 'addOptions', { name: this.name }))),
			(this.storage = B(x(this, 'addStorage', { name: this.name, options: this.options })) || {});
	}
	static create(e = {}) {
		return new re(e);
	}
	configure(e = {}) {
		const n = this.extend({ ...this.config, addOptions: () => Lr(this.options, e) });
		return (n.name = this.name), (n.parent = this.parent), n;
	}
	extend(e = {}) {
		const n = new re({ ...this.config, ...e });
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = B(x(n, 'addOptions', { name: n.name }))),
			(n.storage = B(x(n, 'addStorage', { name: n.name, options: n.options }))),
			n
		);
	}
}
function ql(t, e, n) {
	const { from: r, to: s } = e,
		{
			blockSeparator: o = `

`,
			textSerializers: i = {}
		} = n || {};
	let l = '';
	return (
		t.nodesBetween(r, s, (a, c, u, d) => {
			var f;
			a.isBlock && c > r && (l += o);
			const p = i == null ? void 0 : i[a.type.name];
			if (p) return u && (l += p({ node: a, pos: c, parent: u, index: d, range: e })), !1;
			a.isText &&
				(l +=
					(f = a == null ? void 0 : a.text) === null || f === void 0
						? void 0
						: f.slice(Math.max(r, c) - c, s - c));
		}),
		l
	);
}
function Ul(t) {
	return Object.fromEntries(
		Object.entries(t.nodes)
			.filter(([, e]) => e.spec.toText)
			.map(([e, n]) => [e, n.spec.toText])
	);
}
const Gl = re.create({
		name: 'clipboardTextSerializer',
		addOptions() {
			return { blockSeparator: void 0 };
		},
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('clipboardTextSerializer'),
					props: {
						clipboardTextSerializer: () => {
							const { editor: t } = this,
								{ state: e, schema: n } = t,
								{ doc: r, selection: s } = e,
								{ ranges: o } = s,
								i = Math.min(...o.map((u) => u.$from.pos)),
								l = Math.max(...o.map((u) => u.$to.pos)),
								a = Ul(n);
							return ql(
								r,
								{ from: i, to: l },
								{
									...(this.options.blockSeparator !== void 0
										? { blockSeparator: this.options.blockSeparator }
										: {}),
									textSerializers: a
								}
							);
						}
					}
				})
			];
		}
	}),
	bf =
		() =>
		({ editor: t, view: e }) => (
			requestAnimationFrame(() => {
				var n;
				t.isDestroyed ||
					(e.dom.blur(),
					(n = window == null ? void 0 : window.getSelection()) === null ||
						n === void 0 ||
						n.removeAllRanges());
			}),
			!0
		),
	kf =
		(t = !1) =>
		({ commands: e }) =>
			e.setContent('', t),
	yf =
		() =>
		({ state: t, tr: e, dispatch: n }) => {
			const { selection: r } = e,
				{ ranges: s } = r;
			return (
				n &&
					s.forEach(({ $from: o, $to: i }) => {
						t.doc.nodesBetween(o.pos, i.pos, (l, a) => {
							if (l.type.isText) return;
							const { doc: c, mapping: u } = e,
								d = c.resolve(u.map(a)),
								f = c.resolve(u.map(a + l.nodeSize)),
								p = d.blockRange(f);
							if (!p) return;
							const h = Xt(p);
							if (l.type.isTextblock) {
								const { defaultType: g } = d.parent.contentMatchAt(d.index());
								e.setNodeMarkup(p.start, g);
							}
							(h || h === 0) && e.lift(p, h);
						});
					}),
				!0
			);
		},
	$f = (t) => (e) => t(e),
	Sf =
		() =>
		({ state: t, dispatch: e }) =>
			Hl(t, e),
	Mf =
		(t, e) =>
		({ editor: n, tr: r }) => {
			const { state: s } = n,
				o = s.doc.slice(t.from, t.to);
			r.deleteRange(t.from, t.to);
			const i = r.mapping.map(e);
			return r.insert(i, o.content), r.setSelection(new V(r.doc.resolve(i - 1))), !0;
		},
	Cf =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				r = n.$anchor.node();
			if (r.content.size > 0) return !1;
			const s = t.selection.$anchor;
			for (let o = s.depth; o > 0; o -= 1)
				if (s.node(o).type === r.type) {
					if (e) {
						const l = s.before(o),
							a = s.after(o);
						t.delete(l, a).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	Tf =
		(t) =>
		({ tr: e, state: n, dispatch: r }) => {
			const s = ce(t, n.schema),
				o = e.selection.$anchor;
			for (let i = o.depth; i > 0; i -= 1)
				if (o.node(i).type === s) {
					if (r) {
						const a = o.before(i),
							c = o.after(i);
						e.delete(a, c).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	xf =
		(t) =>
		({ tr: e, dispatch: n }) => {
			const { from: r, to: s } = t;
			return n && e.delete(r, s), !0;
		},
	wf =
		() =>
		({ state: t, dispatch: e }) =>
			Ys(t, e),
	Af =
		() =>
		({ commands: t }) =>
			t.keyboardShortcut('Enter'),
	Ef =
		() =>
		({ state: t, dispatch: e }) =>
			Hd(t, e);
function Qn(t, e, n = { strict: !0 }) {
	const r = Object.keys(e);
	return r.length
		? r.every((s) => (n.strict ? e[s] === t[s] : no(e[s]) ? e[s].test(t[s]) : e[s] === t[s]))
		: !0;
}
function Ql(t, e, n = {}) {
	return t.find(
		(r) => r.type === e && Qn(Object.fromEntries(Object.keys(n).map((s) => [s, r.attrs[s]])), n)
	);
}
function hi(t, e, n = {}) {
	return !!Ql(t, e, n);
}
function ro(t, e, n) {
	var r;
	if (!t || !e) return;
	let s = t.parent.childAfter(t.parentOffset);
	if (
		((!s.node || !s.node.marks.some((u) => u.type === e)) &&
			(s = t.parent.childBefore(t.parentOffset)),
		!s.node ||
			!s.node.marks.some((u) => u.type === e) ||
			((n = n || ((r = s.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs)),
			!Ql([...s.node.marks], e, n)))
	)
		return;
	let i = s.index,
		l = t.start() + s.offset,
		a = i + 1,
		c = l + s.node.nodeSize;
	for (; i > 0 && hi([...t.parent.child(i - 1).marks], e, n); )
		(i -= 1), (l -= t.parent.child(i).nodeSize);
	for (; a < t.parent.childCount && hi([...t.parent.child(a).marks], e, n); )
		(c += t.parent.child(a).nodeSize), (a += 1);
	return { from: l, to: c };
}
function gt(t, e) {
	if (typeof t == 'string') {
		if (!e.marks[t])
			throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
		return e.marks[t];
	}
	return t;
}
const Of =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: s }) => {
			const o = gt(t, r.schema),
				{ doc: i, selection: l } = n,
				{ $from: a, from: c, to: u } = l;
			if (s) {
				const d = ro(a, o, e);
				if (d && d.from <= c && d.to >= u) {
					const f = V.create(i, d.from, d.to);
					n.setSelection(f);
				}
			}
			return !0;
		},
	Nf = (t) => (e) => {
		const n = typeof t == 'function' ? t(e) : t;
		for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
		return !1;
	};
function Jl(t) {
	return t instanceof V;
}
function Mt(t = 0, e = 0, n = 0) {
	return Math.min(Math.max(t, e), n);
}
function Yl(t, e = null) {
	if (!e) return null;
	const n = ne.atStart(t),
		r = ne.atEnd(t);
	if (e === 'start' || e === !0) return n;
	if (e === 'end') return r;
	const s = n.from,
		o = r.to;
	return e === 'all'
		? V.create(t, Mt(0, s, o), Mt(t.content.size, s, o))
		: V.create(t, Mt(e, s, o), Mt(e, s, o));
}
function Df() {
	return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);
}
function so() {
	return (
		['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(
			navigator.platform
		) ||
		(navigator.userAgent.includes('Mac') && 'ontouchend' in document)
	);
}
const vf =
		(t = null, e = {}) =>
		({ editor: n, view: r, tr: s, dispatch: o }) => {
			e = { scrollIntoView: !0, ...e };
			const i = () => {
				(so() || Df()) && r.dom.focus(),
					requestAnimationFrame(() => {
						n.isDestroyed ||
							(r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
					});
			};
			if ((r.hasFocus() && t === null) || t === !1) return !0;
			if (o && t === null && !Jl(n.state.selection)) return i(), !0;
			const l = Yl(s.doc, t) || n.state.selection,
				a = n.state.selection.eq(l);
			return (
				o && (a || s.setSelection(l), a && s.storedMarks && s.setStoredMarks(s.storedMarks), i()),
				!0
			);
		},
	_f = (t, e) => (n) => t.every((r, s) => e(r, { ...n, index: s })),
	If =
		(t, e) =>
		({ tr: n, commands: r }) =>
			r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e),
	Xl = (t) => {
		const e = t.childNodes;
		for (let n = e.length - 1; n >= 0; n -= 1) {
			const r = e[n];
			r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
				? t.removeChild(r)
				: r.nodeType === 1 && Xl(r);
		}
		return t;
	};
function Nn(t) {
	const e = `<body>${t}</body>`,
		n = new window.DOMParser().parseFromString(e, 'text/html').body;
	return Xl(n);
}
function gn(t, e, n) {
	if (t instanceof ja || t instanceof L) return t;
	n = { slice: !0, parseOptions: {}, ...n };
	const r = typeof t == 'object' && t !== null,
		s = typeof t == 'string';
	if (r)
		try {
			if (Array.isArray(t) && t.length > 0) return L.fromArray(t.map((l) => e.nodeFromJSON(l)));
			const i = e.nodeFromJSON(t);
			return n.errorOnInvalidContent && i.check(), i;
		} catch (o) {
			if (n.errorOnInvalidContent)
				throw new Error('[tiptap error]: Invalid JSON content', { cause: o });
			return (
				console.warn('[tiptap warn]: Invalid content.', 'Passed value:', t, 'Error:', o),
				gn('', e, n)
			);
		}
	if (s) {
		if (n.errorOnInvalidContent) {
			let i = !1,
				l = '';
			const a = new Hs({
				topNode: e.spec.topNode,
				marks: e.spec.marks,
				nodes: e.spec.nodes.append({
					__tiptap__private__unknown__catch__all__node: {
						content: 'inline*',
						group: 'block',
						parseDOM: [
							{
								tag: '*',
								getAttrs: (c) => ((i = !0), (l = typeof c == 'string' ? c : c.outerHTML), null)
							}
						]
					}
				})
			});
			if (
				(n.slice
					? zt.fromSchema(a).parseSlice(Nn(t), n.parseOptions)
					: zt.fromSchema(a).parse(Nn(t), n.parseOptions),
				n.errorOnInvalidContent && i)
			)
				throw new Error('[tiptap error]: Invalid HTML content', {
					cause: new Error(`Invalid element found: ${l}`)
				});
		}
		const o = zt.fromSchema(e);
		return n.slice ? o.parseSlice(Nn(t), n.parseOptions).content : o.parse(Nn(t), n.parseOptions);
	}
	return gn('', e, n);
}
function Lf(t, e, n) {
	const r = t.steps.length - 1;
	if (r < e) return;
	const s = t.steps[r];
	if (!(s instanceof qi || s instanceof At)) return;
	const o = t.mapping.maps[r];
	let i = 0;
	o.forEach((l, a, c, u) => {
		i === 0 && (i = u);
	}),
		t.setSelection(ne.near(t.doc.resolve(i), n));
}
const Pf = (t) => !('type' in t),
	Rf =
		(t, e, n) =>
		({ tr: r, dispatch: s, editor: o }) => {
			var i;
			if (s) {
				n = {
					parseOptions: o.options.parseOptions,
					updateSelection: !0,
					applyInputRules: !1,
					applyPasteRules: !1,
					...n
				};
				let l;
				const a = (m) => {
						o.emit('contentError', {
							editor: o,
							error: m,
							disableCollaboration: () => {
								o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
							}
						});
					},
					c = { preserveWhitespace: 'full', ...n.parseOptions };
				if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
					try {
						gn(e, o.schema, { parseOptions: c, errorOnInvalidContent: !0 });
					} catch (m) {
						a(m);
					}
				try {
					l = gn(e, o.schema, {
						parseOptions: c,
						errorOnInvalidContent:
							(i = n.errorOnInvalidContent) !== null && i !== void 0
								? i
								: o.options.enableContentCheck
					});
				} catch (m) {
					return a(m), !1;
				}
				let { from: u, to: d } =
						typeof t == 'number' ? { from: t, to: t } : { from: t.from, to: t.to },
					f = !0,
					p = !0;
				if (
					((Pf(l) ? l : [l]).forEach((m) => {
						m.check(), (f = f ? m.isText && m.marks.length === 0 : !1), (p = p ? m.isBlock : !1);
					}),
					u === d && p)
				) {
					const { parent: m } = r.doc.resolve(u);
					m.isTextblock && !m.type.spec.code && !m.childCount && ((u -= 1), (d += 1));
				}
				let g;
				if (f) {
					if (Array.isArray(e)) g = e.map((m) => m.text || '').join('');
					else if (e instanceof L) {
						let m = '';
						e.forEach((b) => {
							b.text && (m += b.text);
						}),
							(g = m);
					} else typeof e == 'object' && e && e.text ? (g = e.text) : (g = e);
					r.insertText(g, u, d);
				} else (g = l), r.replaceWith(u, d, g);
				n.updateSelection && Lf(r, r.steps.length - 1, -1),
					n.applyInputRules && r.setMeta('applyInputRules', { from: u, text: g }),
					n.applyPasteRules && r.setMeta('applyPasteRules', { from: u, text: g });
			}
			return !0;
		},
	Bf =
		() =>
		({ state: t, dispatch: e }) =>
			Rd(t, e),
	zf =
		() =>
		({ state: t, dispatch: e }) =>
			Bd(t, e),
	Hf =
		() =>
		({ state: t, dispatch: e }) =>
			_l(t, e),
	Vf =
		() =>
		({ state: t, dispatch: e }) =>
			Rl(t, e),
	Ff =
		() =>
		({ state: t, dispatch: e, tr: n }) => {
			try {
				const r = Er(t.doc, t.selection.$from.pos, -1);
				return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
			} catch {
				return !1;
			}
		},
	jf =
		() =>
		({ state: t, dispatch: e, tr: n }) => {
			try {
				const r = Er(t.doc, t.selection.$from.pos, 1);
				return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
			} catch {
				return !1;
			}
		},
	Kf =
		() =>
		({ state: t, dispatch: e }) =>
			Ld(t, e),
	Wf =
		() =>
		({ state: t, dispatch: e }) =>
			Pd(t, e);
function Zl() {
	return typeof navigator < 'u' ? /Mac/.test(navigator.platform) : !1;
}
function qf(t) {
	const e = t.split(/-(?!$)/);
	let n = e[e.length - 1];
	n === 'Space' && (n = ' ');
	let r, s, o, i;
	for (let l = 0; l < e.length - 1; l += 1) {
		const a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) i = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) s = !0;
		else if (/^s(hift)?$/i.test(a)) o = !0;
		else if (/^mod$/i.test(a)) so() || Zl() ? (i = !0) : (s = !0);
		else throw new Error(`Unrecognized modifier name: ${a}`);
	}
	return (
		r && (n = `Alt-${n}`),
		s && (n = `Ctrl-${n}`),
		i && (n = `Meta-${n}`),
		o && (n = `Shift-${n}`),
		n
	);
}
const Uf =
	(t) =>
	({ editor: e, view: n, tr: r, dispatch: s }) => {
		const o = qf(t).split(/-(?!$)/),
			i = o.find((c) => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(c)),
			l = new KeyboardEvent('keydown', {
				key: i === 'Space' ? ' ' : i,
				altKey: o.includes('Alt'),
				ctrlKey: o.includes('Ctrl'),
				metaKey: o.includes('Meta'),
				shiftKey: o.includes('Shift'),
				bubbles: !0,
				cancelable: !0
			}),
			a = e.captureTransaction(() => {
				n.someProp('handleKeyDown', (c) => c(n, l));
			});
		return (
			a == null ||
				a.steps.forEach((c) => {
					const u = c.map(r.mapping);
					u && s && r.maybeStep(u);
				}),
			!0
		);
	};
function bn(t, e, n = {}) {
	const { from: r, to: s, empty: o } = t.selection,
		i = e ? ce(e, t.schema) : null,
		l = [];
	t.doc.nodesBetween(r, s, (d, f) => {
		if (d.isText) return;
		const p = Math.max(r, f),
			h = Math.min(s, f + d.nodeSize);
		l.push({ node: d, from: p, to: h });
	});
	const a = s - r,
		c = l
			.filter((d) => (i ? i.name === d.node.type.name : !0))
			.filter((d) => Qn(d.node.attrs, n, { strict: !1 }));
	return o ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= a;
}
const Gf =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const s = ce(t, n.schema);
			return bn(n, s, e) ? zd(n, r) : !1;
		},
	Qf =
		() =>
		({ state: t, dispatch: e }) =>
			Vl(t, e),
	Jf =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = ce(t, e.schema);
			return Yd(r)(e, n);
		},
	Yf =
		() =>
		({ state: t, dispatch: e }) =>
			zl(t, e);
function Pr(t, e) {
	return e.nodes[t] ? 'node' : e.marks[t] ? 'mark' : null;
}
function mi(t, e) {
	const n = typeof e == 'string' ? [e] : e;
	return Object.keys(t).reduce((r, s) => (n.includes(s) || (r[s] = t[s]), r), {});
}
const Xf =
		(t, e) =>
		({ tr: n, state: r, dispatch: s }) => {
			let o = null,
				i = null;
			const l = Pr(typeof t == 'string' ? t : t.name, r.schema);
			return l
				? (l === 'node' && (o = ce(t, r.schema)),
					l === 'mark' && (i = gt(t, r.schema)),
					s &&
						n.selection.ranges.forEach((a) => {
							r.doc.nodesBetween(a.$from.pos, a.$to.pos, (c, u) => {
								o && o === c.type && n.setNodeMarkup(u, void 0, mi(c.attrs, e)),
									i &&
										c.marks.length &&
										c.marks.forEach((d) => {
											i === d.type && n.addMark(u, u + c.nodeSize, i.create(mi(d.attrs, e)));
										});
							});
						}),
					!0)
				: !1;
		},
	Zf =
		() =>
		({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
	ep =
		() =>
		({ tr: t, dispatch: e }) => {
			if (e) {
				const n = new Ar(t.doc);
				t.setSelection(n);
			}
			return !0;
		},
	tp =
		() =>
		({ state: t, dispatch: e }) =>
			Ll(t, e),
	np =
		() =>
		({ state: t, dispatch: e }) =>
			Bl(t, e),
	rp =
		() =>
		({ state: t, dispatch: e }) =>
			jd(t, e),
	sp =
		() =>
		({ state: t, dispatch: e }) =>
			qd(t, e),
	op =
		() =>
		({ state: t, dispatch: e }) =>
			Wd(t, e);
function Ms(t, e, n = {}, r = {}) {
	return gn(t, e, { slice: !1, parseOptions: n, errorOnInvalidContent: r.errorOnInvalidContent });
}
const ip =
	(t, e = !1, n = {}, r = {}) =>
	({ editor: s, tr: o, dispatch: i, commands: l }) => {
		var a, c;
		const { doc: u } = o;
		if (n.preserveWhitespace !== 'full') {
			const d = Ms(t, s.schema, n, {
				errorOnInvalidContent:
					(a = r.errorOnInvalidContent) !== null && a !== void 0 ? a : s.options.enableContentCheck
			});
			return i && o.replaceWith(0, u.content.size, d).setMeta('preventUpdate', !e), !0;
		}
		return (
			i && o.setMeta('preventUpdate', !e),
			l.insertContentAt({ from: 0, to: u.content.size }, t, {
				parseOptions: n,
				errorOnInvalidContent:
					(c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : s.options.enableContentCheck
			})
		);
	};
function ea(t, e) {
	const n = gt(e, t.schema),
		{ from: r, to: s, empty: o } = t.selection,
		i = [];
	o
		? (t.storedMarks && i.push(...t.storedMarks), i.push(...t.selection.$head.marks()))
		: t.doc.nodesBetween(r, s, (a) => {
				i.push(...a.marks);
			});
	const l = i.find((a) => a.type.name === n.name);
	return l ? { ...l.attrs } : {};
}
function lp(t, e) {
	const n = new Va(t);
	return (
		e.forEach((r) => {
			r.steps.forEach((s) => {
				n.step(s);
			});
		}),
		n
	);
}
function ap(t) {
	for (let e = 0; e < t.edgeCount; e += 1) {
		const { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
function cp(t, e, n) {
	const r = [];
	return (
		t.nodesBetween(e.from, e.to, (s, o) => {
			n(s) && r.push({ node: s, pos: o });
		}),
		r
	);
}
function up(t, e) {
	for (let n = t.depth; n > 0; n -= 1) {
		const r = t.node(n);
		if (e(r)) return { pos: n > 0 ? t.before(n) : 0, start: t.start(n), depth: n, node: r };
	}
}
function oo(t) {
	return (e) => up(e.$from, t);
}
function dp(t, e) {
	const n = { from: 0, to: t.content.size };
	return ql(t, n, e);
}
function fp(t, e) {
	const n = ce(e, t.schema),
		{ from: r, to: s } = t.selection,
		o = [];
	t.doc.nodesBetween(r, s, (l) => {
		o.push(l);
	});
	const i = o.reverse().find((l) => l.type.name === n.name);
	return i ? { ...i.attrs } : {};
}
function ta(t, e) {
	const n = Pr(typeof e == 'string' ? e : e.name, t.schema);
	return n === 'node' ? fp(t, e) : n === 'mark' ? ea(t, e) : {};
}
function pp(t, e = JSON.stringify) {
	const n = {};
	return t.filter((r) => {
		const s = e(r);
		return Object.prototype.hasOwnProperty.call(n, s) ? !1 : (n[s] = !0);
	});
}
function hp(t) {
	const e = pp(t);
	return e.length === 1
		? e
		: e.filter(
				(n, r) =>
					!e
						.filter((o, i) => i !== r)
						.some(
							(o) =>
								n.oldRange.from >= o.oldRange.from &&
								n.oldRange.to <= o.oldRange.to &&
								n.newRange.from >= o.newRange.from &&
								n.newRange.to <= o.newRange.to
						)
			);
}
function mp(t) {
	const { mapping: e, steps: n } = t,
		r = [];
	return (
		e.maps.forEach((s, o) => {
			const i = [];
			if (s.ranges.length)
				s.forEach((l, a) => {
					i.push({ from: l, to: a });
				});
			else {
				const { from: l, to: a } = n[o];
				if (l === void 0 || a === void 0) return;
				i.push({ from: l, to: a });
			}
			i.forEach(({ from: l, to: a }) => {
				const c = e.slice(o).map(l, -1),
					u = e.slice(o).map(a),
					d = e.invert().map(c, -1),
					f = e.invert().map(u);
				r.push({ oldRange: { from: d, to: f }, newRange: { from: c, to: u } });
			});
		}),
		hp(r)
	);
}
function io(t, e, n) {
	const r = [];
	return (
		t === e
			? n
					.resolve(t)
					.marks()
					.forEach((s) => {
						const o = n.resolve(t),
							i = ro(o, s.type);
						i && r.push({ mark: s, ...i });
					})
			: n.nodesBetween(t, e, (s, o) => {
					!s ||
						(s == null ? void 0 : s.nodeSize) === void 0 ||
						r.push(...s.marks.map((i) => ({ from: o, to: o + s.nodeSize, mark: i })));
				}),
		r
	);
}
function Pn(t, e, n) {
	return Object.fromEntries(
		Object.entries(n).filter(([r]) => {
			const s = t.find((o) => o.type === e && o.name === r);
			return s ? s.attribute.keepOnSplit : !1;
		})
	);
}
function Cs(t, e, n = {}) {
	const { empty: r, ranges: s } = t.selection,
		o = e ? gt(e, t.schema) : null;
	if (r)
		return !!(t.storedMarks || t.selection.$from.marks())
			.filter((d) => (o ? o.name === d.type.name : !0))
			.find((d) => Qn(d.attrs, n, { strict: !1 }));
	let i = 0;
	const l = [];
	if (
		(s.forEach(({ $from: d, $to: f }) => {
			const p = d.pos,
				h = f.pos;
			t.doc.nodesBetween(p, h, (g, m) => {
				if (!g.isText && !g.marks.length) return;
				const b = Math.max(p, m),
					k = Math.min(h, m + g.nodeSize),
					v = k - b;
				(i += v), l.push(...g.marks.map((I) => ({ mark: I, from: b, to: k })));
			});
		}),
		i === 0)
	)
		return !1;
	const a = l
			.filter((d) => (o ? o.name === d.mark.type.name : !0))
			.filter((d) => Qn(d.mark.attrs, n, { strict: !1 }))
			.reduce((d, f) => d + f.to - f.from, 0),
		c = l
			.filter((d) => (o ? d.mark.type !== o && d.mark.type.excludes(o) : !0))
			.reduce((d, f) => d + f.to - f.from, 0);
	return (a > 0 ? a + c : a) >= i;
}
function gp(t, e, n = {}) {
	if (!e) return bn(t, null, n) || Cs(t, null, n);
	const r = Pr(e, t.schema);
	return r === 'node' ? bn(t, e, n) : r === 'mark' ? Cs(t, e, n) : !1;
}
function gi(t, e) {
	const { nodeExtensions: n } = Ir(e),
		r = n.find((i) => i.name === t);
	if (!r) return !1;
	const s = { name: r.name, options: r.options, storage: r.storage },
		o = B(x(r, 'group', s));
	return typeof o != 'string' ? !1 : o.split(' ').includes('list');
}
function lo(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
	var r;
	if (n) {
		if (t.type.name === 'hardBreak') return !0;
		if (t.isText) return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : '');
	}
	if (t.isText) return !t.text;
	if (t.isAtom || t.isLeaf) return !1;
	if (t.content.childCount === 0) return !0;
	if (e) {
		let s = !0;
		return (
			t.content.forEach((o) => {
				s !== !1 && (lo(o, { ignoreWhitespace: n, checkChildren: e }) || (s = !1));
			}),
			s
		);
	}
	return !1;
}
function bp(t) {
	return t instanceof _;
}
function kp(t, e, n) {
	var r;
	const { selection: s } = e;
	let o = null;
	if ((Jl(s) && (o = s.$cursor), o)) {
		const l = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks();
		return !!n.isInSet(l) || !l.some((a) => a.type.excludes(n));
	}
	const { ranges: i } = s;
	return i.some(({ $from: l, $to: a }) => {
		let c = l.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
		return (
			t.doc.nodesBetween(l.pos, a.pos, (u, d, f) => {
				if (c) return !1;
				if (u.isInline) {
					const p = !f || f.type.allowsMarkType(n),
						h = !!n.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(n));
					c = p && h;
				}
				return !c;
			}),
			c
		);
	});
}
const yp =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: s }) => {
			const { selection: o } = n,
				{ empty: i, ranges: l } = o,
				a = gt(t, r.schema);
			if (s)
				if (i) {
					const c = ea(r, a);
					n.addStoredMark(a.create({ ...c, ...e }));
				} else
					l.forEach((c) => {
						const u = c.$from.pos,
							d = c.$to.pos;
						r.doc.nodesBetween(u, d, (f, p) => {
							const h = Math.max(p, u),
								g = Math.min(p + f.nodeSize, d);
							f.marks.find((b) => b.type === a)
								? f.marks.forEach((b) => {
										a === b.type && n.addMark(h, g, a.create({ ...b.attrs, ...e }));
									})
								: n.addMark(h, g, a.create(e));
						});
					});
			return kp(r, n, a);
		},
	$p =
		(t, e) =>
		({ tr: n }) => (n.setMeta(t, e), !0),
	Sp =
		(t, e = {}) =>
		({ state: n, dispatch: r, chain: s }) => {
			const o = ce(t, n.schema);
			let i;
			return (
				n.selection.$anchor.sameParent(n.selection.$head) && (i = n.selection.$anchor.parent.attrs),
				o.isTextblock
					? s()
							.command(({ commands: l }) => (ui(o, { ...i, ...e })(n) ? !0 : l.clearNodes()))
							.command(({ state: l }) => ui(o, { ...i, ...e })(l, r))
							.run()
					: (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
						!1)
			);
		},
	Mp =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					s = Mt(t, 0, r.content.size),
					o = _.create(r, s);
				e.setSelection(o);
			}
			return !0;
		},
	Cp =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					{ from: s, to: o } = typeof t == 'number' ? { from: t, to: t } : t,
					i = V.atStart(r).from,
					l = V.atEnd(r).to,
					a = Mt(s, i, l),
					c = Mt(o, i, l),
					u = V.create(r, a, c);
				e.setSelection(u);
			}
			return !0;
		},
	Tp =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = ce(t, e.schema);
			return ef(r)(e, n);
		};
function bi(t, e) {
	const n = t.storedMarks || (t.selection.$to.parentOffset && t.selection.$from.marks());
	if (n) {
		const r = n.filter((s) => (e == null ? void 0 : e.includes(s.type.name)));
		t.tr.ensureMarks(r);
	}
}
const xp =
		({ keepMarks: t = !0 } = {}) =>
		({ tr: e, state: n, dispatch: r, editor: s }) => {
			const { selection: o, doc: i } = e,
				{ $from: l, $to: a } = o,
				c = s.extensionManager.attributes,
				u = Pn(c, l.node().type.name, l.node().attrs);
			if (o instanceof _ && o.node.isBlock)
				return !l.parentOffset || !et(i, l.pos)
					? !1
					: (r && (t && bi(n, s.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()),
						!0);
			if (!l.parent.isBlock) return !1;
			const d = a.parentOffset === a.parent.content.size,
				f = l.depth === 0 ? void 0 : ap(l.node(-1).contentMatchAt(l.indexAfter(-1)));
			let p = d && f ? [{ type: f, attrs: u }] : void 0,
				h = et(e.doc, e.mapping.map(l.pos), 1, p);
			if (
				(!p &&
					!h &&
					et(e.doc, e.mapping.map(l.pos), 1, f ? [{ type: f }] : void 0) &&
					((h = !0), (p = f ? [{ type: f, attrs: u }] : void 0)),
				r)
			) {
				if (
					h &&
					(o instanceof V && e.deleteSelection(),
					e.split(e.mapping.map(l.pos), 1, p),
					f && !d && !l.parentOffset && l.parent.type !== f)
				) {
					const g = e.mapping.map(l.before()),
						m = e.doc.resolve(g);
					l.node(-1).canReplaceWith(m.index(), m.index() + 1, f) &&
						e.setNodeMarkup(e.mapping.map(l.before()), f);
				}
				t && bi(n, s.extensionManager.splittableMarks), e.scrollIntoView();
			}
			return h;
		},
	wp =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: s, editor: o }) => {
			var i;
			const l = ce(t, r.schema),
				{ $from: a, $to: c } = r.selection,
				u = r.selection.node;
			if ((u && u.isBlock) || a.depth < 2 || !a.sameParent(c)) return !1;
			const d = a.node(-1);
			if (d.type !== l) return !1;
			const f = o.extensionManager.attributes;
			if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
				if (a.depth === 2 || a.node(-3).type !== l || a.index(-2) !== a.node(-2).childCount - 1)
					return !1;
				if (s) {
					let b = L.empty;
					const k = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
					for (let C = a.depth - k; C >= a.depth - 3; C -= 1) b = L.from(a.node(C).copy(b));
					const v =
							a.indexAfter(-1) < a.node(-2).childCount
								? 1
								: a.indexAfter(-2) < a.node(-3).childCount
									? 2
									: 3,
						I = { ...Pn(f, a.node().type.name, a.node().attrs), ...e },
						T =
							((i = l.contentMatch.defaultType) === null || i === void 0
								? void 0
								: i.createAndFill(I)) || void 0;
					b = b.append(L.from(l.createAndFill(null, T) || void 0));
					const y = a.before(a.depth - (k - 1));
					n.replace(y, a.after(-v), new oe(b, 4 - k, 0));
					let D = -1;
					n.doc.nodesBetween(y, n.doc.content.size, (C, F) => {
						if (D > -1) return !1;
						C.isTextblock && C.content.size === 0 && (D = F + 1);
					}),
						D > -1 && n.setSelection(V.near(n.doc.resolve(D))),
						n.scrollIntoView();
				}
				return !0;
			}
			const p = c.pos === a.end() ? d.contentMatchAt(0).defaultType : null,
				h = { ...Pn(f, d.type.name, d.attrs), ...e },
				g = { ...Pn(f, a.node().type.name, a.node().attrs), ...e };
			n.delete(a.pos, c.pos);
			const m = p
				? [
						{ type: l, attrs: h },
						{ type: p, attrs: g }
					]
				: [{ type: l, attrs: h }];
			if (!et(n.doc, a.pos, 2)) return !1;
			if (s) {
				const { selection: b, storedMarks: k } = r,
					{ splittableMarks: v } = o.extensionManager,
					I = k || (b.$to.parentOffset && b.$from.marks());
				if ((n.split(a.pos, 2, m).scrollIntoView(), !I || !s)) return !0;
				const T = I.filter((y) => v.includes(y.type.name));
				n.ensureMarks(T);
			}
			return !0;
		},
	Gr = (t, e) => {
		const n = oo((i) => i.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
		if (r === void 0) return !0;
		const s = t.doc.nodeAt(r);
		return n.node.type === (s == null ? void 0 : s.type) && ht(t.doc, n.pos) && t.join(n.pos), !0;
	},
	Qr = (t, e) => {
		const n = oo((i) => i.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(n.start).after(n.depth);
		if (r === void 0) return !0;
		const s = t.doc.nodeAt(r);
		return n.node.type === (s == null ? void 0 : s.type) && ht(t.doc, r) && t.join(r), !0;
	},
	Ap =
		(t, e, n, r = {}) =>
		({ editor: s, tr: o, state: i, dispatch: l, chain: a, commands: c, can: u }) => {
			const { extensions: d, splittableMarks: f } = s.extensionManager,
				p = ce(t, i.schema),
				h = ce(e, i.schema),
				{ selection: g, storedMarks: m } = i,
				{ $from: b, $to: k } = g,
				v = b.blockRange(k),
				I = m || (g.$to.parentOffset && g.$from.marks());
			if (!v) return !1;
			const T = oo((y) => gi(y.type.name, d))(g);
			if (v.depth >= 1 && T && v.depth - T.depth <= 1) {
				if (T.node.type === p) return c.liftListItem(h);
				if (gi(T.node.type.name, d) && p.validContent(T.node.content) && l)
					return a()
						.command(() => (o.setNodeMarkup(T.pos, p), !0))
						.command(() => Gr(o, p))
						.command(() => Qr(o, p))
						.run();
			}
			return !n || !I || !l
				? a()
						.command(() => (u().wrapInList(p, r) ? !0 : c.clearNodes()))
						.wrapInList(p, r)
						.command(() => Gr(o, p))
						.command(() => Qr(o, p))
						.run()
				: a()
						.command(() => {
							const y = u().wrapInList(p, r),
								D = I.filter((C) => f.includes(C.type.name));
							return o.ensureMarks(D), y ? !0 : c.clearNodes();
						})
						.wrapInList(p, r)
						.command(() => Gr(o, p))
						.command(() => Qr(o, p))
						.run();
		},
	Ep =
		(t, e = {}, n = {}) =>
		({ state: r, commands: s }) => {
			const { extendEmptyMarkRange: o = !1 } = n,
				i = gt(t, r.schema);
			return Cs(r, i, e) ? s.unsetMark(i, { extendEmptyMarkRange: o }) : s.setMark(i, e);
		},
	Op =
		(t, e, n = {}) =>
		({ state: r, commands: s }) => {
			const o = ce(t, r.schema),
				i = ce(e, r.schema),
				l = bn(r, o, n);
			let a;
			return (
				r.selection.$anchor.sameParent(r.selection.$head) && (a = r.selection.$anchor.parent.attrs),
				l ? s.setNode(i, a) : s.setNode(o, { ...a, ...n })
			);
		},
	Np =
		(t, e = {}) =>
		({ state: n, commands: r }) => {
			const s = ce(t, n.schema);
			return bn(n, s, e) ? r.lift(s) : r.wrapIn(s, e);
		},
	Dp =
		() =>
		({ state: t, dispatch: e }) => {
			const n = t.plugins;
			for (let r = 0; r < n.length; r += 1) {
				const s = n[r];
				let o;
				if (s.spec.isInputRules && (o = s.getState(t))) {
					if (e) {
						const i = t.tr,
							l = o.transform;
						for (let a = l.steps.length - 1; a >= 0; a -= 1) i.step(l.steps[a].invert(l.docs[a]));
						if (o.text) {
							const a = i.doc.resolve(o.from).marks();
							i.replaceWith(o.from, o.to, t.schema.text(o.text, a));
						} else i.delete(o.from, o.to);
					}
					return !0;
				}
			}
			return !1;
		},
	vp =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				{ empty: r, ranges: s } = n;
			return (
				r ||
					(e &&
						s.forEach((o) => {
							t.removeMark(o.$from.pos, o.$to.pos);
						})),
				!0
			);
		},
	_p =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: s }) => {
			var o;
			const { extendEmptyMarkRange: i = !1 } = e,
				{ selection: l } = n,
				a = gt(t, r.schema),
				{ $from: c, empty: u, ranges: d } = l;
			if (!s) return !0;
			if (u && i) {
				let { from: f, to: p } = l;
				const h =
						(o = c.marks().find((m) => m.type === a)) === null || o === void 0 ? void 0 : o.attrs,
					g = ro(c, a, h);
				g && ((f = g.from), (p = g.to)), n.removeMark(f, p, a);
			} else
				d.forEach((f) => {
					n.removeMark(f.$from.pos, f.$to.pos, a);
				});
			return n.removeStoredMark(a), !0;
		},
	Ip =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: s }) => {
			let o = null,
				i = null;
			const l = Pr(typeof t == 'string' ? t : t.name, r.schema);
			return l
				? (l === 'node' && (o = ce(t, r.schema)),
					l === 'mark' && (i = gt(t, r.schema)),
					s &&
						n.selection.ranges.forEach((a) => {
							const c = a.$from.pos,
								u = a.$to.pos;
							let d, f, p, h;
							n.selection.empty
								? r.doc.nodesBetween(c, u, (g, m) => {
										o &&
											o === g.type &&
											((p = Math.max(m, c)), (h = Math.min(m + g.nodeSize, u)), (d = m), (f = g));
									})
								: r.doc.nodesBetween(c, u, (g, m) => {
										m < c &&
											o &&
											o === g.type &&
											((p = Math.max(m, c)), (h = Math.min(m + g.nodeSize, u)), (d = m), (f = g)),
											m >= c &&
												m <= u &&
												(o && o === g.type && n.setNodeMarkup(m, void 0, { ...g.attrs, ...e }),
												i &&
													g.marks.length &&
													g.marks.forEach((b) => {
														if (i === b.type) {
															const k = Math.max(m, c),
																v = Math.min(m + g.nodeSize, u);
															n.addMark(k, v, i.create({ ...b.attrs, ...e }));
														}
													}));
									}),
								f &&
									(d !== void 0 && n.setNodeMarkup(d, void 0, { ...f.attrs, ...e }),
									i &&
										f.marks.length &&
										f.marks.forEach((g) => {
											i === g.type && n.addMark(p, h, i.create({ ...g.attrs, ...e }));
										}));
						}),
					!0)
				: !1;
		},
	Lp =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const s = ce(t, n.schema);
			return Ud(s, e)(n, r);
		},
	Pp =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const s = ce(t, n.schema);
			return Gd(s, e)(n, r);
		};
var Rp = Object.freeze({
	__proto__: null,
	blur: bf,
	clearContent: kf,
	clearNodes: yf,
	command: $f,
	createParagraphNear: Sf,
	cut: Mf,
	deleteCurrentNode: Cf,
	deleteNode: Tf,
	deleteRange: xf,
	deleteSelection: wf,
	enter: Af,
	exitCode: Ef,
	extendMarkRange: Of,
	first: Nf,
	focus: vf,
	forEach: _f,
	insertContent: If,
	insertContentAt: Rf,
	joinBackward: Hf,
	joinDown: zf,
	joinForward: Vf,
	joinItemBackward: Ff,
	joinItemForward: jf,
	joinTextblockBackward: Kf,
	joinTextblockForward: Wf,
	joinUp: Bf,
	keyboardShortcut: Uf,
	lift: Gf,
	liftEmptyBlock: Qf,
	liftListItem: Jf,
	newlineInCode: Yf,
	resetAttributes: Xf,
	scrollIntoView: Zf,
	selectAll: ep,
	selectNodeBackward: tp,
	selectNodeForward: np,
	selectParentNode: rp,
	selectTextblockEnd: sp,
	selectTextblockStart: op,
	setContent: ip,
	setMark: yp,
	setMeta: $p,
	setNode: Sp,
	setNodeSelection: Mp,
	setTextSelection: Cp,
	sinkListItem: Tp,
	splitBlock: xp,
	splitListItem: wp,
	toggleList: Ap,
	toggleMark: Ep,
	toggleNode: Op,
	toggleWrap: Np,
	undoInputRule: Dp,
	unsetAllMarks: vp,
	unsetMark: _p,
	updateAttributes: Ip,
	wrapIn: Lp,
	wrapInList: Pp
});
const na = re.create({
		name: 'commands',
		addCommands() {
			return { ...Rp };
		}
	}),
	ra = re.create({
		name: 'drop',
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('tiptapDrop'),
					props: {
						handleDrop: (t, e, n, r) => {
							this.editor.emit('drop', { editor: this.editor, event: e, slice: n, moved: r });
						}
					}
				})
			];
		}
	}),
	sa = re.create({
		name: 'editable',
		addProseMirrorPlugins() {
			return [
				new ie({ key: new me('editable'), props: { editable: () => this.editor.options.editable } })
			];
		}
	}),
	oa = new me('focusEvents'),
	ia = re.create({
		name: 'focusEvents',
		addProseMirrorPlugins() {
			const { editor: t } = this;
			return [
				new ie({
					key: oa,
					props: {
						handleDOMEvents: {
							focus: (e, n) => {
								t.isFocused = !0;
								const r = t.state.tr.setMeta('focus', { event: n }).setMeta('addToHistory', !1);
								return e.dispatch(r), !1;
							},
							blur: (e, n) => {
								t.isFocused = !1;
								const r = t.state.tr.setMeta('blur', { event: n }).setMeta('addToHistory', !1);
								return e.dispatch(r), !1;
							}
						}
					}
				})
			];
		}
	}),
	la = re.create({
		name: 'keymap',
		addKeyboardShortcuts() {
			const t = () =>
					this.editor.commands.first(({ commands: i }) => [
						() => i.undoInputRule(),
						() =>
							i.command(({ tr: l }) => {
								const { selection: a, doc: c } = l,
									{ empty: u, $anchor: d } = a,
									{ pos: f, parent: p } = d,
									h = d.parent.isTextblock && f > 0 ? l.doc.resolve(f - 1) : d,
									g = h.parent.type.spec.isolating,
									m = d.pos - d.parentOffset,
									b = g && h.parent.childCount === 1 ? m === d.pos : ne.atStart(c).from === f;
								return !u ||
									!p.type.isTextblock ||
									p.textContent.length ||
									!b ||
									(b && d.parent.type.name === 'paragraph')
									? !1
									: i.clearNodes();
							}),
						() => i.deleteSelection(),
						() => i.joinBackward(),
						() => i.selectNodeBackward()
					]),
				e = () =>
					this.editor.commands.first(({ commands: i }) => [
						() => i.deleteSelection(),
						() => i.deleteCurrentNode(),
						() => i.joinForward(),
						() => i.selectNodeForward()
					]),
				r = {
					Enter: () =>
						this.editor.commands.first(({ commands: i }) => [
							() => i.newlineInCode(),
							() => i.createParagraphNear(),
							() => i.liftEmptyBlock(),
							() => i.splitBlock()
						]),
					'Mod-Enter': () => this.editor.commands.exitCode(),
					Backspace: t,
					'Mod-Backspace': t,
					'Shift-Backspace': t,
					Delete: e,
					'Mod-Delete': e,
					'Mod-a': () => this.editor.commands.selectAll()
				},
				s = { ...r },
				o = {
					...r,
					'Ctrl-h': t,
					'Alt-Backspace': t,
					'Ctrl-d': e,
					'Ctrl-Alt-Backspace': e,
					'Alt-Delete': e,
					'Alt-d': e,
					'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
					'Ctrl-e': () => this.editor.commands.selectTextblockEnd()
				};
			return so() || Zl() ? o : s;
		},
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('clearDocument'),
					appendTransaction: (t, e, n) => {
						if (t.some((g) => g.getMeta('composition'))) return;
						const r = t.some((g) => g.docChanged) && !e.doc.eq(n.doc),
							s = t.some((g) => g.getMeta('preventClearDocument'));
						if (!r || s) return;
						const { empty: o, from: i, to: l } = e.selection,
							a = ne.atStart(e.doc).from,
							c = ne.atEnd(e.doc).to;
						if (o || !(i === a && l === c) || !lo(n.doc)) return;
						const f = n.tr,
							p = vr({ state: n, transaction: f }),
							{ commands: h } = new _r({ editor: this.editor, state: p });
						if ((h.clearNodes(), !!f.steps.length)) return f;
					}
				})
			];
		}
	}),
	aa = re.create({
		name: 'paste',
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('tiptapPaste'),
					props: {
						handlePaste: (t, e, n) => {
							this.editor.emit('paste', { editor: this.editor, event: e, slice: n });
						}
					}
				})
			];
		}
	}),
	ca = re.create({
		name: 'tabindex',
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('tabindex'),
					props: { attributes: () => (this.editor.isEditable ? { tabindex: '0' } : {}) }
				})
			];
		}
	});
var Bp = Object.freeze({
	__proto__: null,
	ClipboardTextSerializer: Gl,
	Commands: na,
	Drop: ra,
	Editable: sa,
	FocusEvents: ia,
	Keymap: la,
	Paste: aa,
	Tabindex: ca,
	focusEventsPluginKey: oa
});
class yt {
	get name() {
		return this.node.type.name;
	}
	constructor(e, n, r = !1, s = null) {
		(this.currentNode = null),
			(this.actualDepth = null),
			(this.isBlock = r),
			(this.resolvedPos = e),
			(this.editor = n),
			(this.currentNode = s);
	}
	get node() {
		return this.currentNode || this.resolvedPos.node();
	}
	get element() {
		return this.editor.view.domAtPos(this.pos).node;
	}
	get depth() {
		var e;
		return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
	}
	get pos() {
		return this.resolvedPos.pos;
	}
	get content() {
		return this.node.content;
	}
	set content(e) {
		let n = this.from,
			r = this.to;
		if (this.isBlock) {
			if (this.content.size === 0) {
				console.error(
					`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
				);
				return;
			}
			(n = this.from + 1), (r = this.to - 1);
		}
		this.editor.commands.insertContentAt({ from: n, to: r }, e);
	}
	get attributes() {
		return this.node.attrs;
	}
	get textContent() {
		return this.node.textContent;
	}
	get size() {
		return this.node.nodeSize;
	}
	get from() {
		return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
	}
	get range() {
		return { from: this.from, to: this.to };
	}
	get to() {
		return this.isBlock
			? this.pos + this.size
			: this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
	}
	get parent() {
		if (this.depth === 0) return null;
		const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
			n = this.resolvedPos.doc.resolve(e);
		return new yt(n, this.editor);
	}
	get before() {
		let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
		return (
			e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
			new yt(e, this.editor)
		);
	}
	get after() {
		let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
		return (
			e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
			new yt(e, this.editor)
		);
	}
	get children() {
		const e = [];
		return (
			this.node.content.forEach((n, r) => {
				const s = n.isBlock && !n.isTextblock,
					o = n.isAtom && !n.isText,
					i = this.pos + r + (o ? 0 : 1),
					l = this.resolvedPos.doc.resolve(i);
				if (!s && l.depth <= this.depth) return;
				const a = new yt(l, this.editor, s, s ? n : null);
				s && (a.actualDepth = this.depth + 1), e.push(new yt(l, this.editor, s, s ? n : null));
			}),
			e
		);
	}
	get firstChild() {
		return this.children[0] || null;
	}
	get lastChild() {
		const e = this.children;
		return e[e.length - 1] || null;
	}
	closest(e, n = {}) {
		let r = null,
			s = this.parent;
		for (; s && !r; ) {
			if (s.node.type.name === e)
				if (Object.keys(n).length > 0) {
					const o = s.node.attrs,
						i = Object.keys(n);
					for (let l = 0; l < i.length; l += 1) {
						const a = i[l];
						if (o[a] !== n[a]) break;
					}
				} else r = s;
			s = s.parent;
		}
		return r;
	}
	querySelector(e, n = {}) {
		return this.querySelectorAll(e, n, !0)[0] || null;
	}
	querySelectorAll(e, n = {}, r = !1) {
		let s = [];
		if (!this.children || this.children.length === 0) return s;
		const o = Object.keys(n);
		return (
			this.children.forEach((i) => {
				(r && s.length > 0) ||
					(i.node.type.name === e && o.every((a) => n[a] === i.node.attrs[a]) && s.push(i),
					!(r && s.length > 0) && (s = s.concat(i.querySelectorAll(e, n, r))));
			}),
			s
		);
	}
	setAttribute(e) {
		const { tr: n } = this.editor.state;
		n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }), this.editor.view.dispatch(n);
	}
}
const zp = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function Hp(t, e, n) {
	const r = document.querySelector('style[data-tiptap-style]');
	if (r !== null) return r;
	const s = document.createElement('style');
	return (
		e && s.setAttribute('nonce', e),
		s.setAttribute('data-tiptap-style', ''),
		(s.innerHTML = t),
		document.getElementsByTagName('head')[0].appendChild(s),
		s
	);
}
class Vp extends tf {
	constructor(e = {}) {
		super(),
			(this.isFocused = !1),
			(this.isInitialized = !1),
			(this.extensionStorage = {}),
			(this.options = {
				element: document.createElement('div'),
				content: '',
				injectCSS: !0,
				injectNonce: void 0,
				extensions: [],
				autofocus: !1,
				editable: !0,
				editorProps: {},
				parseOptions: {},
				coreExtensionOptions: {},
				enableInputRules: !0,
				enablePasteRules: !0,
				enableCoreExtensions: !0,
				enableContentCheck: !1,
				emitContentError: !1,
				onBeforeCreate: () => null,
				onCreate: () => null,
				onUpdate: () => null,
				onSelectionUpdate: () => null,
				onTransaction: () => null,
				onFocus: () => null,
				onBlur: () => null,
				onDestroy: () => null,
				onContentError: ({ error: n }) => {
					throw n;
				},
				onPaste: () => null,
				onDrop: () => null
			}),
			(this.isCapturingTransaction = !1),
			(this.capturedTransaction = null),
			this.setOptions(e),
			this.createExtensionManager(),
			this.createCommandManager(),
			this.createSchema(),
			this.on('beforeCreate', this.options.onBeforeCreate),
			this.emit('beforeCreate', { editor: this }),
			this.on('contentError', this.options.onContentError),
			this.createView(),
			this.injectCSS(),
			this.on('create', this.options.onCreate),
			this.on('update', this.options.onUpdate),
			this.on('selectionUpdate', this.options.onSelectionUpdate),
			this.on('transaction', this.options.onTransaction),
			this.on('focus', this.options.onFocus),
			this.on('blur', this.options.onBlur),
			this.on('destroy', this.options.onDestroy),
			this.on('drop', ({ event: n, slice: r, moved: s }) => this.options.onDrop(n, r, s)),
			this.on('paste', ({ event: n, slice: r }) => this.options.onPaste(n, r)),
			window.setTimeout(() => {
				this.isDestroyed ||
					(this.commands.focus(this.options.autofocus),
					this.emit('create', { editor: this }),
					(this.isInitialized = !0));
			}, 0);
	}
	get storage() {
		return this.extensionStorage;
	}
	get commands() {
		return this.commandManager.commands;
	}
	chain() {
		return this.commandManager.chain();
	}
	can() {
		return this.commandManager.can();
	}
	injectCSS() {
		this.options.injectCSS && document && (this.css = Hp(zp, this.options.injectNonce));
	}
	setOptions(e = {}) {
		(this.options = { ...this.options, ...e }),
			!(!this.view || !this.state || this.isDestroyed) &&
				(this.options.editorProps && this.view.setProps(this.options.editorProps),
				this.view.updateState(this.state));
	}
	setEditable(e, n = !0) {
		this.setOptions({ editable: e }),
			n && this.emit('update', { editor: this, transaction: this.state.tr });
	}
	get isEditable() {
		return this.options.editable && this.view && this.view.editable;
	}
	get state() {
		return this.view.state;
	}
	registerPlugin(e, n) {
		const r = Wl(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e],
			s = this.state.reconfigure({ plugins: r });
		return this.view.updateState(s), s;
	}
	unregisterPlugin(e) {
		if (this.isDestroyed) return;
		const n = this.state.plugins;
		let r = n;
		if (
			([].concat(e).forEach((o) => {
				const i = typeof o == 'string' ? `${o}$` : o.key;
				r = r.filter((l) => !l.key.startsWith(i));
			}),
			n.length === r.length)
		)
			return;
		const s = this.state.reconfigure({ plugins: r });
		return this.view.updateState(s), s;
	}
	createExtensionManager() {
		var e, n;
		const s = [
			...(this.options.enableCoreExtensions
				? [
						sa,
						Gl.configure({
							blockSeparator:
								(n =
									(e = this.options.coreExtensionOptions) === null || e === void 0
										? void 0
										: e.clipboardTextSerializer) === null || n === void 0
									? void 0
									: n.blockSeparator
						}),
						na,
						ia,
						la,
						ca,
						ra,
						aa
					].filter((o) =>
						typeof this.options.enableCoreExtensions == 'object'
							? this.options.enableCoreExtensions[o.name] !== !1
							: !0
					)
				: []),
			...this.options.extensions
		].filter((o) => ['extension', 'node', 'mark'].includes(o == null ? void 0 : o.type));
		this.extensionManager = new Pt(s, this);
	}
	createCommandManager() {
		this.commandManager = new _r({ editor: this });
	}
	createSchema() {
		this.schema = this.extensionManager.schema;
	}
	createView() {
		var e;
		let n;
		try {
			n = Ms(this.options.content, this.schema, this.options.parseOptions, {
				errorOnInvalidContent: this.options.enableContentCheck
			});
		} catch (i) {
			if (
				!(i instanceof Error) ||
				!['[tiptap error]: Invalid JSON content', '[tiptap error]: Invalid HTML content'].includes(
					i.message
				)
			)
				throw i;
			this.emit('contentError', {
				editor: this,
				error: i,
				disableCollaboration: () => {
					this.storage.collaboration && (this.storage.collaboration.isDisabled = !0),
						(this.options.extensions = this.options.extensions.filter(
							(l) => l.name !== 'collaboration'
						)),
						this.createExtensionManager();
				}
			}),
				(n = Ms(this.options.content, this.schema, this.options.parseOptions, {
					errorOnInvalidContent: !1
				}));
		}
		const r = Yl(n, this.options.autofocus);
		this.view = new Nl(this.options.element, {
			...this.options.editorProps,
			attributes: {
				role: 'textbox',
				...((e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes)
			},
			dispatchTransaction: this.dispatchTransaction.bind(this),
			state: Fa.create({ doc: n, selection: r || void 0 })
		});
		const s = this.state.reconfigure({ plugins: this.extensionManager.plugins });
		this.view.updateState(s), this.createNodeViews(), this.prependClass();
		const o = this.view.dom;
		o.editor = this;
	}
	createNodeViews() {
		this.view.isDestroyed || this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
	}
	prependClass() {
		this.view.dom.className = `tiptap ${this.view.dom.className}`;
	}
	captureTransaction(e) {
		(this.isCapturingTransaction = !0), e(), (this.isCapturingTransaction = !1);
		const n = this.capturedTransaction;
		return (this.capturedTransaction = null), n;
	}
	dispatchTransaction(e) {
		if (this.view.isDestroyed) return;
		if (this.isCapturingTransaction) {
			if (!this.capturedTransaction) {
				this.capturedTransaction = e;
				return;
			}
			e.steps.forEach((i) => {
				var l;
				return (l = this.capturedTransaction) === null || l === void 0 ? void 0 : l.step(i);
			});
			return;
		}
		const n = this.state.apply(e),
			r = !this.state.selection.eq(n.selection);
		this.emit('beforeTransaction', { editor: this, transaction: e, nextState: n }),
			this.view.updateState(n),
			this.emit('transaction', { editor: this, transaction: e }),
			r && this.emit('selectionUpdate', { editor: this, transaction: e });
		const s = e.getMeta('focus'),
			o = e.getMeta('blur');
		s && this.emit('focus', { editor: this, event: s.event, transaction: e }),
			o && this.emit('blur', { editor: this, event: o.event, transaction: e }),
			!(!e.docChanged || e.getMeta('preventUpdate')) &&
				this.emit('update', { editor: this, transaction: e });
	}
	getAttributes(e) {
		return ta(this.state, e);
	}
	isActive(e, n) {
		const r = typeof e == 'string' ? e : null,
			s = typeof e == 'string' ? n : e;
		return gp(this.state, r, s);
	}
	getJSON() {
		return this.state.doc.toJSON();
	}
	getHTML() {
		return Tn(this.state.doc.content, this.schema);
	}
	getText(e) {
		const {
			blockSeparator: n = `

`,
			textSerializers: r = {}
		} = e || {};
		return dp(this.state.doc, { blockSeparator: n, textSerializers: { ...Ul(this.schema), ...r } });
	}
	get isEmpty() {
		return lo(this.state.doc);
	}
	getCharacterCount() {
		return (
			console.warn(
				'[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
			),
			this.state.doc.content.size - 2
		);
	}
	destroy() {
		if ((this.emit('destroy'), this.view)) {
			const e = this.view.dom;
			e && e.editor && delete e.editor, this.view.destroy();
		}
		this.removeAllListeners();
	}
	get isDestroyed() {
		var e;
		return !(!((e = this.view) === null || e === void 0) && e.docView);
	}
	$node(e, n) {
		var r;
		return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
	}
	$nodes(e, n) {
		var r;
		return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
	}
	$pos(e) {
		const n = this.state.doc.resolve(e);
		return new yt(n, this);
	}
	get $doc() {
		return this.$pos(0);
	}
}
function qt(t) {
	return new xn({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const s = B(t.getAttributes, void 0, r);
			if (s === !1 || s === null) return null;
			const { tr: o } = e,
				i = r[r.length - 1],
				l = r[0];
			if (i) {
				const a = l.search(/\S/),
					c = n.from + l.indexOf(i),
					u = c + i.length;
				if (
					io(n.from, n.to, e.doc)
						.filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type))
						.filter((p) => p.to > c).length
				)
					return null;
				u < n.to && o.delete(u, n.to), c > n.from && o.delete(n.from + a, c);
				const f = n.from + a + i.length;
				o.addMark(n.from + a, f, t.type.create(s || {})), o.removeStoredMark(t.type);
			}
		}
	});
}
function Fp(t) {
	return new xn({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const s = B(t.getAttributes, void 0, r) || {},
				{ tr: o } = e,
				i = n.from;
			let l = n.to;
			const a = t.type.create(s);
			if (r[1]) {
				const c = r[0].lastIndexOf(r[1]);
				let u = i + c;
				u > l ? (u = l) : (l = u + r[1].length);
				const d = r[0][r[0].length - 1];
				o.insertText(d, i + r[0].length - 1), o.replaceWith(u, l, a);
			} else if (r[0]) {
				const c = t.type.isInline ? i : i - 1;
				o.insert(c, t.type.create(s)).delete(o.mapping.map(i), o.mapping.map(l));
			}
			o.scrollIntoView();
		}
	});
}
function Ts(t) {
	return new xn({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const s = e.doc.resolve(n.from),
				o = B(t.getAttributes, void 0, r) || {};
			if (!s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t.type)) return null;
			e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
		}
	});
}
function te(t) {
	return new xn({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			let s = t.replace,
				o = n.from;
			const i = n.to;
			if (r[1]) {
				const l = r[0].lastIndexOf(r[1]);
				(s += r[0].slice(l + r[1].length)), (o += l);
				const a = o - i;
				a > 0 && ((s = r[0].slice(l - a, l) + s), (o = i));
			}
			e.tr.insertText(s, o, i);
		}
	});
}
function Ut(t) {
	return new xn({
		find: t.find,
		handler: ({ state: e, range: n, match: r, chain: s }) => {
			const o = B(t.getAttributes, void 0, r) || {},
				i = e.tr.delete(n.from, n.to),
				a = i.doc.resolve(n.from).blockRange(),
				c = a && Bs(a, t.type, o);
			if (!c) return null;
			if ((i.wrap(a, c), t.keepMarks && t.editor)) {
				const { selection: d, storedMarks: f } = e,
					{ splittableMarks: p } = t.editor.extensionManager,
					h = f || (d.$to.parentOffset && d.$from.marks());
				if (h) {
					const g = h.filter((m) => p.includes(m.type.name));
					i.ensureMarks(g);
				}
			}
			if (t.keepAttributes) {
				const d =
					t.type.name === 'bulletList' || t.type.name === 'orderedList' ? 'listItem' : 'taskList';
				s().updateAttributes(d, o).run();
			}
			const u = i.doc.resolve(n.from - 1).nodeBefore;
			u &&
				u.type === t.type &&
				ht(i.doc, n.from - 1) &&
				(!t.joinPredicate || t.joinPredicate(r, u)) &&
				i.join(n.from - 1);
		}
	});
}
let q = class xs {
	constructor(e = {}) {
		(this.type = 'node'),
			(this.name = 'node'),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = { ...this.config, ...e }),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions && (this.options = B(x(this, 'addOptions', { name: this.name }))),
			(this.storage = B(x(this, 'addStorage', { name: this.name, options: this.options })) || {});
	}
	static create(e = {}) {
		return new xs(e);
	}
	configure(e = {}) {
		const n = this.extend({ ...this.config, addOptions: () => Lr(this.options, e) });
		return (n.name = this.name), (n.parent = this.parent), n;
	}
	extend(e = {}) {
		const n = new xs(e);
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = B(x(n, 'addOptions', { name: n.name }))),
			(n.storage = B(x(n, 'addStorage', { name: n.name, options: n.options }))),
			n
		);
	}
};
function Nt(t) {
	return new df({
		find: t.find,
		handler: ({ state: e, range: n, match: r, pasteEvent: s }) => {
			const o = B(t.getAttributes, void 0, r, s);
			if (o === !1 || o === null) return null;
			const { tr: i } = e,
				l = r[r.length - 1],
				a = r[0];
			let c = n.to;
			if (l) {
				const u = a.search(/\S/),
					d = n.from + a.indexOf(l),
					f = d + l.length;
				if (
					io(n.from, n.to, e.doc)
						.filter((h) => h.mark.type.excluded.find((m) => m === t.type && m !== h.mark.type))
						.filter((h) => h.to > d).length
				)
					return null;
				f < n.to && i.delete(f, n.to),
					d > n.from && i.delete(n.from + u, d),
					(c = n.from + u + l.length),
					i.addMark(n.from + u, c, t.type.create(o || {})),
					i.removeStoredMark(t.type);
			}
		}
	});
}
const jp = /^\s*>\s$/,
	Kp = q.create({
		name: 'blockquote',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: 'block+',
		group: 'block',
		defining: !0,
		parseHTML() {
			return [{ tag: 'blockquote' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['blockquote', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBlockquote:
					() =>
					({ commands: t }) =>
						t.wrapIn(this.name),
				toggleBlockquote:
					() =>
					({ commands: t }) =>
						t.toggleWrap(this.name),
				unsetBlockquote:
					() =>
					({ commands: t }) =>
						t.lift(this.name)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Shift-b': () => this.editor.commands.toggleBlockquote() };
		},
		addInputRules() {
			return [Ut({ find: jp, type: this.type })];
		}
	}),
	Wp = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/,
	qp = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g,
	Up = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/,
	Gp = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g,
	Qp = Me.create({
		name: 'bold',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: 'strong' },
				{ tag: 'b', getAttrs: (t) => t.style.fontWeight !== 'normal' && null },
				{ style: 'font-weight=400', clearMark: (t) => t.type.name === this.name },
				{ style: 'font-weight', getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['strong', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBold:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleBold:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetBold:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name)
			};
		},
		addKeyboardShortcuts() {
			return {
				'Mod-b': () => this.editor.commands.toggleBold(),
				'Mod-B': () => this.editor.commands.toggleBold()
			};
		},
		addInputRules() {
			return [qt({ find: Wp, type: this.type }), qt({ find: Up, type: this.type })];
		},
		addPasteRules() {
			return [Nt({ find: qp, type: this.type }), Nt({ find: Gp, type: this.type })];
		}
	}),
	Jp = 'listItem',
	ki = 'textStyle',
	yi = /^\s*([-+*])\s$/,
	Yp = q.create({
		name: 'bulletList',
		addOptions() {
			return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 };
		},
		group: 'block list',
		content() {
			return `${this.options.itemTypeName}+`;
		},
		parseHTML() {
			return [{ tag: 'ul' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['ul', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleBulletList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
									.updateAttributes(Jp, this.editor.getAttributes(ki))
									.run()
							: t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Shift-8': () => this.editor.commands.toggleBulletList() };
		},
		addInputRules() {
			let t = Ut({ find: yi, type: this.type });
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Ut({
						find: yi,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: () => this.editor.getAttributes(ki),
						editor: this.editor
					})),
				[t]
			);
		}
	}),
	Xp = /(^|[^`])`([^`]+)`(?!`)/,
	Zp = /(^|[^`])`([^`]+)`(?!`)/g,
	eh = Me.create({
		name: 'code',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		excludes: '_',
		code: !0,
		exitable: !0,
		parseHTML() {
			return [{ tag: 'code' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['code', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setCode:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleCode:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetCode:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-e': () => this.editor.commands.toggleCode() };
		},
		addInputRules() {
			return [qt({ find: Xp, type: this.type })];
		},
		addPasteRules() {
			return [Nt({ find: Zp, type: this.type })];
		}
	}),
	th = /^```([a-z]+)?[\s\n]$/,
	nh = /^~~~([a-z]+)?[\s\n]$/,
	rh = q.create({
		name: 'codeBlock',
		addOptions() {
			return {
				languageClassPrefix: 'language-',
				exitOnTripleEnter: !0,
				exitOnArrowDown: !0,
				defaultLanguage: null,
				HTMLAttributes: {}
			};
		},
		content: 'text*',
		marks: '',
		group: 'block',
		code: !0,
		defining: !0,
		addAttributes() {
			return {
				language: {
					default: this.options.defaultLanguage,
					parseHTML: (t) => {
						var e;
						const { languageClassPrefix: n } = this.options,
							o = [
								...(((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) ||
									[])
							]
								.filter((i) => i.startsWith(n))
								.map((i) => i.replace(n, ''))[0];
						return o || null;
					},
					rendered: !1
				}
			};
		},
		parseHTML() {
			return [{ tag: 'pre', preserveWhitespace: 'full' }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				'pre',
				le(this.options.HTMLAttributes, e),
				[
					'code',
					{ class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null },
					0
				]
			];
		},
		addCommands() {
			return {
				setCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.setNode(this.name, t),
				toggleCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.toggleNode(this.name, 'paragraph', t)
			};
		},
		addKeyboardShortcuts() {
			return {
				'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
				Backspace: () => {
					const { empty: t, $anchor: e } = this.editor.state.selection,
						n = e.pos === 1;
					return !t || e.parent.type.name !== this.name
						? !1
						: n || !e.parent.textContent.length
							? this.editor.commands.clearNodes()
							: !1;
				},
				Enter: ({ editor: t }) => {
					if (!this.options.exitOnTripleEnter) return !1;
					const { state: e } = t,
						{ selection: n } = e,
						{ $from: r, empty: s } = n;
					if (!s || r.parent.type !== this.type) return !1;
					const o = r.parentOffset === r.parent.nodeSize - 2,
						i = r.parent.textContent.endsWith(`

`);
					return !o || !i
						? !1
						: t
								.chain()
								.command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0))
								.exitCode()
								.run();
				},
				ArrowDown: ({ editor: t }) => {
					if (!this.options.exitOnArrowDown) return !1;
					const { state: e } = t,
						{ selection: n, doc: r } = e,
						{ $from: s, empty: o } = n;
					if (!o || s.parent.type !== this.type || !(s.parentOffset === s.parent.nodeSize - 2))
						return !1;
					const l = s.after();
					return l === void 0
						? !1
						: r.nodeAt(l)
							? t.commands.command(({ tr: c }) => (c.setSelection(ne.near(r.resolve(l))), !0))
							: t.commands.exitCode();
				}
			};
		},
		addInputRules() {
			return [
				Ts({ find: th, type: this.type, getAttributes: (t) => ({ language: t[1] }) }),
				Ts({ find: nh, type: this.type, getAttributes: (t) => ({ language: t[1] }) })
			];
		},
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('codeBlockVSCodeHandler'),
					props: {
						handlePaste: (t, e) => {
							if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1;
							const n = e.clipboardData.getData('text/plain'),
								r = e.clipboardData.getData('vscode-editor-data'),
								s = r ? JSON.parse(r) : void 0,
								o = s == null ? void 0 : s.mode;
							if (!n || !o) return !1;
							const { tr: i, schema: l } = t.state,
								a = l.text(
									n.replace(
										/\r\n?/g,
										`
`
									)
								);
							return (
								i.replaceSelectionWith(this.type.create({ language: o }, a)),
								i.selection.$from.parent.type !== this.type &&
									i.setSelection(V.near(i.doc.resolve(Math.max(0, i.selection.from - 2)))),
								i.setMeta('paste', !0),
								t.dispatch(i),
								!0
							);
						}
					}
				})
			];
		}
	}),
	ua = q.create({ name: 'doc', topNode: !0, content: 'block+' });
function sh(t = {}) {
	return new ie({
		view(e) {
			return new oh(e, t);
		}
	});
}
class oh {
	constructor(e, n) {
		var r;
		(this.editorView = e),
			(this.cursorPos = null),
			(this.element = null),
			(this.timeout = -1),
			(this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
			(this.color = n.color === !1 ? void 0 : n.color || 'black'),
			(this.class = n.class),
			(this.handlers = ['dragover', 'dragend', 'drop', 'dragleave'].map((s) => {
				let o = (i) => {
					this[s](i);
				};
				return e.dom.addEventListener(s, o), { name: s, handler: o };
			}));
	}
	destroy() {
		this.handlers.forEach(({ name: e, handler: n }) =>
			this.editorView.dom.removeEventListener(e, n)
		);
	}
	update(e, n) {
		this.cursorPos != null &&
			n.doc != e.state.doc &&
			(this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
	}
	setCursor(e) {
		e != this.cursorPos &&
			((this.cursorPos = e),
			e == null
				? (this.element.parentNode.removeChild(this.element), (this.element = null))
				: this.updateOverlay());
	}
	updateOverlay() {
		let e = this.editorView.state.doc.resolve(this.cursorPos),
			n = !e.parent.inlineContent,
			r,
			s = this.editorView.dom,
			o = s.getBoundingClientRect(),
			i = o.width / s.offsetWidth,
			l = o.height / s.offsetHeight;
		if (n) {
			let d = e.nodeBefore,
				f = e.nodeAfter;
			if (d || f) {
				let p = this.editorView.nodeDOM(this.cursorPos - (d ? d.nodeSize : 0));
				if (p) {
					let h = p.getBoundingClientRect(),
						g = d ? h.bottom : h.top;
					d &&
						f &&
						(g = (g + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
					let m = (this.width / 2) * l;
					r = { left: h.left, right: h.right, top: g - m, bottom: g + m };
				}
			}
		}
		if (!r) {
			let d = this.editorView.coordsAtPos(this.cursorPos),
				f = (this.width / 2) * i;
			r = { left: d.left - f, right: d.left + f, top: d.top, bottom: d.bottom };
		}
		let a = this.editorView.dom.offsetParent;
		this.element ||
			((this.element = a.appendChild(document.createElement('div'))),
			this.class && (this.element.className = this.class),
			(this.element.style.cssText = 'position: absolute; z-index: 50; pointer-events: none;'),
			this.color && (this.element.style.backgroundColor = this.color)),
			this.element.classList.toggle('prosemirror-dropcursor-block', n),
			this.element.classList.toggle('prosemirror-dropcursor-inline', !n);
		let c, u;
		if (!a || (a == document.body && getComputedStyle(a).position == 'static'))
			(c = -pageXOffset), (u = -pageYOffset);
		else {
			let d = a.getBoundingClientRect(),
				f = d.width / a.offsetWidth,
				p = d.height / a.offsetHeight;
			(c = d.left - a.scrollLeft * f), (u = d.top - a.scrollTop * p);
		}
		(this.element.style.left = (r.left - c) / i + 'px'),
			(this.element.style.top = (r.top - u) / l + 'px'),
			(this.element.style.width = (r.right - r.left) / i + 'px'),
			(this.element.style.height = (r.bottom - r.top) / l + 'px');
	}
	scheduleRemoval(e) {
		clearTimeout(this.timeout), (this.timeout = setTimeout(() => this.setCursor(null), e));
	}
	dragover(e) {
		if (!this.editorView.editable) return;
		let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }),
			r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside),
			s = r && r.type.spec.disableDropCursor,
			o = typeof s == 'function' ? s(this.editorView, n, e) : s;
		if (n && !o) {
			let i = n.pos;
			if (this.editorView.dragging && this.editorView.dragging.slice) {
				let l = Wi(this.editorView.state.doc, i, this.editorView.dragging.slice);
				l != null && (i = l);
			}
			this.setCursor(i), this.scheduleRemoval(5e3);
		}
	}
	dragend() {
		this.scheduleRemoval(20);
	}
	drop() {
		this.scheduleRemoval(20);
	}
	dragleave(e) {
		this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
	}
}
const ih = re.create({
	name: 'dropCursor',
	addOptions() {
		return { color: 'currentColor', width: 1, class: void 0 };
	},
	addProseMirrorPlugins() {
		return [sh(this.options)];
	}
});
class ee extends ne {
	constructor(e) {
		super(e, e);
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		return ee.valid(r) ? new ee(r) : ne.near(r);
	}
	content() {
		return oe.empty;
	}
	eq(e) {
		return e instanceof ee && e.head == this.head;
	}
	toJSON() {
		return { type: 'gapcursor', pos: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.pos != 'number') throw new RangeError('Invalid input for GapCursor.fromJSON');
		return new ee(e.resolve(n.pos));
	}
	getBookmark() {
		return new ao(this.anchor);
	}
	static valid(e) {
		let n = e.parent;
		if (n.isTextblock || !lh(e) || !ah(e)) return !1;
		let r = n.type.spec.allowGapCursor;
		if (r != null) return r;
		let s = n.contentMatchAt(e.index()).defaultType;
		return s && s.isTextblock;
	}
	static findGapCursorFrom(e, n, r = !1) {
		e: for (;;) {
			if (!r && ee.valid(e)) return e;
			let s = e.pos,
				o = null;
			for (let i = e.depth; ; i--) {
				let l = e.node(i);
				if (n > 0 ? e.indexAfter(i) < l.childCount : e.index(i) > 0) {
					o = l.child(n > 0 ? e.indexAfter(i) : e.index(i) - 1);
					break;
				} else if (i == 0) return null;
				s += n;
				let a = e.doc.resolve(s);
				if (ee.valid(a)) return a;
			}
			for (;;) {
				let i = n > 0 ? o.firstChild : o.lastChild;
				if (!i) {
					if (o.isAtom && !o.isText && !_.isSelectable(o)) {
						(e = e.doc.resolve(s + o.nodeSize * n)), (r = !1);
						continue e;
					}
					break;
				}
				(o = i), (s += n);
				let l = e.doc.resolve(s);
				if (ee.valid(l)) return l;
			}
			return null;
		}
	}
}
ee.prototype.visible = !1;
ee.findFrom = ee.findGapCursorFrom;
ne.jsonID('gapcursor', ee);
class ao {
	constructor(e) {
		this.pos = e;
	}
	map(e) {
		return new ao(e.map(this.pos));
	}
	resolve(e) {
		let n = e.resolve(this.pos);
		return ee.valid(n) ? new ee(n) : ne.near(n);
	}
}
function lh(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.index(e),
			r = t.node(e);
		if (n == 0) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let s = r.child(n - 1); ; s = s.lastChild) {
			if ((s.childCount == 0 && !s.inlineContent) || s.isAtom || s.type.spec.isolating) return !0;
			if (s.inlineContent) return !1;
		}
	}
	return !0;
}
function ah(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.indexAfter(e),
			r = t.node(e);
		if (n == r.childCount) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let s = r.child(n); ; s = s.firstChild) {
			if ((s.childCount == 0 && !s.inlineContent) || s.isAtom || s.type.spec.isolating) return !0;
			if (s.inlineContent) return !1;
		}
	}
	return !0;
}
function ch() {
	return new ie({
		props: {
			decorations: ph,
			createSelectionBetween(t, e, n) {
				return e.pos == n.pos && ee.valid(n) ? new ee(n) : null;
			},
			handleClick: dh,
			handleKeyDown: uh,
			handleDOMEvents: { beforeinput: fh }
		}
	});
}
const uh = Dl({
	ArrowLeft: Dn('horiz', -1),
	ArrowRight: Dn('horiz', 1),
	ArrowUp: Dn('vert', -1),
	ArrowDown: Dn('vert', 1)
});
function Dn(t, e) {
	const n = t == 'vert' ? (e > 0 ? 'down' : 'up') : e > 0 ? 'right' : 'left';
	return function (r, s, o) {
		let i = r.selection,
			l = e > 0 ? i.$to : i.$from,
			a = i.empty;
		if (i instanceof V) {
			if (!o.endOfTextblock(n) || l.depth == 0) return !1;
			(a = !1), (l = r.doc.resolve(e > 0 ? l.after() : l.before()));
		}
		let c = ee.findGapCursorFrom(l, e, a);
		return c ? (s && s(r.tr.setSelection(new ee(c))), !0) : !1;
	};
}
function dh(t, e, n) {
	if (!t || !t.editable) return !1;
	let r = t.state.doc.resolve(e);
	if (!ee.valid(r)) return !1;
	let s = t.posAtCoords({ left: n.clientX, top: n.clientY });
	return s && s.inside > -1 && _.isSelectable(t.state.doc.nodeAt(s.inside))
		? !1
		: (t.dispatch(t.state.tr.setSelection(new ee(r))), !0);
}
function fh(t, e) {
	if (e.inputType != 'insertCompositionText' || !(t.state.selection instanceof ee)) return !1;
	let { $from: n } = t.state.selection,
		r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
	if (!r) return !1;
	let s = L.empty;
	for (let i = r.length - 1; i >= 0; i--) s = L.from(r[i].createAndFill(null, s));
	let o = t.state.tr.replace(n.pos, n.pos, new oe(s, 0, 0));
	return o.setSelection(V.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function ph(t) {
	if (!(t.selection instanceof ee)) return null;
	let e = document.createElement('div');
	return (
		(e.className = 'ProseMirror-gapcursor'),
		Y.create(t.doc, [Ne.widget(t.selection.head, e, { key: 'gapcursor' })])
	);
}
const hh = re.create({
		name: 'gapCursor',
		addProseMirrorPlugins() {
			return [ch()];
		},
		extendNodeSchema(t) {
			var e;
			const n = { name: t.name, options: t.options, storage: t.storage };
			return {
				allowGapCursor: (e = B(x(t, 'allowGapCursor', n))) !== null && e !== void 0 ? e : null
			};
		}
	}),
	mh = q.create({
		name: 'hardBreak',
		addOptions() {
			return { keepMarks: !0, HTMLAttributes: {} };
		},
		inline: !0,
		group: 'inline',
		selectable: !1,
		linebreakReplacement: !0,
		parseHTML() {
			return [{ tag: 'br' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['br', le(this.options.HTMLAttributes, t)];
		},
		renderText() {
			return `
`;
		},
		addCommands() {
			return {
				setHardBreak:
					() =>
					({ commands: t, chain: e, state: n, editor: r }) =>
						t.first([
							() => t.exitCode(),
							() =>
								t.command(() => {
									const { selection: s, storedMarks: o } = n;
									if (s.$from.parent.type.spec.isolating) return !1;
									const { keepMarks: i } = this.options,
										{ splittableMarks: l } = r.extensionManager,
										a = o || (s.$to.parentOffset && s.$from.marks());
									return e()
										.insertContent({ type: this.name })
										.command(({ tr: c, dispatch: u }) => {
											if (u && a && i) {
												const d = a.filter((f) => l.includes(f.type.name));
												c.ensureMarks(d);
											}
											return !0;
										})
										.run();
								})
						])
			};
		},
		addKeyboardShortcuts() {
			return {
				'Mod-Enter': () => this.editor.commands.setHardBreak(),
				'Shift-Enter': () => this.editor.commands.setHardBreak()
			};
		}
	}),
	gh = q.create({
		name: 'heading',
		addOptions() {
			return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
		},
		content: 'inline*',
		group: 'block',
		defining: !0,
		addAttributes() {
			return { level: { default: 1, rendered: !1 } };
		},
		parseHTML() {
			return this.options.levels.map((t) => ({ tag: `h${t}`, attrs: { level: t } }));
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`,
				le(this.options.HTMLAttributes, e),
				0
			];
		},
		addCommands() {
			return {
				setHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
				toggleHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level) ? e.toggleNode(this.name, 'paragraph', t) : !1
			};
		},
		addKeyboardShortcuts() {
			return this.options.levels.reduce(
				(t, e) => ({
					...t,
					[`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
				}),
				{}
			);
		},
		addInputRules() {
			return this.options.levels.map((t) =>
				Ts({
					find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
					type: this.type,
					getAttributes: { level: t }
				})
			);
		}
	});
var Jn = 200,
	ae = function () {};
ae.prototype.append = function (e) {
	return e.length
		? ((e = ae.from(e)),
			(!this.length && e) ||
				(e.length < Jn && this.leafAppend(e)) ||
				(this.length < Jn && e.leafPrepend(this)) ||
				this.appendInner(e))
		: this;
};
ae.prototype.prepend = function (e) {
	return e.length ? ae.from(e).append(this) : this;
};
ae.prototype.appendInner = function (e) {
	return new bh(this, e);
};
ae.prototype.slice = function (e, n) {
	return (
		e === void 0 && (e = 0),
		n === void 0 && (n = this.length),
		e >= n ? ae.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
	);
};
ae.prototype.get = function (e) {
	if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
ae.prototype.forEach = function (e, n, r) {
	n === void 0 && (n = 0),
		r === void 0 && (r = this.length),
		n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
ae.prototype.map = function (e, n, r) {
	n === void 0 && (n = 0), r === void 0 && (r = this.length);
	var s = [];
	return (
		this.forEach(
			function (o, i) {
				return s.push(e(o, i));
			},
			n,
			r
		),
		s
	);
};
ae.from = function (e) {
	return e instanceof ae ? e : e && e.length ? new da(e) : ae.empty;
};
var da = (function (t) {
	function e(r) {
		t.call(this), (this.values = r);
	}
	t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e);
	var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
	return (
		(e.prototype.flatten = function () {
			return this.values;
		}),
		(e.prototype.sliceInner = function (s, o) {
			return s == 0 && o == this.length ? this : new e(this.values.slice(s, o));
		}),
		(e.prototype.getInner = function (s) {
			return this.values[s];
		}),
		(e.prototype.forEachInner = function (s, o, i, l) {
			for (var a = o; a < i; a++) if (s(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.forEachInvertedInner = function (s, o, i, l) {
			for (var a = o - 1; a >= i; a--) if (s(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.leafAppend = function (s) {
			if (this.length + s.length <= Jn) return new e(this.values.concat(s.flatten()));
		}),
		(e.prototype.leafPrepend = function (s) {
			if (this.length + s.length <= Jn) return new e(s.flatten().concat(this.values));
		}),
		(n.length.get = function () {
			return this.values.length;
		}),
		(n.depth.get = function () {
			return 0;
		}),
		Object.defineProperties(e.prototype, n),
		e
	);
})(ae);
ae.empty = new da([]);
var bh = (function (t) {
	function e(n, r) {
		t.call(this),
			(this.left = n),
			(this.right = r),
			(this.length = n.length + r.length),
			(this.depth = Math.max(n.depth, r.depth) + 1);
	}
	return (
		t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e),
		(e.prototype.flatten = function () {
			return this.left.flatten().concat(this.right.flatten());
		}),
		(e.prototype.getInner = function (r) {
			return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
		}),
		(e.prototype.forEachInner = function (r, s, o, i) {
			var l = this.left.length;
			if (
				(s < l && this.left.forEachInner(r, s, Math.min(o, l), i) === !1) ||
				(o > l &&
					this.right.forEachInner(r, Math.max(s - l, 0), Math.min(this.length, o) - l, i + l) ===
						!1)
			)
				return !1;
		}),
		(e.prototype.forEachInvertedInner = function (r, s, o, i) {
			var l = this.left.length;
			if (
				(s > l && this.right.forEachInvertedInner(r, s - l, Math.max(o, l) - l, i + l) === !1) ||
				(o < l && this.left.forEachInvertedInner(r, Math.min(s, l), o, i) === !1)
			)
				return !1;
		}),
		(e.prototype.sliceInner = function (r, s) {
			if (r == 0 && s == this.length) return this;
			var o = this.left.length;
			return s <= o
				? this.left.slice(r, s)
				: r >= o
					? this.right.slice(r - o, s - o)
					: this.left.slice(r, o).append(this.right.slice(0, s - o));
		}),
		(e.prototype.leafAppend = function (r) {
			var s = this.right.leafAppend(r);
			if (s) return new e(this.left, s);
		}),
		(e.prototype.leafPrepend = function (r) {
			var s = this.left.leafPrepend(r);
			if (s) return new e(s, this.right);
		}),
		(e.prototype.appendInner = function (r) {
			return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
				? new e(this.left, new e(this.right, r))
				: new e(this, r);
		}),
		e
	);
})(ae);
const kh = 500;
class Be {
	constructor(e, n) {
		(this.items = e), (this.eventCount = n);
	}
	popEvent(e, n) {
		if (this.eventCount == 0) return null;
		let r = this.items.length;
		for (; ; r--)
			if (this.items.get(r - 1).selection) {
				--r;
				break;
			}
		let s, o;
		n && ((s = this.remapping(r, this.items.length)), (o = s.maps.length));
		let i = e.tr,
			l,
			a,
			c = [],
			u = [];
		return (
			this.items.forEach(
				(d, f) => {
					if (!d.step) {
						s || ((s = this.remapping(r, f + 1)), (o = s.maps.length)), o--, u.push(d);
						return;
					}
					if (s) {
						u.push(new Fe(d.map));
						let p = d.step.map(s.slice(o)),
							h;
						p &&
							i.maybeStep(p).doc &&
							((h = i.mapping.maps[i.mapping.maps.length - 1]),
							c.push(new Fe(h, void 0, void 0, c.length + u.length))),
							o--,
							h && s.appendMap(h, o);
					} else i.maybeStep(d.step);
					if (d.selection)
						return (
							(l = s ? d.selection.map(s.slice(o)) : d.selection),
							(a = new Be(
								this.items.slice(0, r).append(u.reverse().concat(c)),
								this.eventCount - 1
							)),
							!1
						);
				},
				this.items.length,
				0
			),
			{ remaining: a, transform: i, selection: l }
		);
	}
	addTransform(e, n, r, s) {
		let o = [],
			i = this.eventCount,
			l = this.items,
			a = !s && l.length ? l.get(l.length - 1) : null;
		for (let u = 0; u < e.steps.length; u++) {
			let d = e.steps[u].invert(e.docs[u]),
				f = new Fe(e.mapping.maps[u], d, n),
				p;
			(p = a && a.merge(f)) && ((f = p), u ? o.pop() : (l = l.slice(0, l.length - 1))),
				o.push(f),
				n && (i++, (n = void 0)),
				s || (a = f);
		}
		let c = i - r.depth;
		return c > $h && ((l = yh(l, c)), (i -= c)), new Be(l.append(o), i);
	}
	remapping(e, n) {
		let r = new Ka();
		return (
			this.items.forEach(
				(s, o) => {
					let i =
						s.mirrorOffset != null && o - s.mirrorOffset >= e
							? r.maps.length - s.mirrorOffset
							: void 0;
					r.appendMap(s.map, i);
				},
				e,
				n
			),
			r
		);
	}
	addMaps(e) {
		return this.eventCount == 0
			? this
			: new Be(this.items.append(e.map((n) => new Fe(n))), this.eventCount);
	}
	rebased(e, n) {
		if (!this.eventCount) return this;
		let r = [],
			s = Math.max(0, this.items.length - n),
			o = e.mapping,
			i = e.steps.length,
			l = this.eventCount;
		this.items.forEach((f) => {
			f.selection && l--;
		}, s);
		let a = n;
		this.items.forEach((f) => {
			let p = o.getMirror(--a);
			if (p == null) return;
			i = Math.min(i, p);
			let h = o.maps[p];
			if (f.step) {
				let g = e.steps[p].invert(e.docs[p]),
					m = f.selection && f.selection.map(o.slice(a + 1, p));
				m && l++, r.push(new Fe(h, g, m));
			} else r.push(new Fe(h));
		}, s);
		let c = [];
		for (let f = n; f < i; f++) c.push(new Fe(o.maps[f]));
		let u = this.items.slice(0, s).append(c).append(r),
			d = new Be(u, l);
		return d.emptyItemCount() > kh && (d = d.compress(this.items.length - r.length)), d;
	}
	emptyItemCount() {
		let e = 0;
		return (
			this.items.forEach((n) => {
				n.step || e++;
			}),
			e
		);
	}
	compress(e = this.items.length) {
		let n = this.remapping(0, e),
			r = n.maps.length,
			s = [],
			o = 0;
		return (
			this.items.forEach(
				(i, l) => {
					if (l >= e) s.push(i), i.selection && o++;
					else if (i.step) {
						let a = i.step.map(n.slice(r)),
							c = a && a.getMap();
						if ((r--, c && n.appendMap(c, r), a)) {
							let u = i.selection && i.selection.map(n.slice(r));
							u && o++;
							let d = new Fe(c.invert(), a, u),
								f,
								p = s.length - 1;
							(f = s.length && s[p].merge(d)) ? (s[p] = f) : s.push(d);
						}
					} else i.map && r--;
				},
				this.items.length,
				0
			),
			new Be(ae.from(s.reverse()), o)
		);
	}
}
Be.empty = new Be(ae.empty, 0);
function yh(t, e) {
	let n;
	return (
		t.forEach((r, s) => {
			if (r.selection && e-- == 0) return (n = s), !1;
		}),
		t.slice(n)
	);
}
class Fe {
	constructor(e, n, r, s) {
		(this.map = e), (this.step = n), (this.selection = r), (this.mirrorOffset = s);
	}
	merge(e) {
		if (this.step && e.step && !e.selection) {
			let n = e.step.merge(this.step);
			if (n) return new Fe(n.getMap().invert(), n, this.selection);
		}
	}
}
class ot {
	constructor(e, n, r, s, o) {
		(this.done = e),
			(this.undone = n),
			(this.prevRanges = r),
			(this.prevTime = s),
			(this.prevComposition = o);
	}
}
const $h = 20;
function Sh(t, e, n, r) {
	let s = n.getMeta(wt),
		o;
	if (s) return s.historyState;
	n.getMeta(Th) && (t = new ot(t.done, t.undone, null, 0, -1));
	let i = n.getMeta('appendedTransaction');
	if (n.steps.length == 0) return t;
	if (i && i.getMeta(wt))
		return i.getMeta(wt).redo
			? new ot(
					t.done.addTransform(n, void 0, r, Rn(e)),
					t.undone,
					$i(n.mapping.maps),
					t.prevTime,
					t.prevComposition
				)
			: new ot(
					t.done,
					t.undone.addTransform(n, void 0, r, Rn(e)),
					null,
					t.prevTime,
					t.prevComposition
				);
	if (n.getMeta('addToHistory') !== !1 && !(i && i.getMeta('addToHistory') === !1)) {
		let l = n.getMeta('composition'),
			a =
				t.prevTime == 0 ||
				(!i &&
					t.prevComposition != l &&
					(t.prevTime < (n.time || 0) - r.newGroupDelay || !Mh(n, t.prevRanges))),
			c = i ? Jr(t.prevRanges, n.mapping) : $i(n.mapping.maps);
		return new ot(
			t.done.addTransform(n, a ? e.selection.getBookmark() : void 0, r, Rn(e)),
			Be.empty,
			c,
			n.time,
			l ?? t.prevComposition
		);
	} else
		return (o = n.getMeta('rebased'))
			? new ot(
					t.done.rebased(n, o),
					t.undone.rebased(n, o),
					Jr(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
				)
			: new ot(
					t.done.addMaps(n.mapping.maps),
					t.undone.addMaps(n.mapping.maps),
					Jr(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
				);
}
function Mh(t, e) {
	if (!e) return !1;
	if (!t.docChanged) return !0;
	let n = !1;
	return (
		t.mapping.maps[0].forEach((r, s) => {
			for (let o = 0; o < e.length; o += 2) r <= e[o + 1] && s >= e[o] && (n = !0);
		}),
		n
	);
}
function $i(t) {
	let e = [];
	for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
		t[n].forEach((r, s, o, i) => e.push(o, i));
	return e;
}
function Jr(t, e) {
	if (!t) return null;
	let n = [];
	for (let r = 0; r < t.length; r += 2) {
		let s = e.map(t[r], 1),
			o = e.map(t[r + 1], -1);
		s <= o && n.push(s, o);
	}
	return n;
}
function Ch(t, e, n) {
	let r = Rn(e),
		s = wt.get(e).spec.config,
		o = (n ? t.undone : t.done).popEvent(e, r);
	if (!o) return null;
	let i = o.selection.resolve(o.transform.doc),
		l = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), s, r),
		a = new ot(n ? l : o.remaining, n ? o.remaining : l, null, 0, -1);
	return o.transform.setSelection(i).setMeta(wt, { redo: n, historyState: a });
}
let Yr = !1,
	Si = null;
function Rn(t) {
	let e = t.plugins;
	if (Si != e) {
		(Yr = !1), (Si = e);
		for (let n = 0; n < e.length; n++)
			if (e[n].spec.historyPreserveItems) {
				Yr = !0;
				break;
			}
	}
	return Yr;
}
const wt = new me('history'),
	Th = new me('closeHistory');
function xh(t = {}) {
	return (
		(t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
		new ie({
			key: wt,
			state: {
				init() {
					return new ot(Be.empty, Be.empty, null, 0, -1);
				},
				apply(e, n, r) {
					return Sh(n, r, e, t);
				}
			},
			config: t,
			props: {
				handleDOMEvents: {
					beforeinput(e, n) {
						let r = n.inputType,
							s = r == 'historyUndo' ? pa : r == 'historyRedo' ? ha : null;
						return s ? (n.preventDefault(), s(e.state, e.dispatch)) : !1;
					}
				}
			}
		})
	);
}
function fa(t, e) {
	return (n, r) => {
		let s = wt.getState(n);
		if (!s || (t ? s.undone : s.done).eventCount == 0) return !1;
		if (r) {
			let o = Ch(s, n, t);
			o && r(e ? o.scrollIntoView() : o);
		}
		return !0;
	};
}
const pa = fa(!1, !0),
	ha = fa(!0, !0),
	wh = re.create({
		name: 'history',
		addOptions() {
			return { depth: 100, newGroupDelay: 500 };
		},
		addCommands() {
			return {
				undo:
					() =>
					({ state: t, dispatch: e }) =>
						pa(t, e),
				redo:
					() =>
					({ state: t, dispatch: e }) =>
						ha(t, e)
			};
		},
		addProseMirrorPlugins() {
			return [xh(this.options)];
		},
		addKeyboardShortcuts() {
			return {
				'Mod-z': () => this.editor.commands.undo(),
				'Shift-Mod-z': () => this.editor.commands.redo(),
				'Mod-y': () => this.editor.commands.redo(),
				'Mod-я': () => this.editor.commands.undo(),
				'Shift-Mod-я': () => this.editor.commands.redo()
			};
		}
	}),
	Ah = q.create({
		name: 'horizontalRule',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: 'block',
		parseHTML() {
			return [{ tag: 'hr' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['hr', le(this.options.HTMLAttributes, t)];
		},
		addCommands() {
			return {
				setHorizontalRule:
					() =>
					({ chain: t, state: e }) => {
						const { selection: n } = e,
							{ $from: r, $to: s } = n,
							o = t();
						return (
							r.parentOffset === 0
								? o.insertContentAt(
										{ from: Math.max(r.pos - 1, 0), to: s.pos },
										{ type: this.name }
									)
								: bp(n)
									? o.insertContentAt(s.pos, { type: this.name })
									: o.insertContent({ type: this.name }),
							o
								.command(({ tr: i, dispatch: l }) => {
									var a;
									if (l) {
										const { $to: c } = i.selection,
											u = c.end();
										if (c.nodeAfter)
											c.nodeAfter.isTextblock
												? i.setSelection(V.create(i.doc, c.pos + 1))
												: c.nodeAfter.isBlock
													? i.setSelection(_.create(i.doc, c.pos))
													: i.setSelection(V.create(i.doc, c.pos));
										else {
											const d =
												(a = c.parent.type.contentMatch.defaultType) === null || a === void 0
													? void 0
													: a.create();
											d && (i.insert(u, d), i.setSelection(V.create(i.doc, u + 1)));
										}
										i.scrollIntoView();
									}
									return !0;
								})
								.run()
						);
					}
			};
		},
		addInputRules() {
			return [Fp({ find: /^(?:---|—-|___\s|\*\*\*\s)$/, type: this.type })];
		}
	}),
	Eh = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/,
	Oh = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g,
	Nh = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/,
	Dh = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g,
	vh = Me.create({
		name: 'italic',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: 'em' },
				{ tag: 'i', getAttrs: (t) => t.style.fontStyle !== 'normal' && null },
				{ style: 'font-style=normal', clearMark: (t) => t.type.name === this.name },
				{ style: 'font-style=italic' }
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['em', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setItalic:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleItalic:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetItalic:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name)
			};
		},
		addKeyboardShortcuts() {
			return {
				'Mod-i': () => this.editor.commands.toggleItalic(),
				'Mod-I': () => this.editor.commands.toggleItalic()
			};
		},
		addInputRules() {
			return [qt({ find: Eh, type: this.type }), qt({ find: Nh, type: this.type })];
		},
		addPasteRules() {
			return [Nt({ find: Oh, type: this.type }), Nt({ find: Dh, type: this.type })];
		}
	}),
	_h = q.create({
		name: 'listItem',
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: 'bulletList',
				orderedListTypeName: 'orderedList'
			};
		},
		content: 'paragraph block*',
		defining: !0,
		parseHTML() {
			return [{ tag: 'li' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['li', le(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
			};
		}
	}),
	Ih = 'listItem',
	Mi = 'textStyle',
	Ci = /^(\d+)\.\s$/,
	Lh = q.create({
		name: 'orderedList',
		addOptions() {
			return { itemTypeName: 'listItem', HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 };
		},
		group: 'block list',
		content() {
			return `${this.options.itemTypeName}+`;
		},
		addAttributes() {
			return {
				start: {
					default: 1,
					parseHTML: (t) =>
						t.hasAttribute('start') ? parseInt(t.getAttribute('start') || '', 10) : 1
				},
				type: { default: null, parseHTML: (t) => t.getAttribute('type') }
			};
		},
		parseHTML() {
			return [{ tag: 'ol' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			const { start: e, ...n } = t;
			return e === 1
				? ['ol', le(this.options.HTMLAttributes, n), 0]
				: ['ol', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleOrderedList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
									.updateAttributes(Ih, this.editor.getAttributes(Mi))
									.run()
							: t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Shift-7': () => this.editor.commands.toggleOrderedList() };
		},
		addInputRules() {
			let t = Ut({
				find: Ci,
				type: this.type,
				getAttributes: (e) => ({ start: +e[1] }),
				joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
			});
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Ut({
						find: Ci,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Mi) }),
						joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
						editor: this.editor
					})),
				[t]
			);
		}
	}),
	Ph = q.create({
		name: 'paragraph',
		priority: 1e3,
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: 'block',
		content: 'inline*',
		parseHTML() {
			return [{ tag: 'p' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['p', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setParagraph:
					() =>
					({ commands: t }) =>
						t.setNode(this.name)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Alt-0': () => this.editor.commands.setParagraph() };
		}
	}),
	Rh = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/,
	Bh = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g,
	zh = Me.create({
		name: 'strike',
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: 's' },
				{ tag: 'del' },
				{ tag: 'strike' },
				{
					style: 'text-decoration',
					consuming: !1,
					getAttrs: (t) => (t.includes('line-through') ? {} : !1)
				}
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['s', le(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setStrike:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleStrike:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetStrike:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Shift-s': () => this.editor.commands.toggleStrike() };
		},
		addInputRules() {
			return [qt({ find: Rh, type: this.type })];
		},
		addPasteRules() {
			return [Nt({ find: Bh, type: this.type })];
		}
	}),
	Hh = q.create({ name: 'text', group: 'inline' }),
	Vh = re.create({
		name: 'starterKit',
		addExtensions() {
			const t = [];
			return (
				this.options.bold !== !1 && t.push(Qp.configure(this.options.bold)),
				this.options.blockquote !== !1 && t.push(Kp.configure(this.options.blockquote)),
				this.options.bulletList !== !1 && t.push(Yp.configure(this.options.bulletList)),
				this.options.code !== !1 && t.push(eh.configure(this.options.code)),
				this.options.codeBlock !== !1 && t.push(rh.configure(this.options.codeBlock)),
				this.options.document !== !1 && t.push(ua.configure(this.options.document)),
				this.options.dropcursor !== !1 && t.push(ih.configure(this.options.dropcursor)),
				this.options.gapcursor !== !1 && t.push(hh.configure(this.options.gapcursor)),
				this.options.hardBreak !== !1 && t.push(mh.configure(this.options.hardBreak)),
				this.options.heading !== !1 && t.push(gh.configure(this.options.heading)),
				this.options.history !== !1 && t.push(wh.configure(this.options.history)),
				this.options.horizontalRule !== !1 && t.push(Ah.configure(this.options.horizontalRule)),
				this.options.italic !== !1 && t.push(vh.configure(this.options.italic)),
				this.options.listItem !== !1 && t.push(_h.configure(this.options.listItem)),
				this.options.orderedList !== !1 && t.push(Lh.configure(this.options.orderedList)),
				this.options.paragraph !== !1 && t.push(Ph.configure(this.options.paragraph)),
				this.options.strike !== !1 && t.push(zh.configure(this.options.strike)),
				this.options.text !== !1 && t.push(Hh.configure(this.options.text)),
				t
			);
		}
	}),
	Fh = (t) => te({ find: /--$/, replace: t ?? '—' }),
	jh = (t) => te({ find: /\.\.\.$/, replace: t ?? '…' }),
	Kh = (t) => te({ find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/, replace: t ?? '“' }),
	Wh = (t) => te({ find: /"$/, replace: t ?? '”' }),
	qh = (t) => te({ find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/, replace: t ?? '‘' }),
	Uh = (t) => te({ find: /'$/, replace: t ?? '’' }),
	Gh = (t) => te({ find: /<-$/, replace: t ?? '←' }),
	Qh = (t) => te({ find: /->$/, replace: t ?? '→' }),
	Jh = (t) => te({ find: /\(c\)$/, replace: t ?? '©' }),
	Yh = (t) => te({ find: /\(tm\)$/, replace: t ?? '™' }),
	Xh = (t) => te({ find: /\(sm\)$/, replace: t ?? '℠' }),
	Zh = (t) => te({ find: /\(r\)$/, replace: t ?? '®' }),
	em = (t) => te({ find: /(?:^|\s)(1\/2)\s$/, replace: t ?? '½' }),
	tm = (t) => te({ find: /\+\/-$/, replace: t ?? '±' }),
	nm = (t) => te({ find: /!=$/, replace: t ?? '≠' }),
	rm = (t) => te({ find: /<<$/, replace: t ?? '«' }),
	sm = (t) => te({ find: />>$/, replace: t ?? '»' }),
	om = (t) => te({ find: /\d+\s?([*x])\s?\d+$/, replace: t ?? '×' }),
	im = (t) => te({ find: /\^2$/, replace: t ?? '²' }),
	lm = (t) => te({ find: /\^3$/, replace: t ?? '³' }),
	am = (t) => te({ find: /(?:^|\s)(1\/4)\s$/, replace: t ?? '¼' }),
	cm = (t) => te({ find: /(?:^|\s)(3\/4)\s$/, replace: t ?? '¾' }),
	um = re.create({
		name: 'typography',
		addOptions() {
			return {
				closeDoubleQuote: '”',
				closeSingleQuote: '’',
				copyright: '©',
				ellipsis: '…',
				emDash: '—',
				laquo: '«',
				leftArrow: '←',
				multiplication: '×',
				notEqual: '≠',
				oneHalf: '½',
				oneQuarter: '¼',
				openDoubleQuote: '“',
				openSingleQuote: '‘',
				plusMinus: '±',
				raquo: '»',
				registeredTrademark: '®',
				rightArrow: '→',
				servicemark: '℠',
				superscriptThree: '³',
				superscriptTwo: '²',
				threeQuarters: '¾',
				trademark: '™'
			};
		},
		addInputRules() {
			const t = [];
			return (
				this.options.emDash !== !1 && t.push(Fh(this.options.emDash)),
				this.options.ellipsis !== !1 && t.push(jh(this.options.ellipsis)),
				this.options.openDoubleQuote !== !1 && t.push(Kh(this.options.openDoubleQuote)),
				this.options.closeDoubleQuote !== !1 && t.push(Wh(this.options.closeDoubleQuote)),
				this.options.openSingleQuote !== !1 && t.push(qh(this.options.openSingleQuote)),
				this.options.closeSingleQuote !== !1 && t.push(Uh(this.options.closeSingleQuote)),
				this.options.leftArrow !== !1 && t.push(Gh(this.options.leftArrow)),
				this.options.rightArrow !== !1 && t.push(Qh(this.options.rightArrow)),
				this.options.copyright !== !1 && t.push(Jh(this.options.copyright)),
				this.options.trademark !== !1 && t.push(Yh(this.options.trademark)),
				this.options.servicemark !== !1 && t.push(Xh(this.options.servicemark)),
				this.options.registeredTrademark !== !1 && t.push(Zh(this.options.registeredTrademark)),
				this.options.oneHalf !== !1 && t.push(em(this.options.oneHalf)),
				this.options.plusMinus !== !1 && t.push(tm(this.options.plusMinus)),
				this.options.notEqual !== !1 && t.push(nm(this.options.notEqual)),
				this.options.laquo !== !1 && t.push(rm(this.options.laquo)),
				this.options.raquo !== !1 && t.push(sm(this.options.raquo)),
				this.options.multiplication !== !1 && t.push(om(this.options.multiplication)),
				this.options.superscriptTwo !== !1 && t.push(im(this.options.superscriptTwo)),
				this.options.superscriptThree !== !1 && t.push(lm(this.options.superscriptThree)),
				this.options.oneQuarter !== !1 && t.push(am(this.options.oneQuarter)),
				this.options.threeQuarters !== !1 && t.push(cm(this.options.threeQuarters)),
				t
			);
		}
	}),
	dm = new Hs({
		nodes: {
			doc: { content: 'block+' },
			paragraph: {
				content: 'inline*',
				group: 'block',
				parseDOM: [{ tag: 'p' }],
				toDOM() {
					return ['p', 0];
				}
			},
			blockquote: {
				content: 'block+',
				group: 'block',
				parseDOM: [{ tag: 'blockquote' }],
				toDOM() {
					return ['blockquote', 0];
				}
			},
			horizontal_rule: {
				group: 'block',
				parseDOM: [{ tag: 'hr' }],
				toDOM() {
					return ['div', ['hr']];
				}
			},
			heading: {
				attrs: { level: { default: 1 } },
				content: '(text | image)*',
				group: 'block',
				defining: !0,
				parseDOM: [
					{ tag: 'h1', attrs: { level: 1 } },
					{ tag: 'h2', attrs: { level: 2 } },
					{ tag: 'h3', attrs: { level: 3 } },
					{ tag: 'h4', attrs: { level: 4 } },
					{ tag: 'h5', attrs: { level: 5 } },
					{ tag: 'h6', attrs: { level: 6 } }
				],
				toDOM(t) {
					return ['h' + t.attrs.level, 0];
				}
			},
			code_block: {
				content: 'text*',
				group: 'block',
				code: !0,
				defining: !0,
				marks: '',
				attrs: { params: { default: '' } },
				parseDOM: [
					{
						tag: 'pre',
						preserveWhitespace: 'full',
						getAttrs: (t) => ({ params: t.getAttribute('data-params') || '' })
					}
				],
				toDOM(t) {
					return ['pre', t.attrs.params ? { 'data-params': t.attrs.params } : {}, ['code', 0]];
				}
			},
			ordered_list: {
				content: 'list_item+',
				group: 'block',
				attrs: { order: { default: 1 }, tight: { default: !1 } },
				parseDOM: [
					{
						tag: 'ol',
						getAttrs(t) {
							return {
								order: t.hasAttribute('start') ? +t.getAttribute('start') : 1,
								tight: t.hasAttribute('data-tight')
							};
						}
					}
				],
				toDOM(t) {
					return [
						'ol',
						{
							start: t.attrs.order == 1 ? null : t.attrs.order,
							'data-tight': t.attrs.tight ? 'true' : null
						},
						0
					];
				}
			},
			bullet_list: {
				content: 'list_item+',
				group: 'block',
				attrs: { tight: { default: !1 } },
				parseDOM: [{ tag: 'ul', getAttrs: (t) => ({ tight: t.hasAttribute('data-tight') }) }],
				toDOM(t) {
					return ['ul', { 'data-tight': t.attrs.tight ? 'true' : null }, 0];
				}
			},
			list_item: {
				content: 'block+',
				defining: !0,
				parseDOM: [{ tag: 'li' }],
				toDOM() {
					return ['li', 0];
				}
			},
			text: { group: 'inline' },
			image: {
				inline: !0,
				attrs: { src: {}, alt: { default: null }, title: { default: null } },
				group: 'inline',
				draggable: !0,
				parseDOM: [
					{
						tag: 'img[src]',
						getAttrs(t) {
							return {
								src: t.getAttribute('src'),
								title: t.getAttribute('title'),
								alt: t.getAttribute('alt')
							};
						}
					}
				],
				toDOM(t) {
					return ['img', t.attrs];
				}
			},
			hard_break: {
				inline: !0,
				group: 'inline',
				selectable: !1,
				parseDOM: [{ tag: 'br' }],
				toDOM() {
					return ['br'];
				}
			}
		},
		marks: {
			em: {
				parseDOM: [
					{ tag: 'i' },
					{ tag: 'em' },
					{ style: 'font-style=italic' },
					{ style: 'font-style=normal', clearMark: (t) => t.type.name == 'em' }
				],
				toDOM() {
					return ['em'];
				}
			},
			strong: {
				parseDOM: [
					{ tag: 'strong' },
					{ tag: 'b', getAttrs: (t) => t.style.fontWeight != 'normal' && null },
					{ style: 'font-weight=400', clearMark: (t) => t.type.name == 'strong' },
					{ style: 'font-weight', getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
				],
				toDOM() {
					return ['strong'];
				}
			},
			link: {
				attrs: { href: {}, title: { default: null } },
				inclusive: !1,
				parseDOM: [
					{
						tag: 'a[href]',
						getAttrs(t) {
							return { href: t.getAttribute('href'), title: t.getAttribute('title') };
						}
					}
				],
				toDOM(t) {
					return ['a', t.attrs];
				}
			},
			code: {
				code: !0,
				parseDOM: [{ tag: 'code' }],
				toDOM() {
					return ['code'];
				}
			}
		}
	});
function fm(t, e) {
	if (t.isText && e.isText && Fn.sameSet(t.marks, e.marks)) return t.withText(t.text + e.text);
}
class pm {
	constructor(e, n) {
		(this.schema = e),
			(this.tokenHandlers = n),
			(this.stack = [{ type: e.topNodeType, attrs: null, content: [], marks: Fn.none }]);
	}
	top() {
		return this.stack[this.stack.length - 1];
	}
	push(e) {
		this.stack.length && this.top().content.push(e);
	}
	addText(e) {
		if (!e) return;
		let n = this.top(),
			r = n.content,
			s = r[r.length - 1],
			o = this.schema.text(e, n.marks),
			i;
		s && (i = fm(s, o)) ? (r[r.length - 1] = i) : r.push(o);
	}
	openMark(e) {
		let n = this.top();
		n.marks = e.addToSet(n.marks);
	}
	closeMark(e) {
		let n = this.top();
		n.marks = e.removeFromSet(n.marks);
	}
	parseTokens(e) {
		for (let n = 0; n < e.length; n++) {
			let r = e[n],
				s = this.tokenHandlers[r.type];
			if (!s) throw new Error('Token type `' + r.type + '` not supported by Markdown parser');
			s(this, r, e, n);
		}
	}
	addNode(e, n, r) {
		let s = this.top(),
			o = e.createAndFill(n, r, s ? s.marks : []);
		return o ? (this.push(o), o) : null;
	}
	openNode(e, n) {
		this.stack.push({ type: e, attrs: n, content: [], marks: Fn.none });
	}
	closeNode() {
		let e = this.stack.pop();
		return this.addNode(e.type, e.attrs, e.content);
	}
}
function tn(t, e, n, r) {
	return t.getAttrs ? t.getAttrs(e, n, r) : t.attrs instanceof Function ? t.attrs(e) : t.attrs;
}
function Xr(t, e) {
	return t.noCloseToken || e == 'code_inline' || e == 'code_block' || e == 'fence';
}
function Ti(t) {
	return t[t.length - 1] ==
		`
`
		? t.slice(0, t.length - 1)
		: t;
}
function Zr() {}
function hm(t, e) {
	let n = Object.create(null);
	for (let r in e) {
		let s = e[r];
		if (s.block) {
			let o = t.nodeType(s.block);
			Xr(s, r)
				? (n[r] = (i, l, a, c) => {
						i.openNode(o, tn(s, l, a, c)), i.addText(Ti(l.content)), i.closeNode();
					})
				: ((n[r + '_open'] = (i, l, a, c) => i.openNode(o, tn(s, l, a, c))),
					(n[r + '_close'] = (i) => i.closeNode()));
		} else if (s.node) {
			let o = t.nodeType(s.node);
			n[r] = (i, l, a, c) => i.addNode(o, tn(s, l, a, c));
		} else if (s.mark) {
			let o = t.marks[s.mark];
			Xr(s, r)
				? (n[r] = (i, l, a, c) => {
						i.openMark(o.create(tn(s, l, a, c))), i.addText(Ti(l.content)), i.closeMark(o);
					})
				: ((n[r + '_open'] = (i, l, a, c) => i.openMark(o.create(tn(s, l, a, c)))),
					(n[r + '_close'] = (i) => i.closeMark(o)));
		} else if (s.ignore) Xr(s, r) ? (n[r] = Zr) : ((n[r + '_open'] = Zr), (n[r + '_close'] = Zr));
		else throw new RangeError('Unrecognized parsing spec ' + JSON.stringify(s));
	}
	return (
		(n.text = (r, s) => r.addText(s.content)),
		(n.inline = (r, s) => r.parseTokens(s.children)),
		(n.softbreak = n.softbreak || ((r) => r.addText(' '))),
		n
	);
}
let mm = class {
	constructor(e, n, r) {
		(this.schema = e), (this.tokenizer = n), (this.tokens = r), (this.tokenHandlers = hm(e, r));
	}
	parse(e, n = {}) {
		let r = new pm(this.schema, this.tokenHandlers),
			s;
		r.parseTokens(this.tokenizer.parse(e, n));
		do s = r.closeNode();
		while (r.stack.length);
		return s || this.schema.topNodeType.createAndFill();
	}
};
function xi(t, e) {
	for (; ++e < t.length; ) if (t[e].type != 'list_item_open') return t[e].hidden;
	return !1;
}
new mm(dm, Vs('commonmark', { html: !1 }), {
	blockquote: { block: 'blockquote' },
	paragraph: { block: 'paragraph' },
	list_item: { block: 'list_item' },
	bullet_list: { block: 'bullet_list', getAttrs: (t, e, n) => ({ tight: xi(e, n) }) },
	ordered_list: {
		block: 'ordered_list',
		getAttrs: (t, e, n) => ({ order: +t.attrGet('start') || 1, tight: xi(e, n) })
	},
	heading: { block: 'heading', getAttrs: (t) => ({ level: +t.tag.slice(1) }) },
	code_block: { block: 'code_block', noCloseToken: !0 },
	fence: { block: 'code_block', getAttrs: (t) => ({ params: t.info || '' }), noCloseToken: !0 },
	hr: { node: 'horizontal_rule' },
	image: {
		node: 'image',
		getAttrs: (t) => ({
			src: t.attrGet('src'),
			title: t.attrGet('title') || null,
			alt: (t.children[0] && t.children[0].content) || null
		})
	},
	hardbreak: { node: 'hard_break' },
	em: { mark: 'em' },
	strong: { mark: 'strong' },
	link: {
		mark: 'link',
		getAttrs: (t) => ({ href: t.attrGet('href'), title: t.attrGet('title') || null })
	},
	code_inline: { mark: 'code', noCloseToken: !0 }
});
const gm = { open: '', close: '', mixable: !0 };
let bm = class {
	constructor(e, n, r = {}) {
		(this.nodes = e), (this.marks = n), (this.options = r);
	}
	serialize(e, n = {}) {
		n = Object.assign({}, this.options, n);
		let r = new ma(this.nodes, this.marks, n);
		return r.renderContent(e), r.out;
	}
};
const Ue = new bm(
	{
		blockquote(t, e) {
			t.wrapBlock('> ', null, e, () => t.renderContent(e));
		},
		code_block(t, e) {
			const n = e.textContent.match(/`{3,}/gm),
				r = n ? n.sort().slice(-1)[0] + '`' : '```';
			t.write(
				r +
					(e.attrs.params || '') +
					`
`
			),
				t.text(e.textContent, !1),
				t.write(`
`),
				t.write(r),
				t.closeBlock(e);
		},
		heading(t, e) {
			t.write(t.repeat('#', e.attrs.level) + ' '), t.renderInline(e, !1), t.closeBlock(e);
		},
		horizontal_rule(t, e) {
			t.write(e.attrs.markup || '---'), t.closeBlock(e);
		},
		bullet_list(t, e) {
			t.renderList(e, '  ', () => (e.attrs.bullet || '*') + ' ');
		},
		ordered_list(t, e) {
			let n = e.attrs.order || 1,
				r = String(n + e.childCount - 1).length,
				s = t.repeat(' ', r + 2);
			t.renderList(e, s, (o) => {
				let i = String(n + o);
				return t.repeat(' ', r - i.length) + i + '. ';
			});
		},
		list_item(t, e) {
			t.renderContent(e);
		},
		paragraph(t, e) {
			t.renderInline(e), t.closeBlock(e);
		},
		image(t, e) {
			t.write(
				'![' +
					t.esc(e.attrs.alt || '') +
					'](' +
					e.attrs.src.replace(/[\(\)]/g, '\\$&') +
					(e.attrs.title ? ' "' + e.attrs.title.replace(/"/g, '\\"') + '"' : '') +
					')'
			);
		},
		hard_break(t, e, n, r) {
			for (let s = r + 1; s < n.childCount; s++)
				if (n.child(s).type != e.type) {
					t.write(`\\
`);
					return;
				}
		},
		text(t, e) {
			t.text(e.text, !t.inAutolink);
		}
	},
	{
		em: { open: '*', close: '*', mixable: !0, expelEnclosingWhitespace: !0 },
		strong: { open: '**', close: '**', mixable: !0, expelEnclosingWhitespace: !0 },
		link: {
			open(t, e, n, r) {
				return (t.inAutolink = km(e, n, r)), t.inAutolink ? '<' : '[';
			},
			close(t, e, n, r) {
				let { inAutolink: s } = t;
				return (
					(t.inAutolink = void 0),
					s
						? '>'
						: '](' +
							e.attrs.href.replace(/[\(\)"]/g, '\\$&') +
							(e.attrs.title ? ` "${e.attrs.title.replace(/"/g, '\\"')}"` : '') +
							')'
				);
			},
			mixable: !0
		},
		code: {
			open(t, e, n, r) {
				return wi(n.child(r), -1);
			},
			close(t, e, n, r) {
				return wi(n.child(r - 1), 1);
			},
			escape: !1
		}
	}
);
function wi(t, e) {
	let n = /`+/g,
		r,
		s = 0;
	if (t.isText) for (; (r = n.exec(t.text)); ) s = Math.max(s, r[0].length);
	let o = s > 0 && e > 0 ? ' `' : '`';
	for (let i = 0; i < s; i++) o += '`';
	return s > 0 && e < 0 && (o += ' '), o;
}
function km(t, e, n) {
	if (t.attrs.title || !/^\w+:/.test(t.attrs.href)) return !1;
	let r = e.child(n);
	return !r.isText || r.text != t.attrs.href || r.marks[r.marks.length - 1] != t
		? !1
		: n == e.childCount - 1 || !t.isInSet(e.child(n + 1).marks);
}
let ma = class {
	constructor(e, n, r) {
		(this.nodes = e),
			(this.marks = n),
			(this.options = r),
			(this.delim = ''),
			(this.out = ''),
			(this.closed = null),
			(this.inAutolink = void 0),
			(this.atBlockStart = !1),
			(this.inTightList = !1),
			typeof this.options.tightLists > 'u' && (this.options.tightLists = !1),
			typeof this.options.hardBreakNodeName > 'u' &&
				(this.options.hardBreakNodeName = 'hard_break');
	}
	flushClose(e = 2) {
		if (this.closed) {
			if (
				(this.atBlank() ||
					(this.out += `
`),
				e > 1)
			) {
				let n = this.delim,
					r = /\s+$/.exec(n);
				r && (n = n.slice(0, n.length - r[0].length));
				for (let s = 1; s < e; s++)
					this.out +=
						n +
						`
`;
			}
			this.closed = null;
		}
	}
	getMark(e) {
		let n = this.marks[e];
		if (!n) {
			if (this.options.strict !== !1)
				throw new Error(`Mark type \`${e}\` not supported by Markdown renderer`);
			n = gm;
		}
		return n;
	}
	wrapBlock(e, n, r, s) {
		let o = this.delim;
		this.write(n ?? e), (this.delim += e), s(), (this.delim = o), this.closeBlock(r);
	}
	atBlank() {
		return /(^|\n)$/.test(this.out);
	}
	ensureNewLine() {
		this.atBlank() ||
			(this.out += `
`);
	}
	write(e) {
		this.flushClose(),
			this.delim && this.atBlank() && (this.out += this.delim),
			e && (this.out += e);
	}
	closeBlock(e) {
		this.closed = e;
	}
	text(e, n = !0) {
		let r = e.split(`
`);
		for (let s = 0; s < r.length; s++)
			this.write(),
				!n &&
					r[s][0] == '[' &&
					/(^|[^\\])\!$/.test(this.out) &&
					(this.out = this.out.slice(0, this.out.length - 1) + '\\!'),
				(this.out += n ? this.esc(r[s], this.atBlockStart) : r[s]),
				s != r.length - 1 &&
					(this.out += `
`);
	}
	render(e, n, r) {
		if (this.nodes[e.type.name]) this.nodes[e.type.name](this, e, n, r);
		else {
			if (this.options.strict !== !1)
				throw new Error('Token type `' + e.type.name + '` not supported by Markdown renderer');
			e.type.isLeaf ||
				(e.type.inlineContent ? this.renderInline(e) : this.renderContent(e),
				e.isBlock && this.closeBlock(e));
		}
	}
	renderContent(e) {
		e.forEach((n, r, s) => this.render(n, e, s));
	}
	renderInline(e, n = !0) {
		this.atBlockStart = n;
		let r = [],
			s = '',
			o = (i, l, a) => {
				let c = i ? i.marks : [];
				i &&
					i.type.name === this.options.hardBreakNodeName &&
					(c = c.filter((g) => {
						if (a + 1 == e.childCount) return !1;
						let m = e.child(a + 1);
						return g.isInSet(m.marks) && (!m.isText || /\S/.test(m.text));
					}));
				let u = s;
				if (
					((s = ''),
					i &&
						i.isText &&
						c.some((g) => {
							let m = this.getMark(g.type.name);
							return m && m.expelEnclosingWhitespace && !g.isInSet(r);
						}))
				) {
					let [g, m, b] = /^(\s*)(.*)$/m.exec(i.text);
					m && ((u += m), (i = b ? i.withText(b) : null), i || (c = r));
				}
				if (
					i &&
					i.isText &&
					c.some((g) => {
						let m = this.getMark(g.type.name);
						return (
							m &&
							m.expelEnclosingWhitespace &&
							(a == e.childCount - 1 || !g.isInSet(e.child(a + 1).marks))
						);
					})
				) {
					let [g, m, b] = /^(.*?)(\s*)$/m.exec(i.text);
					b && ((s = b), (i = m ? i.withText(m) : null), i || (c = r));
				}
				let d = c.length ? c[c.length - 1] : null,
					f = d && this.getMark(d.type.name).escape === !1,
					p = c.length - (f ? 1 : 0);
				e: for (let g = 0; g < p; g++) {
					let m = c[g];
					if (!this.getMark(m.type.name).mixable) break;
					for (let b = 0; b < r.length; b++) {
						let k = r[b];
						if (!this.getMark(k.type.name).mixable) break;
						if (m.eq(k)) {
							g > b
								? (c = c
										.slice(0, b)
										.concat(m)
										.concat(c.slice(b, g))
										.concat(c.slice(g + 1, p)))
								: b > g &&
									(c = c
										.slice(0, g)
										.concat(c.slice(g + 1, b))
										.concat(m)
										.concat(c.slice(b, p)));
							continue e;
						}
					}
				}
				let h = 0;
				for (; h < Math.min(r.length, p) && c[h].eq(r[h]); ) ++h;
				for (; h < r.length; ) this.text(this.markString(r.pop(), !1, e, a), !1);
				if ((u && this.text(u), i)) {
					for (; r.length < p; ) {
						let g = c[r.length];
						r.push(g), this.text(this.markString(g, !0, e, a), !1), (this.atBlockStart = !1);
					}
					f && i.isText
						? this.text(
								this.markString(d, !0, e, a) + i.text + this.markString(d, !1, e, a + 1),
								!1
							)
						: this.render(i, e, a),
						(this.atBlockStart = !1);
				}
				i != null && i.isText && i.nodeSize > 0 && (this.atBlockStart = !1);
			};
		e.forEach(o), o(null, 0, e.childCount), (this.atBlockStart = !1);
	}
	renderList(e, n, r) {
		this.closed && this.closed.type == e.type
			? this.flushClose(3)
			: this.inTightList && this.flushClose(1);
		let s = typeof e.attrs.tight < 'u' ? e.attrs.tight : this.options.tightLists,
			o = this.inTightList;
		(this.inTightList = s),
			e.forEach((i, l, a) => {
				a && s && this.flushClose(1), this.wrapBlock(n, r(a), e, () => this.render(i, e, a));
			}),
			(this.inTightList = o);
	}
	esc(e, n = !1) {
		return (
			(e = e.replace(/[`*\\~\[\]_]/g, (r, s) =>
				r == '_' && s > 0 && s + 1 < e.length && e[s - 1].match(/\w/) && e[s + 1].match(/\w/)
					? r
					: '\\' + r
			)),
			n &&
				(e = e
					.replace(/^(\+[ ]|[\-*>])/, '\\$&')
					.replace(/^(\s*)(#{1,6})(\s|$)/, '$1\\$2$3')
					.replace(/^(\s*\d+)\.\s/, '$1\\. ')),
			this.options.escapeExtraCharacters &&
				(e = e.replace(this.options.escapeExtraCharacters, '\\$&')),
			e
		);
	}
	quote(e) {
		let n = e.indexOf('"') == -1 ? '""' : e.indexOf("'") == -1 ? "''" : '()';
		return n[0] + e + n[1];
	}
	repeat(e, n) {
		let r = '';
		for (let s = 0; s < n; s++) r += e;
		return r;
	}
	markString(e, n, r, s) {
		let o = this.getMark(e.type.name),
			i = n ? o.open : o.close;
		return typeof i == 'string' ? i : i(this, e, r, s);
	}
	getEnclosingWhitespace(e) {
		return {
			leading: (e.match(/^(\s+)/) || [void 0])[0],
			trailing: (e.match(/(\s+)$/) || [void 0])[0]
		};
	}
};
function ym(t) {
	return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t;
}
var ws = !0,
	ga = !1,
	ba = !1,
	$m = function (t, e) {
		e && ((ws = !e.enabled), (ga = !!e.label), (ba = !!e.labelAfter)),
			t.core.ruler.after('inline', 'github-task-lists', function (n) {
				for (var r = n.tokens, s = 2; s < r.length; s++)
					Mm(r, s) &&
						(Cm(r[s], n.Token),
						Ai(r[s - 2], 'class', 'task-list-item' + (ws ? '' : ' enabled')),
						Ai(r[Sm(r, s - 2)], 'class', 'contains-task-list'));
			});
	};
function Ai(t, e, n) {
	var r = t.attrIndex(e),
		s = [e, n];
	r < 0 ? t.attrPush(s) : (t.attrs[r] = s);
}
function Sm(t, e) {
	for (var n = t[e].level - 1, r = e - 1; r >= 0; r--) if (t[r].level === n) return r;
	return -1;
}
function Mm(t, e) {
	return Em(t[e]) && Om(t[e - 1]) && Nm(t[e - 2]) && Dm(t[e]);
}
function Cm(t, e) {
	if (
		(t.children.unshift(Tm(t, e)),
		(t.children[1].content = t.children[1].content.slice(3)),
		(t.content = t.content.slice(3)),
		ga)
	)
		if (ba) {
			t.children.pop();
			var n = 'task-item-' + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
			(t.children[0].content = t.children[0].content.slice(0, -1) + ' id="' + n + '">'),
				t.children.push(Am(t.content, n, e));
		} else t.children.unshift(xm(e)), t.children.push(wm(e));
}
function Tm(t, e) {
	var n = new e('html_inline', '', 0),
		r = ws ? ' disabled="" ' : '';
	return (
		t.content.indexOf('[ ] ') === 0
			? (n.content = '<input class="task-list-item-checkbox"' + r + 'type="checkbox">')
			: (t.content.indexOf('[x] ') === 0 || t.content.indexOf('[X] ') === 0) &&
				(n.content = '<input class="task-list-item-checkbox" checked=""' + r + 'type="checkbox">'),
		n
	);
}
function xm(t) {
	var e = new t('html_inline', '', 0);
	return (e.content = '<label>'), e;
}
function wm(t) {
	var e = new t('html_inline', '', 0);
	return (e.content = '</label>'), e;
}
function Am(t, e, n) {
	var r = new n('html_inline', '', 0);
	return (
		(r.content = '<label class="task-list-item-label" for="' + e + '">' + t + '</label>'),
		(r.attrs = [{ for: e }]),
		r
	);
}
function Em(t) {
	return t.type === 'inline';
}
function Om(t) {
	return t.type === 'paragraph_open';
}
function Nm(t) {
	return t.type === 'list_item_open';
}
function Dm(t) {
	return (
		t.content.indexOf('[ ] ') === 0 ||
		t.content.indexOf('[x] ') === 0 ||
		t.content.indexOf('[X] ') === 0
	);
}
const vm = ym($m);
var _m = Object.defineProperty,
	Im = (t, e, n) =>
		e in t ? _m(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n),
	Yn = (t, e, n) => (Im(t, typeof e != 'symbol' ? e + '' : e, n), n);
const Lm = re.create({
		name: 'markdownTightLists',
		addOptions: () => ({
			tight: !0,
			tightClass: 'tight',
			listTypes: ['bulletList', 'orderedList']
		}),
		addGlobalAttributes() {
			return [
				{
					types: this.options.listTypes,
					attributes: {
						tight: {
							default: this.options.tight,
							parseHTML: (t) => t.getAttribute('data-tight') === 'true' || !t.querySelector('p'),
							renderHTML: (t) => ({
								class: t.tight ? this.options.tightClass : null,
								'data-tight': t.tight ? 'true' : null
							})
						}
					}
				}
			];
		},
		addCommands() {
			var t = this;
			return {
				toggleTight: function () {
					let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
					return (n) => {
						let { editor: r, commands: s } = n;
						function o(i) {
							if (!r.isActive(i)) return !1;
							const l = r.getAttributes(i);
							return s.updateAttributes(i, { tight: e ?? !(l != null && l.tight) });
						}
						return t.options.listTypes.some((i) => o(i));
					};
				}
			};
		}
	}),
	Ei = Vs();
function ka(t, e) {
	return (
		Ei.inline.State.prototype.scanDelims.call({ src: t, posMax: t.length }),
		new Ei.inline.State(t, null, null, []).scanDelims(e, !0)
	);
}
function ya(t, e, n, r) {
	let s = t.substring(0, n) + t.substring(n + e.length);
	return (s = s.substring(0, n + r) + e + s.substring(n + r)), s;
}
function Pm(t, e, n, r) {
	let s = n,
		o = t;
	for (; s < r && !ka(o, s).can_open; ) (o = ya(o, e, s, 1)), s++;
	return { text: o, from: s, to: r };
}
function Rm(t, e, n, r) {
	let s = r,
		o = t;
	for (; s > n && !ka(o, s).can_close; ) (o = ya(o, e, s, -1)), s--;
	return { text: o, from: n, to: s };
}
function Bm(t, e, n, r) {
	let s = { text: t, from: n, to: r };
	return (
		(s = Pm(s.text, e, s.from, s.to)),
		(s = Rm(s.text, e, s.from, s.to)),
		s.to - s.from < e.length + 1 &&
			(s.text = s.text.substring(0, s.from) + s.text.substring(s.to + e.length)),
		s.text
	);
}
class zm extends ma {
	constructor(e, n, r) {
		super(e, n, r ?? {}), Yn(this, 'inTable', !1), (this.inlines = []);
	}
	render(e, n, r) {
		super.render(e, n, r);
		const s = this.inlines[this.inlines.length - 1];
		if (s != null && s.start && s !== null && s !== void 0 && s.end) {
			const { delimiter: o, start: i, end: l } = this.normalizeInline(s);
			(this.out = Bm(this.out, o, i, l)), this.inlines.pop();
		}
	}
	markString(e, n, r, s) {
		const o = this.marks[e.type.name];
		if (o.expelEnclosingWhitespace)
			if (n) this.inlines.push({ start: this.out.length, delimiter: o.open });
			else {
				const i = this.inlines.pop();
				this.inlines.push({ ...i, end: this.out.length });
			}
		return super.markString(e, n, r, s);
	}
	normalizeInline(e) {
		let { start: n, end: r } = e;
		for (; this.out.charAt(n).match(/\s/); ) n++;
		return { ...e, start: n };
	}
}
const $a = Me.create({
	name: 'markdownHTMLMark',
	addStorage() {
		return {
			markdown: {
				serialize: {
					open(t, e) {
						var n, r;
						return this.editor.storage.markdown.options.html
							? (n = (r = Oi(e)) === null || r === void 0 ? void 0 : r[0]) !== null && n !== void 0
								? n
								: ''
							: (console.warn(
									`Tiptap Markdown: "${e.type.name}" mark is only available in html mode`
								),
								'');
					},
					close(t, e) {
						var n, r;
						return this.editor.storage.markdown.options.html &&
							(n = (r = Oi(e)) === null || r === void 0 ? void 0 : r[1]) !== null &&
							n !== void 0
							? n
							: '';
					}
				},
				parse: {}
			}
		};
	}
});
function Oi(t) {
	const e = t.type.schema,
		n = e.text(' ', [t]),
		s = Tn(L.from(n), e).match(/^(<.*?>) (<\/.*?>)$/);
	return s ? [s[1], s[2]] : null;
}
function co(t) {
	const e = `<body>${t}</body>`;
	return new window.DOMParser().parseFromString(e, 'text/html').body;
}
function Hm(t) {
	return t == null ? void 0 : t.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function Vm(t) {
	const e = t.parentElement,
		n = e.cloneNode();
	for (; e.firstChild && e.firstChild !== t; ) n.appendChild(e.firstChild);
	n.childNodes.length > 0 && e.parentElement.insertBefore(n, e),
		e.parentElement.insertBefore(t, e),
		e.childNodes.length === 0 && e.remove();
}
function Fm(t) {
	const e = t.parentNode;
	for (; t.firstChild; ) e.insertBefore(t.firstChild, t);
	e.removeChild(t);
}
const Rr = q.create({
	name: 'markdownHTMLNode',
	addStorage() {
		return {
			markdown: {
				serialize(t, e, n) {
					this.editor.storage.markdown.options.html
						? t.write(jm(e, n))
						: (console.warn(
								`Tiptap Markdown: "${e.type.name}" node is only available in html mode`
							),
							t.write(`[${e.type.name}]`)),
						e.isBlock && t.closeBlock(e);
				},
				parse: {}
			}
		};
	}
});
function jm(t, e) {
	const n = t.type.schema,
		r = Tn(L.from(t), n);
	return t.isBlock && (e instanceof L || e.type.name === n.topNodeType.name) ? Km(r) : r;
}
function Km(t) {
	const n = co(t).firstElementChild;
	return (
		(n.innerHTML = n.innerHTML.trim()
			? `
${n.innerHTML}
`
			: `
`),
		n.outerHTML
	);
}
const Wm = q.create({ name: 'blockquote' }),
	qm = Wm.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.blockquote, parse: {} } };
		}
	}),
	Um = q.create({ name: 'bulletList' }),
	Sa = Um.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e) {
						return t.renderList(
							e,
							'  ',
							() => (this.editor.storage.markdown.options.bulletListMarker || '-') + ' '
						);
					},
					parse: {}
				}
			};
		}
	}),
	Gm = q.create({ name: 'codeBlock' }),
	Qm = Gm.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e) {
						t.write(
							'```' +
								(e.attrs.language || '') +
								`
`
						),
							t.text(e.textContent, !1),
							t.ensureNewLine(),
							t.write('```'),
							t.closeBlock(e);
					},
					parse: {
						setup(t) {
							var e;
							t.set({
								langPrefix:
									(e = this.options.languageClassPrefix) !== null && e !== void 0 ? e : 'language-'
							});
						},
						updateDOM(t) {
							t.innerHTML = t.innerHTML.replace(/\n<\/code><\/pre>/g, '</code></pre>');
						}
					}
				}
			};
		}
	}),
	Jm = q.create({ name: 'hardBreak' }),
	Ma = Jm.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e, n, r) {
						for (let s = r + 1; s < n.childCount; s++)
							if (n.child(s).type != e.type) {
								t.write(
									t.inTable
										? Rr.storage.markdown.serialize.call(this, t, e, n)
										: `\\
`
								);
								return;
							}
					},
					parse: {}
				}
			};
		}
	}),
	Ym = q.create({ name: 'heading' }),
	Xm = Ym.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.heading, parse: {} } };
		}
	}),
	Zm = q.create({ name: 'horizontalRule' }),
	eg = Zm.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.horizontal_rule, parse: {} } };
		}
	}),
	tg = q.create({ name: 'image' }),
	ng = tg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.image, parse: {} } };
		}
	}),
	rg = q.create({ name: 'listItem' }),
	sg = rg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.list_item, parse: {} } };
		}
	}),
	og = q.create({ name: 'orderedList' });
function ig(t, e, n) {
	let r = 0;
	for (; n - r > 0 && e.child(n - r - 1).type.name === t.type.name; r++);
	return r;
}
const lg = og.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e, n, r) {
						const s = e.attrs.start || 1,
							o = String(s + e.childCount - 1).length,
							i = t.repeat(' ', o + 2),
							a = ig(e, n, r) % 2 ? ') ' : '. ';
						t.renderList(e, i, (c) => {
							const u = String(s + c);
							return t.repeat(' ', o - u.length) + u + a;
						});
					},
					parse: {}
				}
			};
		}
	}),
	ag = q.create({ name: 'paragraph' }),
	cg = ag.extend({
		addStorage() {
			return { markdown: { serialize: Ue.nodes.paragraph, parse: {} } };
		}
	});
function es(t) {
	var e, n;
	return (e = t == null || (n = t.content) === null || n === void 0 ? void 0 : n.content) !==
		null && e !== void 0
		? e
		: [];
}
const ug = q.create({ name: 'table' }),
	dg = ug.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e, n) {
						if (!fg(e)) {
							Rr.storage.markdown.serialize.call(this, t, e, n);
							return;
						}
						(t.inTable = !0),
							e.forEach((r, s, o) => {
								if (
									(t.write('| '),
									r.forEach((i, l, a) => {
										a && t.write(' | ');
										const c = i.firstChild;
										c.textContent.trim() && t.renderInline(c);
									}),
									t.write(' |'),
									t.ensureNewLine(),
									!o)
								) {
									const i = Array.from({ length: r.childCount })
										.map(() => '---')
										.join(' | ');
									t.write(`| ${i} |`), t.ensureNewLine();
								}
							}),
							t.closeBlock(e),
							(t.inTable = !1);
					},
					parse: {}
				}
			};
		}
	});
function Ni(t) {
	return t.attrs.colspan > 1 || t.attrs.rowspan > 1;
}
function fg(t) {
	const e = es(t),
		n = e[0],
		r = e.slice(1);
	return !(
		es(n).some((s) => s.type.name !== 'tableHeader' || Ni(s) || s.childCount > 1) ||
		r.some((s) => es(s).some((o) => o.type.name === 'tableHeader' || Ni(o) || o.childCount > 1))
	);
}
const pg = q.create({ name: 'taskItem' }),
	hg = pg.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e) {
						const n = e.attrs.checked ? '[x]' : '[ ]';
						t.write(`${n} `), t.renderContent(e);
					},
					parse: {
						updateDOM(t) {
							[...t.querySelectorAll('.task-list-item')].forEach((e) => {
								const n = e.querySelector('input');
								e.setAttribute('data-type', 'taskItem'),
									n && (e.setAttribute('data-checked', n.checked), n.remove());
							});
						}
					}
				}
			};
		}
	}),
	mg = q.create({ name: 'taskList' }),
	gg = mg.extend({
		addStorage() {
			return {
				markdown: {
					serialize: Sa.storage.markdown.serialize,
					parse: {
						setup(t) {
							t.use(vm);
						},
						updateDOM(t) {
							[...t.querySelectorAll('.contains-task-list')].forEach((e) => {
								e.setAttribute('data-type', 'taskList');
							});
						}
					}
				}
			};
		}
	}),
	bg = q.create({ name: 'text' }),
	kg = bg.extend({
		addStorage() {
			return {
				markdown: {
					serialize(t, e) {
						t.text(Hm(e.text));
					},
					parse: {}
				}
			};
		}
	}),
	yg = Me.create({ name: 'bold' }),
	$g = yg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.marks.strong, parse: {} } };
		}
	}),
	Sg = Me.create({ name: 'code' }),
	Mg = Sg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.marks.code, parse: {} } };
		}
	}),
	Cg = Me.create({ name: 'italic' }),
	Tg = Cg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.marks.em, parse: {} } };
		}
	}),
	xg = Me.create({ name: 'link' }),
	wg = xg.extend({
		addStorage() {
			return { markdown: { serialize: Ue.marks.link, parse: {} } };
		}
	}),
	Ag = Me.create({ name: 'strike' }),
	Eg = Ag.extend({
		addStorage() {
			return {
				markdown: {
					serialize: { open: '~~', close: '~~', expelEnclosingWhitespace: !0 },
					parse: {}
				}
			};
		}
	}),
	Og = [qm, Sa, Qm, Ma, Xm, eg, Rr, ng, sg, lg, cg, dg, hg, gg, kg, $g, Mg, $a, Tg, wg, Eg];
function Xn(t) {
	var e, n;
	const r = (e = t.storage) === null || e === void 0 ? void 0 : e.markdown,
		s =
			(n = Og.find((o) => o.name === t.name)) === null || n === void 0
				? void 0
				: n.storage.markdown;
	return r || s ? { ...s, ...r } : null;
}
class Ng {
	constructor(e) {
		Yn(this, 'editor', null), (this.editor = e);
	}
	serialize(e) {
		const n = new zm(this.nodes, this.marks, { hardBreakNodeName: Ma.name });
		return n.renderContent(e), n.out;
	}
	get nodes() {
		var e;
		return {
			...Object.fromEntries(
				Object.keys(this.editor.schema.nodes).map((n) => [n, this.serializeNode(Rr)])
			),
			...Object.fromEntries(
				(e = this.editor.extensionManager.extensions
					.filter((n) => n.type === 'node' && this.serializeNode(n))
					.map((n) => [n.name, this.serializeNode(n)])) !== null && e !== void 0
					? e
					: []
			)
		};
	}
	get marks() {
		var e;
		return {
			...Object.fromEntries(
				Object.keys(this.editor.schema.marks).map((n) => [n, this.serializeMark($a)])
			),
			...Object.fromEntries(
				(e = this.editor.extensionManager.extensions
					.filter((n) => n.type === 'mark' && this.serializeMark(n))
					.map((n) => [n.name, this.serializeMark(n)])) !== null && e !== void 0
					? e
					: []
			)
		};
	}
	serializeNode(e) {
		var n;
		return (n = Xn(e)) === null || n === void 0 || (n = n.serialize) === null || n === void 0
			? void 0
			: n.bind({ editor: this.editor, options: e.options });
	}
	serializeMark(e) {
		var n;
		const r = (n = Xn(e)) === null || n === void 0 ? void 0 : n.serialize;
		return r
			? {
					...r,
					open:
						typeof r.open == 'function'
							? r.open.bind({ editor: this.editor, options: e.options })
							: r.open,
					close:
						typeof r.close == 'function'
							? r.close.bind({ editor: this.editor, options: e.options })
							: r.close
				}
			: null;
	}
}
class Dg {
	constructor(e, n) {
		Yn(this, 'editor', null), Yn(this, 'md', null);
		let { html: r, linkify: s, breaks: o } = n;
		(this.editor = e), (this.md = this.withPatchedRenderer(Vs({ html: r, linkify: s, breaks: o })));
	}
	parse(e) {
		let { inline: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		if (typeof e == 'string') {
			this.editor.extensionManager.extensions.forEach((o) => {
				var i;
				return (i = Xn(o)) === null ||
					i === void 0 ||
					(i = i.parse) === null ||
					i === void 0 ||
					(i = i.setup) === null ||
					i === void 0
					? void 0
					: i.call({ editor: this.editor, options: o.options }, this.md);
			});
			const r = this.md.render(e),
				s = co(r);
			return (
				this.editor.extensionManager.extensions.forEach((o) => {
					var i;
					return (i = Xn(o)) === null ||
						i === void 0 ||
						(i = i.parse) === null ||
						i === void 0 ||
						(i = i.updateDOM) === null ||
						i === void 0
						? void 0
						: i.call({ editor: this.editor, options: o.options }, s);
				}),
				this.normalizeDOM(s, { inline: n, content: e }),
				s.innerHTML
			);
		}
		return e;
	}
	normalizeDOM(e, n) {
		let { inline: r, content: s } = n;
		return (
			this.normalizeBlocks(e),
			e.querySelectorAll('*').forEach((o) => {
				var i;
				((i = o.nextSibling) === null || i === void 0 ? void 0 : i.nodeType) === Node.TEXT_NODE &&
					!o.closest('pre') &&
					(o.nextSibling.textContent = o.nextSibling.textContent.replace(/^\n/, ''));
			}),
			r && this.normalizeInline(e, s),
			e
		);
	}
	normalizeBlocks(e) {
		const r = Object.values(this.editor.schema.nodes)
			.filter((s) => s.isBlock)
			.map((s) => {
				var o;
				return (o = s.spec.parseDOM) === null || o === void 0 ? void 0 : o.map((i) => i.tag);
			})
			.flat()
			.filter(Boolean)
			.join(',');
		r &&
			[...e.querySelectorAll(r)].forEach((s) => {
				s.parentElement.matches('p') && Vm(s);
			});
	}
	normalizeInline(e, n) {
		var r;
		if ((r = e.firstElementChild) !== null && r !== void 0 && r.matches('p')) {
			var s, o, i, l;
			const a = e.firstElementChild,
				{ nextElementSibling: c } = a,
				u =
					(s = (o = n.match(/^\s+/)) === null || o === void 0 ? void 0 : o[0]) !== null &&
					s !== void 0
						? s
						: '',
				d = c
					? ''
					: (i = (l = n.match(/\s+$/)) === null || l === void 0 ? void 0 : l[0]) !== null &&
						  i !== void 0
						? i
						: '';
			if (n.match(/^\n\n/)) {
				a.innerHTML = `${a.innerHTML}${d}`;
				return;
			}
			Fm(a), (e.innerHTML = `${u}${e.innerHTML}${d}`);
		}
	}
	withPatchedRenderer(e) {
		const n = (r) =>
			function () {
				const s = r(...arguments);
				return s ===
					`
`
					? s
					: s[s.length - 1] ===
						  `
`
						? s.slice(0, -1)
						: s;
			};
		return (
			(e.renderer.rules.hardbreak = n(e.renderer.rules.hardbreak)),
			(e.renderer.rules.softbreak = n(e.renderer.rules.softbreak)),
			(e.renderer.rules.fence = n(e.renderer.rules.fence)),
			(e.renderer.rules.code_block = n(e.renderer.rules.code_block)),
			(e.renderer.renderToken = n(e.renderer.renderToken.bind(e.renderer))),
			e
		);
	}
}
const vg = re.create({
		name: 'markdownClipboard',
		addOptions() {
			return { transformPastedText: !1, transformCopiedText: !1 };
		},
		addProseMirrorPlugins() {
			return [
				new ie({
					key: new me('markdownClipboard'),
					props: {
						clipboardTextParser: (t, e, n) => {
							if (n || !this.options.transformPastedText) return null;
							const r = this.editor.storage.markdown.parser.parse(t, { inline: !0 });
							return zt
								.fromSchema(this.editor.schema)
								.parseSlice(co(r), { preserveWhitespace: !0, context: e });
						},
						clipboardTextSerializer: (t) =>
							this.options.transformCopiedText
								? this.editor.storage.markdown.serializer.serialize(t.content)
								: null
					}
				})
			];
		}
	}),
	_g = re.create({
		name: 'markdown',
		priority: 50,
		addOptions() {
			return {
				html: !0,
				tightLists: !0,
				tightListClass: 'tight',
				bulletListMarker: '-',
				linkify: !1,
				breaks: !1,
				transformPastedText: !1,
				transformCopiedText: !1
			};
		},
		addCommands() {
			const t = Bp.Commands.config.addCommands();
			return {
				setContent: (e, n, r) => (s) =>
					t.setContent(s.editor.storage.markdown.parser.parse(e), n, r)(s),
				insertContentAt: (e, n, r) => (s) =>
					t.insertContentAt(e, s.editor.storage.markdown.parser.parse(n, { inline: !0 }), r)(s)
			};
		},
		onBeforeCreate() {
			(this.editor.storage.markdown = {
				options: { ...this.options },
				parser: new Dg(this.editor, this.options),
				serializer: new Ng(this.editor),
				getMarkdown: () => this.editor.storage.markdown.serializer.serialize(this.editor.state.doc)
			}),
				(this.editor.options.initialContent = this.editor.options.content),
				(this.editor.options.content = this.editor.storage.markdown.parser.parse(
					this.editor.options.content
				));
		},
		onCreate() {
			(this.editor.options.content = this.editor.options.initialContent),
				delete this.editor.options.initialContent;
		},
		addStorage() {
			return {};
		},
		addExtensions() {
			return [
				Lm.configure({ tight: this.options.tightLists, tightClass: this.options.tightListClass }),
				vg.configure({
					transformPastedText: this.options.transformPastedText,
					transformCopiedText: this.options.transformCopiedText
				})
			];
		}
	}),
	Ig = q.create({
		name: 'taskList',
		addOptions() {
			return { itemTypeName: 'taskItem', HTMLAttributes: {} };
		},
		group: 'block list',
		content() {
			return `${this.options.itemTypeName}+`;
		},
		parseHTML() {
			return [{ tag: `ul[data-type="${this.name}"]`, priority: 51 }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ['ul', le(this.options.HTMLAttributes, t, { 'data-type': this.name }), 0];
		},
		addCommands() {
			return {
				toggleTaskList:
					() =>
					({ commands: t }) =>
						t.toggleList(this.name, this.options.itemTypeName)
			};
		},
		addKeyboardShortcuts() {
			return { 'Mod-Shift-9': () => this.editor.commands.toggleTaskList() };
		}
	}),
	Lg = /^\s*(\[([( |x])?\])\s$/,
	Pg = q.create({
		name: 'taskItem',
		addOptions() {
			return { nested: !1, HTMLAttributes: {}, taskListTypeName: 'taskList' };
		},
		content() {
			return this.options.nested ? 'paragraph block*' : 'paragraph+';
		},
		defining: !0,
		addAttributes() {
			return {
				checked: {
					default: !1,
					keepOnSplit: !1,
					parseHTML: (t) => {
						const e = t.getAttribute('data-checked');
						return e === '' || e === 'true';
					},
					renderHTML: (t) => ({ 'data-checked': t.checked })
				}
			};
		},
		parseHTML() {
			return [{ tag: `li[data-type="${this.name}"]`, priority: 51 }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				'li',
				le(this.options.HTMLAttributes, e, { 'data-type': this.name }),
				[
					'label',
					['input', { type: 'checkbox', checked: t.attrs.checked ? 'checked' : null }],
					['span']
				],
				['div', 0]
			];
		},
		addKeyboardShortcuts() {
			const t = {
				Enter: () => this.editor.commands.splitListItem(this.name),
				'Shift-Tab': () => this.editor.commands.liftListItem(this.name)
			};
			return this.options.nested
				? { ...t, Tab: () => this.editor.commands.sinkListItem(this.name) }
				: t;
		},
		addNodeView() {
			return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
				const s = document.createElement('li'),
					o = document.createElement('label'),
					i = document.createElement('span'),
					l = document.createElement('input'),
					a = document.createElement('div');
				return (
					(o.contentEditable = 'false'),
					(l.type = 'checkbox'),
					l.addEventListener('mousedown', (c) => c.preventDefault()),
					l.addEventListener('change', (c) => {
						if (!r.isEditable && !this.options.onReadOnlyChecked) {
							l.checked = !l.checked;
							return;
						}
						const { checked: u } = c.target;
						r.isEditable &&
							typeof n == 'function' &&
							r
								.chain()
								.focus(void 0, { scrollIntoView: !1 })
								.command(({ tr: d }) => {
									const f = n();
									if (typeof f != 'number') return !1;
									const p = d.doc.nodeAt(f);
									return (
										d.setNodeMarkup(f, void 0, { ...(p == null ? void 0 : p.attrs), checked: u }),
										!0
									);
								})
								.run(),
							!r.isEditable &&
								this.options.onReadOnlyChecked &&
								(this.options.onReadOnlyChecked(t, u) || (l.checked = !l.checked));
					}),
					Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
						s.setAttribute(c, u);
					}),
					(s.dataset.checked = t.attrs.checked),
					(l.checked = t.attrs.checked),
					o.append(l, i),
					s.append(o, a),
					Object.entries(e).forEach(([c, u]) => {
						s.setAttribute(c, u);
					}),
					{
						dom: s,
						contentDOM: a,
						update: (c) =>
							c.type !== this.type
								? !1
								: ((s.dataset.checked = c.attrs.checked), (l.checked = c.attrs.checked), !0)
					}
				);
			};
		},
		addInputRules() {
			return [
				Ut({
					find: Lg,
					type: this.type,
					getAttributes: (t) => ({ checked: t[t.length - 1] === 'x' })
				})
			];
		}
	}),
	Rg =
		'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2',
	Bg =
		'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2',
	Gt = (t, e) => {
		for (const n in e) t[n] = e[n];
		return t;
	},
	As = 'numeric',
	Es = 'ascii',
	Os = 'alpha',
	ln = 'asciinumeric',
	rn = 'alphanumeric',
	Ns = 'domain',
	Ca = 'emoji',
	zg = 'scheme',
	Hg = 'slashscheme',
	ts = 'whitespace';
function Vg(t, e) {
	return t in e || (e[t] = []), e[t];
}
function Ct(t, e, n) {
	e[As] && ((e[ln] = !0), (e[rn] = !0)),
		e[Es] && ((e[ln] = !0), (e[Os] = !0)),
		e[ln] && (e[rn] = !0),
		e[Os] && (e[rn] = !0),
		e[rn] && (e[Ns] = !0),
		e[Ca] && (e[Ns] = !0);
	for (const r in e) {
		const s = Vg(r, n);
		s.indexOf(t) < 0 && s.push(t);
	}
}
function Fg(t, e) {
	const n = {};
	for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
	return n;
}
function xe(t = null) {
	(this.j = {}), (this.jr = []), (this.jd = null), (this.t = t);
}
xe.groups = {};
xe.prototype = {
	accepts() {
		return !!this.t;
	},
	go(t) {
		const e = this,
			n = e.j[t];
		if (n) return n;
		for (let r = 0; r < e.jr.length; r++) {
			const s = e.jr[r][0],
				o = e.jr[r][1];
			if (o && s.test(t)) return o;
		}
		return e.jd;
	},
	has(t, e = !1) {
		return e ? t in this.j : !!this.go(t);
	},
	ta(t, e, n, r) {
		for (let s = 0; s < t.length; s++) this.tt(t[s], e, n, r);
	},
	tr(t, e, n, r) {
		r = r || xe.groups;
		let s;
		return e && e.j ? (s = e) : ((s = new xe(e)), n && r && Ct(e, n, r)), this.jr.push([t, s]), s;
	},
	ts(t, e, n, r) {
		let s = this;
		const o = t.length;
		if (!o) return s;
		for (let i = 0; i < o - 1; i++) s = s.tt(t[i]);
		return s.tt(t[o - 1], e, n, r);
	},
	tt(t, e, n, r) {
		r = r || xe.groups;
		const s = this;
		if (e && e.j) return (s.j[t] = e), e;
		const o = e;
		let i,
			l = s.go(t);
		if (
			(l
				? ((i = new xe()), Gt(i.j, l.j), i.jr.push.apply(i.jr, l.jr), (i.jd = l.jd), (i.t = l.t))
				: (i = new xe()),
			o)
		) {
			if (r)
				if (i.t && typeof i.t == 'string') {
					const a = Gt(Fg(i.t, r), n);
					Ct(o, a, r);
				} else n && Ct(o, n, r);
			i.t = o;
		}
		return (s.j[t] = i), i;
	}
};
const P = (t, e, n, r, s) => t.ta(e, n, r, s),
	Z = (t, e, n, r, s) => t.tr(e, n, r, s),
	Di = (t, e, n, r, s) => t.ts(e, n, r, s),
	$ = (t, e, n, r, s) => t.tt(e, n, r, s),
	Ye = 'WORD',
	Ds = 'UWORD',
	Ta = 'ASCIINUMERICAL',
	xa = 'ALPHANUMERICAL',
	kn = 'LOCALHOST',
	vs = 'TLD',
	_s = 'UTLD',
	Bn = 'SCHEME',
	It = 'SLASH_SCHEME',
	uo = 'NUM',
	Is = 'WS',
	fo = 'NL',
	an = 'OPENBRACE',
	cn = 'CLOSEBRACE',
	Zn = 'OPENBRACKET',
	er = 'CLOSEBRACKET',
	tr = 'OPENPAREN',
	nr = 'CLOSEPAREN',
	rr = 'OPENANGLEBRACKET',
	sr = 'CLOSEANGLEBRACKET',
	or = 'FULLWIDTHLEFTPAREN',
	ir = 'FULLWIDTHRIGHTPAREN',
	lr = 'LEFTCORNERBRACKET',
	ar = 'RIGHTCORNERBRACKET',
	cr = 'LEFTWHITECORNERBRACKET',
	ur = 'RIGHTWHITECORNERBRACKET',
	dr = 'FULLWIDTHLESSTHAN',
	fr = 'FULLWIDTHGREATERTHAN',
	pr = 'AMPERSAND',
	hr = 'APOSTROPHE',
	mr = 'ASTERISK',
	it = 'AT',
	gr = 'BACKSLASH',
	br = 'BACKTICK',
	kr = 'CARET',
	at = 'COLON',
	po = 'COMMA',
	yr = 'DOLLAR',
	je = 'DOT',
	$r = 'EQUALS',
	ho = 'EXCLAMATION',
	_e = 'HYPHEN',
	un = 'PERCENT',
	Sr = 'PIPE',
	Mr = 'PLUS',
	Cr = 'POUND',
	dn = 'QUERY',
	mo = 'QUOTE',
	wa = 'FULLWIDTHMIDDLEDOT',
	go = 'SEMI',
	Ke = 'SLASH',
	fn = 'TILDE',
	Tr = 'UNDERSCORE',
	Aa = 'EMOJI',
	xr = 'SYM';
var Ea = Object.freeze({
	__proto__: null,
	ALPHANUMERICAL: xa,
	AMPERSAND: pr,
	APOSTROPHE: hr,
	ASCIINUMERICAL: Ta,
	ASTERISK: mr,
	AT: it,
	BACKSLASH: gr,
	BACKTICK: br,
	CARET: kr,
	CLOSEANGLEBRACKET: sr,
	CLOSEBRACE: cn,
	CLOSEBRACKET: er,
	CLOSEPAREN: nr,
	COLON: at,
	COMMA: po,
	DOLLAR: yr,
	DOT: je,
	EMOJI: Aa,
	EQUALS: $r,
	EXCLAMATION: ho,
	FULLWIDTHGREATERTHAN: fr,
	FULLWIDTHLEFTPAREN: or,
	FULLWIDTHLESSTHAN: dr,
	FULLWIDTHMIDDLEDOT: wa,
	FULLWIDTHRIGHTPAREN: ir,
	HYPHEN: _e,
	LEFTCORNERBRACKET: lr,
	LEFTWHITECORNERBRACKET: cr,
	LOCALHOST: kn,
	NL: fo,
	NUM: uo,
	OPENANGLEBRACKET: rr,
	OPENBRACE: an,
	OPENBRACKET: Zn,
	OPENPAREN: tr,
	PERCENT: un,
	PIPE: Sr,
	PLUS: Mr,
	POUND: Cr,
	QUERY: dn,
	QUOTE: mo,
	RIGHTCORNERBRACKET: ar,
	RIGHTWHITECORNERBRACKET: ur,
	SCHEME: Bn,
	SEMI: go,
	SLASH: Ke,
	SLASH_SCHEME: It,
	SYM: xr,
	TILDE: fn,
	TLD: vs,
	UNDERSCORE: Tr,
	UTLD: _s,
	UWORD: Ds,
	WORD: Ye,
	WS: Is
});
const Qe = /[a-z]/,
	nn = new RegExp('\\p{L}', 'u'),
	ns = new RegExp('\\p{Emoji}', 'u'),
	Je = /\d/,
	rs = /\s/,
	vi = '\r',
	ss = `
`,
	jg = '️',
	Kg = '‍',
	is = '￼';
let vn = null,
	_n = null;
function Wg(t = []) {
	const e = {};
	xe.groups = e;
	const n = new xe();
	vn == null && (vn = _i(Rg)),
		_n == null && (_n = _i(Bg)),
		$(n, "'", hr),
		$(n, '{', an),
		$(n, '}', cn),
		$(n, '[', Zn),
		$(n, ']', er),
		$(n, '(', tr),
		$(n, ')', nr),
		$(n, '<', rr),
		$(n, '>', sr),
		$(n, '（', or),
		$(n, '）', ir),
		$(n, '「', lr),
		$(n, '」', ar),
		$(n, '『', cr),
		$(n, '』', ur),
		$(n, '＜', dr),
		$(n, '＞', fr),
		$(n, '&', pr),
		$(n, '*', mr),
		$(n, '@', it),
		$(n, '`', br),
		$(n, '^', kr),
		$(n, ':', at),
		$(n, ',', po),
		$(n, '$', yr),
		$(n, '.', je),
		$(n, '=', $r),
		$(n, '!', ho),
		$(n, '-', _e),
		$(n, '%', un),
		$(n, '|', Sr),
		$(n, '+', Mr),
		$(n, '#', Cr),
		$(n, '?', dn),
		$(n, '"', mo),
		$(n, '/', Ke),
		$(n, ';', go),
		$(n, '~', fn),
		$(n, '_', Tr),
		$(n, '\\', gr),
		$(n, '・', wa);
	const r = Z(n, Je, uo, { [As]: !0 });
	Z(r, Je, r);
	const s = Z(r, Qe, Ta, { [ln]: !0 }),
		o = Z(r, nn, xa, { [rn]: !0 }),
		i = Z(n, Qe, Ye, { [Es]: !0 });
	Z(i, Je, s), Z(i, Qe, i), Z(s, Je, s), Z(s, Qe, s);
	const l = Z(n, nn, Ds, { [Os]: !0 });
	Z(l, Qe), Z(l, Je, o), Z(l, nn, l), Z(o, Je, o), Z(o, Qe), Z(o, nn, o);
	const a = $(n, ss, fo, { [ts]: !0 }),
		c = $(n, vi, Is, { [ts]: !0 }),
		u = Z(n, rs, Is, { [ts]: !0 });
	$(n, is, u), $(c, ss, a), $(c, is, u), Z(c, rs, u), $(u, vi), $(u, ss), Z(u, rs, u), $(u, is, u);
	const d = Z(n, ns, Aa, { [Ca]: !0 });
	$(d, '#'), Z(d, ns, d), $(d, jg, d);
	const f = $(d, Kg);
	$(f, '#'), Z(f, ns, d);
	const p = [
			[Qe, i],
			[Je, s]
		],
		h = [
			[Qe, null],
			[nn, l],
			[Je, o]
		];
	for (let g = 0; g < vn.length; g++) nt(n, vn[g], vs, Ye, p);
	for (let g = 0; g < _n.length; g++) nt(n, _n[g], _s, Ds, h);
	Ct(vs, { tld: !0, ascii: !0 }, e),
		Ct(_s, { utld: !0, alpha: !0 }, e),
		nt(n, 'file', Bn, Ye, p),
		nt(n, 'mailto', Bn, Ye, p),
		nt(n, 'http', It, Ye, p),
		nt(n, 'https', It, Ye, p),
		nt(n, 'ftp', It, Ye, p),
		nt(n, 'ftps', It, Ye, p),
		Ct(Bn, { scheme: !0, ascii: !0 }, e),
		Ct(It, { slashscheme: !0, ascii: !0 }, e),
		(t = t.sort((g, m) => (g[0] > m[0] ? 1 : -1)));
	for (let g = 0; g < t.length; g++) {
		const m = t[g][0],
			k = t[g][1] ? { [zg]: !0 } : { [Hg]: !0 };
		m.indexOf('-') >= 0
			? (k[Ns] = !0)
			: Qe.test(m)
				? Je.test(m)
					? (k[ln] = !0)
					: (k[Es] = !0)
				: (k[As] = !0),
			Di(n, m, m, k);
	}
	return (
		Di(n, 'localhost', kn, { ascii: !0 }),
		(n.jd = new xe(xr)),
		{ start: n, tokens: Gt({ groups: e }, Ea) }
	);
}
function Oa(t, e) {
	const n = qg(e.replace(/[A-Z]/g, (l) => l.toLowerCase())),
		r = n.length,
		s = [];
	let o = 0,
		i = 0;
	for (; i < r; ) {
		let l = t,
			a = null,
			c = 0,
			u = null,
			d = -1,
			f = -1;
		for (; i < r && (a = l.go(n[i])); )
			(l = a),
				l.accepts() ? ((d = 0), (f = 0), (u = l)) : d >= 0 && ((d += n[i].length), f++),
				(c += n[i].length),
				(o += n[i].length),
				i++;
		(o -= d), (i -= f), (c -= d), s.push({ t: u.t, v: e.slice(o - c, o), s: o - c, e: o });
	}
	return s;
}
function qg(t) {
	const e = [],
		n = t.length;
	let r = 0;
	for (; r < n; ) {
		let s = t.charCodeAt(r),
			o,
			i =
				s < 55296 || s > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343
					? t[r]
					: t.slice(r, r + 2);
		e.push(i), (r += i.length);
	}
	return e;
}
function nt(t, e, n, r, s) {
	let o;
	const i = e.length;
	for (let l = 0; l < i - 1; l++) {
		const a = e[l];
		t.j[a] ? (o = t.j[a]) : ((o = new xe(r)), (o.jr = s.slice()), (t.j[a] = o)), (t = o);
	}
	return (o = new xe(n)), (o.jr = s.slice()), (t.j[e[i - 1]] = o), o;
}
function _i(t) {
	const e = [],
		n = [];
	let r = 0,
		s = '0123456789';
	for (; r < t.length; ) {
		let o = 0;
		for (; s.indexOf(t[r + o]) >= 0; ) o++;
		if (o > 0) {
			e.push(n.join(''));
			for (let i = parseInt(t.substring(r, r + o), 10); i > 0; i--) n.pop();
			r += o;
		} else n.push(t[r]), r++;
	}
	return e;
}
const yn = {
	defaultProtocol: 'http',
	events: null,
	format: Ii,
	formatHref: Ii,
	nl2br: !1,
	tagName: 'a',
	target: null,
	rel: null,
	validate: !0,
	truncate: 1 / 0,
	className: null,
	attributes: null,
	ignoreTags: [],
	render: null
};
function bo(t, e = null) {
	let n = Gt({}, yn);
	t && (n = Gt(n, t instanceof bo ? t.o : t));
	const r = n.ignoreTags,
		s = [];
	for (let o = 0; o < r.length; o++) s.push(r[o].toUpperCase());
	(this.o = n), e && (this.defaultRender = e), (this.ignoreTags = s);
}
bo.prototype = {
	o: yn,
	ignoreTags: [],
	defaultRender(t) {
		return t;
	},
	check(t) {
		return this.get('validate', t.toString(), t);
	},
	get(t, e, n) {
		const r = e != null;
		let s = this.o[t];
		return (
			s &&
			(typeof s == 'object'
				? ((s = n.t in s ? s[n.t] : yn[t]), typeof s == 'function' && r && (s = s(e, n)))
				: typeof s == 'function' && r && (s = s(e, n.t, n)),
			s)
		);
	},
	getObj(t, e, n) {
		let r = this.o[t];
		return typeof r == 'function' && e != null && (r = r(e, n.t, n)), r;
	},
	render(t) {
		const e = t.render(this);
		return (this.get('render', null, t) || this.defaultRender)(e, t.t, t);
	}
};
function Ii(t) {
	return t;
}
function Na(t, e) {
	(this.t = 'token'), (this.v = t), (this.tk = e);
}
Na.prototype = {
	isLink: !1,
	toString() {
		return this.v;
	},
	toHref(t) {
		return this.toString();
	},
	toFormattedString(t) {
		const e = this.toString(),
			n = t.get('truncate', e, this),
			r = t.get('format', e, this);
		return n && r.length > n ? r.substring(0, n) + '…' : r;
	},
	toFormattedHref(t) {
		return t.get('formatHref', this.toHref(t.get('defaultProtocol')), this);
	},
	startIndex() {
		return this.tk[0].s;
	},
	endIndex() {
		return this.tk[this.tk.length - 1].e;
	},
	toObject(t = yn.defaultProtocol) {
		return {
			type: this.t,
			value: this.toString(),
			isLink: this.isLink,
			href: this.toHref(t),
			start: this.startIndex(),
			end: this.endIndex()
		};
	},
	toFormattedObject(t) {
		return {
			type: this.t,
			value: this.toFormattedString(t),
			isLink: this.isLink,
			href: this.toFormattedHref(t),
			start: this.startIndex(),
			end: this.endIndex()
		};
	},
	validate(t) {
		return t.get('validate', this.toString(), this);
	},
	render(t) {
		const e = this,
			n = this.toHref(t.get('defaultProtocol')),
			r = t.get('formatHref', n, this),
			s = t.get('tagName', n, e),
			o = this.toFormattedString(t),
			i = {},
			l = t.get('className', n, e),
			a = t.get('target', n, e),
			c = t.get('rel', n, e),
			u = t.getObj('attributes', n, e),
			d = t.getObj('events', n, e);
		return (
			(i.href = r),
			l && (i.class = l),
			a && (i.target = a),
			c && (i.rel = c),
			u && Gt(i, u),
			{ tagName: s, attributes: i, content: o, eventListeners: d }
		);
	}
};
function Br(t, e) {
	class n extends Na {
		constructor(s, o) {
			super(s, o), (this.t = t);
		}
	}
	for (const r in e) n.prototype[r] = e[r];
	return (n.t = t), n;
}
const Li = Br('email', {
		isLink: !0,
		toHref() {
			return 'mailto:' + this.toString();
		}
	}),
	Pi = Br('text'),
	Ug = Br('nl'),
	In = Br('url', {
		isLink: !0,
		toHref(t = yn.defaultProtocol) {
			return this.hasProtocol() ? this.v : `${t}://${this.v}`;
		},
		hasProtocol() {
			const t = this.tk;
			return t.length >= 2 && t[0].t !== kn && t[1].t === at;
		}
	}),
	ve = (t) => new xe(t);
function Gg({ groups: t }) {
	const e = t.domain.concat([
			pr,
			mr,
			it,
			gr,
			br,
			kr,
			yr,
			$r,
			_e,
			uo,
			un,
			Sr,
			Mr,
			Cr,
			Ke,
			xr,
			fn,
			Tr
		]),
		n = [
			hr,
			at,
			po,
			je,
			ho,
			un,
			dn,
			mo,
			go,
			rr,
			sr,
			an,
			cn,
			er,
			Zn,
			tr,
			nr,
			or,
			ir,
			lr,
			ar,
			cr,
			ur,
			dr,
			fr
		],
		r = [pr, hr, mr, gr, br, kr, yr, $r, _e, an, cn, un, Sr, Mr, Cr, dn, Ke, xr, fn, Tr],
		s = ve(),
		o = $(s, fn);
	P(o, r, o), P(o, t.domain, o);
	const i = ve(),
		l = ve(),
		a = ve();
	P(s, t.domain, i), P(s, t.scheme, l), P(s, t.slashscheme, a), P(i, r, o), P(i, t.domain, i);
	const c = $(i, it);
	$(o, it, c), $(l, it, c), $(a, it, c);
	const u = $(o, je);
	P(u, r, o), P(u, t.domain, o);
	const d = ve();
	P(c, t.domain, d), P(d, t.domain, d);
	const f = $(d, je);
	P(f, t.domain, d);
	const p = ve(Li);
	P(f, t.tld, p), P(f, t.utld, p), $(c, kn, p);
	const h = $(d, _e);
	$(h, _e, h), P(h, t.domain, d), P(p, t.domain, d), $(p, je, f), $(p, _e, h);
	const g = $(p, at);
	P(g, t.numeric, Li);
	const m = $(i, _e),
		b = $(i, je);
	$(m, _e, m), P(m, t.domain, i), P(b, r, o), P(b, t.domain, i);
	const k = ve(In);
	P(b, t.tld, k),
		P(b, t.utld, k),
		P(k, t.domain, i),
		P(k, r, o),
		$(k, je, b),
		$(k, _e, m),
		$(k, it, c);
	const v = $(k, at),
		I = ve(In);
	P(v, t.numeric, I);
	const T = ve(In),
		y = ve();
	P(T, e, T), P(T, n, y), P(y, e, T), P(y, n, y), $(k, Ke, T), $(I, Ke, T);
	const D = $(l, at),
		C = $(a, at),
		F = $(C, Ke),
		N = $(F, Ke);
	P(l, t.domain, i),
		$(l, je, b),
		$(l, _e, m),
		P(a, t.domain, i),
		$(a, je, b),
		$(a, _e, m),
		P(D, t.domain, T),
		$(D, Ke, T),
		$(D, dn, T),
		P(N, t.domain, T),
		P(N, e, T),
		$(N, Ke, T);
	const H = [
		[an, cn],
		[Zn, er],
		[tr, nr],
		[rr, sr],
		[or, ir],
		[lr, ar],
		[cr, ur],
		[dr, fr]
	];
	for (let ue = 0; ue < H.length; ue++) {
		const [Ce, R] = H[ue],
			j = $(T, Ce);
		$(y, Ce, j), $(j, R, T);
		const Te = ve(In);
		P(j, e, Te);
		const De = ve();
		P(j, n), P(Te, e, Te), P(Te, n, De), P(De, e, Te), P(De, n, De), $(Te, R, T), $(De, R, T);
	}
	return $(s, kn, k), $(s, fo, Ug), { start: s, tokens: Ea };
}
function Qg(t, e, n) {
	let r = n.length,
		s = 0,
		o = [],
		i = [];
	for (; s < r; ) {
		let l = t,
			a = null,
			c = null,
			u = 0,
			d = null,
			f = -1;
		for (; s < r && !(a = l.go(n[s].t)); ) i.push(n[s++]);
		for (; s < r && (c = a || l.go(n[s].t)); )
			(a = null), (l = c), l.accepts() ? ((f = 0), (d = l)) : f >= 0 && f++, s++, u++;
		if (f < 0) (s -= u), s < r && (i.push(n[s]), s++);
		else {
			i.length > 0 && (o.push(ls(Pi, e, i)), (i = [])), (s -= f), (u -= f);
			const p = d.t,
				h = n.slice(s - u, s);
			o.push(ls(p, e, h));
		}
	}
	return i.length > 0 && o.push(ls(Pi, e, i)), o;
}
function ls(t, e, n) {
	const r = n[0].s,
		s = n[n.length - 1].e,
		o = e.slice(r, s);
	return new t(o, n);
}
const Jg = (typeof console < 'u' && console && console.warn) || (() => {}),
	Yg =
		'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.',
	G = {
		scanner: null,
		parser: null,
		tokenQueue: [],
		pluginQueue: [],
		customSchemes: [],
		initialized: !1
	};
function Xg() {
	return (
		(xe.groups = {}),
		(G.scanner = null),
		(G.parser = null),
		(G.tokenQueue = []),
		(G.pluginQueue = []),
		(G.customSchemes = []),
		(G.initialized = !1),
		G
	);
}
function Ri(t, e = !1) {
	if (
		(G.initialized &&
			Jg(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Yg}`),
		!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
	)
		throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
	G.customSchemes.push([t, e]);
}
function Zg() {
	G.scanner = Wg(G.customSchemes);
	for (let t = 0; t < G.tokenQueue.length; t++) G.tokenQueue[t][1]({ scanner: G.scanner });
	G.parser = Gg(G.scanner.tokens);
	for (let t = 0; t < G.pluginQueue.length; t++)
		G.pluginQueue[t][1]({ scanner: G.scanner, parser: G.parser });
	return (G.initialized = !0), G;
}
function ko(t) {
	return G.initialized || Zg(), Qg(G.parser.start, t, Oa(G.scanner.start, t));
}
ko.scan = Oa;
function Da(t, e = null, n = null) {
	if (e && typeof e == 'object') {
		if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
		(n = e), (e = null);
	}
	const r = new bo(n),
		s = ko(t),
		o = [];
	for (let i = 0; i < s.length; i++) {
		const l = s[i];
		l.isLink && (!e || l.t === e) && r.check(l) && o.push(l.toFormattedObject(r));
	}
	return o;
}
function eb(t) {
	return t.length === 1
		? t[0].isLink
		: t.length === 3 && t[1].isLink
			? ['()', '[]'].includes(t[0].value + t[2].value)
			: !1;
}
function tb(t) {
	return new ie({
		key: new me('autolink'),
		appendTransaction: (e, n, r) => {
			const s = e.some((c) => c.docChanged) && !n.doc.eq(r.doc),
				o = e.some((c) => c.getMeta('preventAutolink'));
			if (!s || o) return;
			const { tr: i } = r,
				l = lp(n.doc, [...e]);
			if (
				(mp(l).forEach(({ newRange: c }) => {
					const u = cp(r.doc, c, (p) => p.isTextblock);
					let d, f;
					if (
						(u.length > 1
							? ((d = u[0]), (f = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, ' ')))
							: u.length &&
								r.doc.textBetween(c.from, c.to, ' ', ' ').endsWith(' ') &&
								((d = u[0]), (f = r.doc.textBetween(d.pos, c.to, void 0, ' '))),
						d && f)
					) {
						const p = f.split(' ').filter((b) => b !== '');
						if (p.length <= 0) return !1;
						const h = p[p.length - 1],
							g = d.pos + f.lastIndexOf(h);
						if (!h) return !1;
						const m = ko(h).map((b) => b.toObject(t.defaultProtocol));
						if (!eb(m)) return !1;
						m.filter((b) => b.isLink)
							.map((b) => ({ ...b, from: g + b.start + 1, to: g + b.end + 1 }))
							.filter((b) =>
								r.schema.marks.code ? !r.doc.rangeHasMark(b.from, b.to, r.schema.marks.code) : !0
							)
							.filter((b) => t.validate(b.value))
							.filter((b) => t.shouldAutoLink(b.value))
							.forEach((b) => {
								io(b.from, b.to, r.doc).some((k) => k.mark.type === t.type) ||
									i.addMark(b.from, b.to, t.type.create({ href: b.href }));
							});
					}
				}),
				!!i.steps.length)
			)
				return i;
		}
	});
}
function nb(t) {
	return new ie({
		key: new me('handleClickLink'),
		props: {
			handleClick: (e, n, r) => {
				var s, o;
				if (r.button !== 0 || !e.editable) return !1;
				let i = r.target;
				const l = [];
				for (; i.nodeName !== 'DIV'; ) l.push(i), (i = i.parentNode);
				if (!l.find((f) => f.nodeName === 'A')) return !1;
				const a = ta(e.state, t.type.name),
					c = r.target,
					u = (s = c == null ? void 0 : c.href) !== null && s !== void 0 ? s : a.href,
					d = (o = c == null ? void 0 : c.target) !== null && o !== void 0 ? o : a.target;
				return c && u ? (window.open(u, d), !0) : !1;
			}
		}
	});
}
function rb(t) {
	return new ie({
		key: new me('handlePasteLink'),
		props: {
			handlePaste: (e, n, r) => {
				const { state: s } = e,
					{ selection: o } = s,
					{ empty: i } = o;
				if (i) return !1;
				let l = '';
				r.content.forEach((c) => {
					l += c.textContent;
				});
				const a = Da(l, { defaultProtocol: t.defaultProtocol }).find(
					(c) => c.isLink && c.value === l
				);
				return !l || !a ? !1 : t.editor.commands.setMark(t.type, { href: a.href });
			}
		}
	});
}
const sb = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function bt(t, e) {
	const n = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];
	return (
		e &&
			e.forEach((r) => {
				const s = typeof r == 'string' ? r : r.scheme;
				s && n.push(s);
			}),
		!t ||
			t
				.replace(sb, '')
				.match(new RegExp(`^(?:(?:${n.join('|')}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, 'i'))
	);
}
const ob = Me.create({
		name: 'link',
		priority: 1e3,
		keepOnSplit: !1,
		exitable: !0,
		onCreate() {
			this.options.validate &&
				!this.options.shouldAutoLink &&
				((this.options.shouldAutoLink = this.options.validate),
				console.warn(
					'The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.'
				)),
				this.options.protocols.forEach((t) => {
					if (typeof t == 'string') {
						Ri(t);
						return;
					}
					Ri(t.scheme, t.optionalSlashes);
				});
		},
		onDestroy() {
			Xg();
		},
		inclusive() {
			return this.options.autolink;
		},
		addOptions() {
			return {
				openOnClick: !0,
				linkOnPaste: !0,
				autolink: !0,
				protocols: [],
				defaultProtocol: 'http',
				HTMLAttributes: { target: '_blank', rel: 'noopener noreferrer nofollow', class: null },
				isAllowedUri: (t, e) => !!bt(t, e.protocols),
				validate: (t) => !!t,
				shouldAutoLink: (t) => !!t
			};
		},
		addAttributes() {
			return {
				href: {
					default: null,
					parseHTML(t) {
						return t.getAttribute('href');
					}
				},
				target: { default: this.options.HTMLAttributes.target },
				rel: { default: this.options.HTMLAttributes.rel },
				class: { default: this.options.HTMLAttributes.class }
			};
		},
		parseHTML() {
			return [
				{
					tag: 'a[href]',
					getAttrs: (t) => {
						const e = t.getAttribute('href');
						return !e ||
							!this.options.isAllowedUri(e, {
								defaultValidate: (n) => !!bt(n, this.options.protocols),
								protocols: this.options.protocols,
								defaultProtocol: this.options.defaultProtocol
							})
							? !1
							: null;
					}
				}
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return this.options.isAllowedUri(t.href, {
				defaultValidate: (e) => !!bt(e, this.options.protocols),
				protocols: this.options.protocols,
				defaultProtocol: this.options.defaultProtocol
			})
				? ['a', le(this.options.HTMLAttributes, t), 0]
				: ['a', le(this.options.HTMLAttributes, { ...t, href: '' }), 0];
		},
		addCommands() {
			return {
				setLink:
					(t) =>
					({ chain: e }) => {
						const { href: n } = t;
						return this.options.isAllowedUri(n, {
							defaultValidate: (r) => !!bt(r, this.options.protocols),
							protocols: this.options.protocols,
							defaultProtocol: this.options.defaultProtocol
						})
							? e().setMark(this.name, t).setMeta('preventAutolink', !0).run()
							: !1;
					},
				toggleLink:
					(t) =>
					({ chain: e }) => {
						const { href: n } = t;
						return this.options.isAllowedUri(n, {
							defaultValidate: (r) => !!bt(r, this.options.protocols),
							protocols: this.options.protocols,
							defaultProtocol: this.options.defaultProtocol
						})
							? e()
									.toggleMark(this.name, t, { extendEmptyMarkRange: !0 })
									.setMeta('preventAutolink', !0)
									.run()
							: !1;
					},
				unsetLink:
					() =>
					({ chain: t }) =>
						t()
							.unsetMark(this.name, { extendEmptyMarkRange: !0 })
							.setMeta('preventAutolink', !0)
							.run()
			};
		},
		addPasteRules() {
			return [
				Nt({
					find: (t) => {
						const e = [];
						if (t) {
							const { protocols: n, defaultProtocol: r } = this.options,
								s = Da(t).filter(
									(o) =>
										o.isLink &&
										this.options.isAllowedUri(o.value, {
											defaultValidate: (i) => !!bt(i, n),
											protocols: n,
											defaultProtocol: r
										})
								);
							s.length &&
								s.forEach((o) => e.push({ text: o.value, data: { href: o.href }, index: o.start }));
						}
						return e;
					},
					type: this.type,
					getAttributes: (t) => {
						var e;
						return { href: (e = t.data) === null || e === void 0 ? void 0 : e.href };
					}
				})
			];
		},
		addProseMirrorPlugins() {
			const t = [],
				{ protocols: e, defaultProtocol: n } = this.options;
			return (
				this.options.autolink &&
					t.push(
						tb({
							type: this.type,
							defaultProtocol: this.options.defaultProtocol,
							validate: (r) =>
								this.options.isAllowedUri(r, {
									defaultValidate: (s) => !!bt(s, e),
									protocols: e,
									defaultProtocol: n
								}),
							shouldAutoLink: this.options.shouldAutoLink
						})
					),
				this.options.openOnClick === !0 && t.push(nb({ type: this.type })),
				this.options.linkOnPaste &&
					t.push(
						rb({
							editor: this.editor,
							defaultProtocol: this.options.defaultProtocol,
							type: this.type
						})
					),
				t
			);
		}
	}),
	ib = re.create({
		name: 'characterCount',
		addOptions() {
			return {
				limit: null,
				mode: 'textSize',
				textCounter: (t) => t.length,
				wordCounter: (t) => t.split(' ').filter((e) => e !== '').length
			};
		},
		addStorage() {
			return { characters: () => 0, words: () => 0 };
		},
		onBeforeCreate() {
			(this.storage.characters = (t) => {
				const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
				if (((t == null ? void 0 : t.mode) || this.options.mode) === 'textSize') {
					const r = e.textBetween(0, e.content.size, void 0, ' ');
					return this.options.textCounter(r);
				}
				return e.nodeSize;
			}),
				(this.storage.words = (t) => {
					const e = (t == null ? void 0 : t.node) || this.editor.state.doc,
						n = e.textBetween(0, e.content.size, ' ', ' ');
					return this.options.wordCounter(n);
				});
		},
		addProseMirrorPlugins() {
			let t = !1;
			return [
				new ie({
					key: new me('characterCount'),
					appendTransaction: (e, n, r) => {
						if (t) return;
						const s = this.options.limit;
						if (s == null || s === 0) {
							t = !0;
							return;
						}
						const o = this.storage.characters({ node: r.doc });
						if (o > s) {
							const i = o - s,
								l = 0,
								a = i;
							console.warn(
								`[CharacterCount] Initial content exceeded limit of ${s} characters. Content was automatically trimmed.`
							);
							const c = r.tr.deleteRange(l, a);
							return (t = !0), c;
						}
						t = !0;
					},
					filterTransaction: (e, n) => {
						const r = this.options.limit;
						if (!e.docChanged || r === 0 || r === null || r === void 0) return !0;
						const s = this.storage.characters({ node: n.doc }),
							o = this.storage.characters({ node: e.doc });
						if (o <= r || (s > r && o > r && o <= s)) return !0;
						if ((s > r && o > r && o > s) || !e.getMeta('paste')) return !1;
						const l = e.selection.$head.pos,
							a = o - r,
							c = l - a,
							u = l;
						return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > r);
					}
				})
			];
		}
	}),
	lb = (t, e, n) => RegExp(e ? t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') : t, n ? 'gu' : 'gui');
function ab(t, e, n, r) {
	const s = [],
		o = [];
	let i = [],
		l = 0;
	if (!e) return { decorationsToReturn: Y.empty, results: [] };
	t == null ||
		t.descendants((a, c) => {
			a.isText
				? i[l]
					? (i[l] = { text: i[l].text + a.text, pos: i[l].pos })
					: (i[l] = { text: `${a.text}`, pos: c })
				: (l += 1);
		}),
		(i = i.filter(Boolean));
	for (const a of i) {
		const { text: c, pos: u } = a,
			d = Array.from(c.matchAll(e)).filter(([f]) => f.trim());
		for (const f of d) {
			if (f[0] === '') break;
			f.index !== void 0 && o.push({ from: u + f.index, to: u + f.index + f[0].length });
		}
	}
	for (let a = 0; a < o.length; a += 1) {
		const c = o[a],
			u = a === r ? `${n} ${n}-current` : n,
			d = Ne.inline(c.from, c.to, { class: u });
		s.push(d);
	}
	return { decorationsToReturn: Y.create(t, s), results: o };
}
const cb = (t, e, { state: n, dispatch: r }) => {
		if (!e[0]) return;
		const { from: o, to: i } = e[0];
		r && r(n.tr.insertText(t, o, i));
	},
	ub = (t, e, n, r) => {
		const s = e + 1;
		if (!r[s]) return null;
		const { from: o, to: i } = r[e],
			l = i - o - t.length + n,
			{ from: a, to: c } = r[s];
		return (r[s] = { to: c - l, from: a - l }), [l, r];
	},
	db = (t, e, { tr: n, dispatch: r }) => {
		let s = 0,
			o = e.slice();
		if (o.length) {
			for (let i = 0; i < o.length; i += 1) {
				const { from: l, to: a } = o[i];
				n.insertText(t, l, a);
				const c = ub(t, i, s, o);
				c && ((s = c[0]), (o = c[1]));
			}
			r && r(n);
		}
	},
	fb = new me('searchAndReplacePlugin'),
	pb = re.create({
		name: 'searchAndReplace',
		addOptions() {
			return { searchResultClass: 'search-result', disableRegex: !0 };
		},
		addStorage() {
			return {
				searchTerm: '',
				replaceTerm: '',
				results: [],
				lastSearchTerm: '',
				caseSensitive: !1,
				lastCaseSensitive: !1,
				resultIndex: 0,
				lastResultIndex: 0
			};
		},
		addCommands() {
			return {
				setSearchTerm:
					(t) =>
					({ editor: e }) => ((e.storage.searchAndReplace.searchTerm = t), !1),
				setReplaceTerm:
					(t) =>
					({ editor: e }) => ((e.storage.searchAndReplace.replaceTerm = t), !1),
				setCaseSensitive:
					(t) =>
					({ editor: e }) => ((e.storage.searchAndReplace.caseSensitive = t), !1),
				resetIndex:
					() =>
					({ editor: t }) => ((t.storage.searchAndReplace.resultIndex = 0), !1),
				nextSearchResult:
					() =>
					({ editor: t }) => {
						const { results: e, resultIndex: n } = t.storage.searchAndReplace,
							r = n + 1;
						return (
							e[r]
								? (t.storage.searchAndReplace.resultIndex = r)
								: (t.storage.searchAndReplace.resultIndex = 0),
							!1
						);
					},
				previousSearchResult:
					() =>
					({ editor: t }) => {
						const { results: e, resultIndex: n } = t.storage.searchAndReplace,
							r = n - 1;
						return (
							e[r]
								? (t.storage.searchAndReplace.resultIndex = r)
								: (t.storage.searchAndReplace.resultIndex = e.length - 1),
							!1
						);
					},
				replace:
					() =>
					({ editor: t, state: e, dispatch: n }) => {
						const { replaceTerm: r, results: s } = t.storage.searchAndReplace;
						return cb(r, s, { state: e, dispatch: n }), !1;
					},
				replaceAll:
					() =>
					({ editor: t, tr: e, dispatch: n }) => {
						const { replaceTerm: r, results: s } = t.storage.searchAndReplace;
						return db(r, s, { tr: e, dispatch: n }), !1;
					},
				setSearchResult:
					(t) =>
					({ editor: e }) => {
						const { results: n } = e.storage.searchAndReplace;
						return (
							t >= 0 && t < n.length
								? (e.storage.searchAndReplace.resultIndex = t)
								: console.warn(
										`Search result index out of range. Valid range: 0 to ${n.length - 1}`
									),
							!1
						);
					}
			};
		},
		addProseMirrorPlugins() {
			const t = this.editor,
				{ searchResultClass: e, disableRegex: n } = this.options,
				r = (i) => (t.storage.searchAndReplace.lastSearchTerm = i),
				s = (i) => (t.storage.searchAndReplace.lastCaseSensitive = i),
				o = (i) => (t.storage.searchAndReplace.lastResultIndex = i);
			return [
				new ie({
					key: fb,
					state: {
						init: () => Y.empty,
						apply({ doc: i, docChanged: l }, a) {
							const {
								searchTerm: c,
								lastSearchTerm: u,
								caseSensitive: d,
								lastCaseSensitive: f,
								resultIndex: p,
								lastResultIndex: h
							} = t.storage.searchAndReplace;
							if (!l && u === c && f === d && h === p) return a;
							if ((r(c), s(d), o(p), !c)) return (t.storage.searchAndReplace.results = []), Y.empty;
							const { decorationsToReturn: g, results: m } = ab(i, lb(c, n, d), e, p);
							return (t.storage.searchAndReplace.results = m), g;
						}
					},
					props: {
						decorations(i) {
							return this.getState(i);
						}
					}
				})
			];
		}
	});
function hb(t) {
	let e, n, r, s, o, i, l;
	return (
		(n = new ze({ props: { options: Ae['note:save'], callback: t[2] } })),
		(s = new ze({ props: { options: Ae['note:copy-path'], callback: t[3] } })),
		{
			c() {
				(e = ke('div')), O(n.$$.fragment), (r = W()), O(s.$$.fragment), this.h();
			},
			l(a) {
				e = be(a, 'DIV', { spellcheck: !0, autocorrect: !0, class: !0 });
				var c = we(e);
				E(n.$$.fragment, c), (r = K(c)), E(s.$$.fragment, c), c.forEach(z), this.h();
			},
			h() {
				U(e, 'spellcheck', (o = t[1].editor.spell_check)),
					U(e, 'autocorrect', (i = t[1].editor.auto_correct.toString())),
					U(e, 'class', 'w-full h-[calc(100%-97px)] px-8 svelte-zc20w6');
			},
			m(a, c) {
				Q(a, e, c), A(n, e, null), J(e, r), A(s, e, null), t[4](e), (l = !0);
			},
			p(a, [c]) {
				(!l || (c & 2 && o !== (o = a[1].editor.spell_check))) && U(e, 'spellcheck', o),
					(!l || (c & 2 && i !== (i = a[1].editor.auto_correct.toString()))) &&
						U(e, 'autocorrect', i);
			},
			i(a) {
				l || (S(n.$$.fragment, a), S(s.$$.fragment, a), (l = !0));
			},
			o(a) {
				M(n.$$.fragment, a), M(s.$$.fragment, a), (l = !1);
			},
			d(a) {
				a && z(e), w(n), w(s), t[4](null);
			}
		}
	);
}
function mb(t, e, n) {
	let r, s;
	se(t, Rs, (d) => n(1, (r = d))), se(t, Rt, (d) => n(7, (s = d)));
	let o, i, l;
	Pa(() => {
		i = new Vp({
			element: o,
			extensions: [
				Vh.configure({
					document: !1,
					hardBreak: !1,
					paragraph: { HTMLAttributes: { class: 'min-w-[1px] my-1 leading-5' } }
				}),
				ib,
				ua,
				pb.configure({ searchResultClass: 'search-result', disableRegex: !1 }),
				um,
				Ig,
				Pg.configure({
					HTMLAttributes: {
						class:
							'flex items-start pl-1.5 gap-2 [&>div]:mb-0 [&>label]:mt-0 [&>div]:w-full [&>div>p]:inline-block [&>label]:inline-flex [&>label]:items-center [&>label>input]:rounded-md'
					},
					nested: !0
				}),
				ob.configure({
					HTMLAttributes: {
						class:
							'text-primary underline hover:text-primary/80 transition-all cursor-pointer text-base [&>*]:font-normal'
					}
				}),
				_g.configure({ linkify: !0, transformPastedText: !0 })
			],
			editorProps: {
				attributes: {
					class: 'prose prose-theme mx-auto focus:outline-none min-h-full pb-6 select-text'
				}
			},
			onTransaction: () => {
				(i = i), Bt.set(i);
			},
			onUpdate: async () => {
				l && clearTimeout(l),
					(l = setTimeout(async () => {
						r.editor.auto_save &&
							(console.log('Saving note...'),
							wo(s)
								.then(() => {
									Bt.notifySaveEvent();
								})
								.catch((d) => {
									console.error('Error saving note:', d);
								}));
					}, r.editor.auto_save_debounce));
			}
		});
	}),
		Ra(() => {
			Bt && i.destroy();
		});
	const a = () => wo(Mo(Rt) ?? ''),
		c = () => navigator.clipboard.writeText(Mo(Rt) ?? '');
	function u(d) {
		wr[d ? 'unshift' : 'push'](() => {
			(o = d), n(0, o);
		});
	}
	return [o, r, a, c, u];
}
class Db extends Jt {
	constructor(e) {
		super(), Yt(this, e, mb, hb, Qt, {});
	}
}
export { Db as E, xb as I, wb as S, Ab as T };
